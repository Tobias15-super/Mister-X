var pe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nA(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Z0(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var eg = {}, tg = {}, at = {}, Lt = {};
const iA = {}, aA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: iA
}, Symbol.toStringTag, { value: "Module" })), ge = /* @__PURE__ */ Z0(aA);
var rg = {}, ng = {}, ya = {}, Lr = {}, io = {}, gs = Object.prototype.hasOwnProperty, ig = Object.prototype.toString, Md = Object.defineProperty, Vd = Object.getOwnPropertyDescriptor, $d = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : ig.call(e) === "[object Array]";
}, Hd = function(e) {
  if (!e || ig.call(e) !== "[object Object]")
    return !1;
  var r = gs.call(e, "constructor"), n = e.constructor && e.constructor.prototype && gs.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !r && !n)
    return !1;
  var i;
  for (i in e)
    ;
  return typeof i > "u" || gs.call(e, i);
}, Kd = function(e, r) {
  Md && r.name === "__proto__" ? Md(e, r.name, {
    enumerable: !0,
    configurable: !0,
    value: r.newValue,
    writable: !0
  }) : e[r.name] = r.newValue;
}, Gd = function(e, r) {
  if (r === "__proto__")
    if (gs.call(e, r)) {
      if (Vd)
        return Vd(e, r).value;
    } else return;
  return e[r];
}, ag = function t() {
  var e, r, n, i, a, s, o = arguments[0], l = 1, u = arguments.length, f = !1;
  for (typeof o == "boolean" && (f = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); l < u; ++l)
    if (e = arguments[l], e != null)
      for (r in e)
        n = Gd(o, r), i = Gd(e, r), o !== i && (f && i && (Hd(i) || (a = $d(i))) ? (a ? (a = !1, s = n && $d(n) ? n : []) : s = n && Hd(n) ? n : {}, Kd(o, { name: r, newValue: t(f, s, i) })) : typeof i < "u" && Kd(o, { name: r, newValue: i }));
  return o;
}, Al = { exports: {} };
(function(t, e) {
  var r = function() {
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof pe < "u")
      return pe;
    throw new Error("unable to locate global object");
  }, n = r();
  t.exports = e = n.fetch, n.fetch && (e.default = n.fetch.bind(n)), e.Headers = n.Headers, e.Request = n.Request, e.Response = n.Response;
})(Al, Al.exports);
var sA = Al.exports;
const jr = (t) => t !== null && typeof t == "object" && typeof t.pipe == "function";
jr.writable = (t) => jr(t) && t.writable !== !1 && typeof t._write == "function" && typeof t._writableState == "object";
jr.readable = (t) => jr(t) && t.readable !== !1 && typeof t._read == "function" && typeof t._readableState == "object";
jr.duplex = (t) => jr.writable(t) && jr.readable(t);
jr.transform = (t) => jr.duplex(t) && typeof t._transform == "function";
var oA = jr, ef = {}, ao = {};
const cA = "gaxios", uA = "6.7.1", lA = "A simple common HTTP client specifically for Google APIs and services.", fA = "build/src/index.js", dA = "build/src/index.d.ts", hA = [
  "build/src"
], pA = {
  lint: "gts check",
  test: "c8 mocha build/test",
  "presystem-test": "npm run compile",
  "system-test": "mocha build/system-test --timeout 80000",
  compile: "tsc -p .",
  fix: "gts fix",
  prepare: "npm run compile",
  pretest: "npm run compile",
  webpack: "webpack",
  "prebrowser-test": "npm run compile",
  "browser-test": "node build/browser-test/browser-test-runner.js",
  docs: "compodoc src/",
  "docs-test": "linkinator docs",
  "predocs-test": "npm run docs",
  "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
  prelint: "cd samples; npm link ../; npm install",
  clean: "gts clean",
  precompile: "gts clean"
}, gA = "googleapis/gaxios", yA = [
  "google"
], mA = {
  node: ">=14"
}, EA = "Google, LLC", vA = "Apache-2.0", AA = {
  "@babel/plugin-proposal-private-methods": "^7.18.6",
  "@compodoc/compodoc": "1.1.19",
  "@types/cors": "^2.8.6",
  "@types/express": "^4.16.1",
  "@types/extend": "^3.0.1",
  "@types/mocha": "^9.0.0",
  "@types/multiparty": "0.0.36",
  "@types/mv": "^2.1.0",
  "@types/ncp": "^2.0.1",
  "@types/node": "^20.0.0",
  "@types/node-fetch": "^2.5.7",
  "@types/sinon": "^17.0.0",
  "@types/tmp": "0.2.6",
  "@types/uuid": "^10.0.0",
  "abort-controller": "^3.0.0",
  assert: "^2.0.0",
  browserify: "^17.0.0",
  c8: "^8.0.0",
  cheerio: "1.0.0-rc.10",
  cors: "^2.8.5",
  execa: "^5.0.0",
  express: "^4.16.4",
  "form-data": "^4.0.0",
  gts: "^5.0.0",
  "is-docker": "^2.0.0",
  karma: "^6.0.0",
  "karma-chrome-launcher": "^3.0.0",
  "karma-coverage": "^2.0.0",
  "karma-firefox-launcher": "^2.0.0",
  "karma-mocha": "^2.0.0",
  "karma-remap-coverage": "^0.1.5",
  "karma-sourcemap-loader": "^0.4.0",
  "karma-webpack": "5.0.0",
  linkinator: "^3.0.0",
  mocha: "^8.0.0",
  multiparty: "^4.2.1",
  mv: "^2.1.1",
  ncp: "^2.0.0",
  nock: "^13.0.0",
  "null-loader": "^4.0.0",
  puppeteer: "^19.0.0",
  sinon: "^18.0.0",
  "stream-browserify": "^3.0.0",
  tmp: "0.2.3",
  "ts-loader": "^8.0.0",
  typescript: "^5.1.6",
  webpack: "^5.35.0",
  "webpack-cli": "^4.0.0"
}, CA = {
  extend: "^3.0.2",
  "https-proxy-agent": "^7.0.1",
  "is-stream": "^2.0.0",
  "node-fetch": "^2.6.9",
  uuid: "^9.0.1"
}, _A = {
  name: cA,
  version: uA,
  description: lA,
  main: fA,
  types: dA,
  files: hA,
  scripts: pA,
  repository: gA,
  keywords: yA,
  engines: mA,
  author: EA,
  license: vA,
  devDependencies: AA,
  dependencies: CA
};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.pkg = void 0;
ao.pkg = _A;
(function(t) {
  var e = pe && pe.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  }, r;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.GaxiosError = t.GAXIOS_ERROR_SYMBOL = void 0, t.defaultErrorRedactor = l;
  const n = ge, i = ao, a = e(ag);
  t.GAXIOS_ERROR_SYMBOL = Symbol.for(`${i.pkg.name}-gaxios-error`);
  class s extends Error {
    /**
     * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
     *
     * @see {@link GAXIOS_ERROR_SYMBOL}
     * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
     */
    static [(r = t.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](f) {
      return f && typeof f == "object" && t.GAXIOS_ERROR_SYMBOL in f && f[t.GAXIOS_ERROR_SYMBOL] === i.pkg.version ? !0 : Function.prototype[Symbol.hasInstance].call(s, f);
    }
    constructor(f, y, m, p) {
      var S;
      if (super(f), this.config = y, this.response = m, this.error = p, this[r] = i.pkg.version, this.config = (0, a.default)(!0, {}, y), this.response && (this.response.config = (0, a.default)(!0, {}, this.response.config)), this.response) {
        try {
          this.response.data = o(this.config.responseType, (S = this.response) === null || S === void 0 ? void 0 : S.data);
        } catch {
        }
        this.status = this.response.status;
      }
      p && "code" in p && p.code && (this.code = p.code), y.errorRedactor && y.errorRedactor({
        config: this.config,
        response: this.response
      });
    }
  }
  t.GaxiosError = s;
  function o(u, f) {
    switch (u) {
      case "stream":
        return f;
      case "json":
        return JSON.parse(JSON.stringify(f));
      case "arraybuffer":
        return JSON.parse(Buffer.from(f).toString("utf8"));
      case "blob":
        return JSON.parse(f.text());
      default:
        return f;
    }
  }
  function l(u) {
    const f = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
    function y(S) {
      if (S)
        for (const A of Object.keys(S))
          /^authentication$/i.test(A) && (S[A] = f), /^authorization$/i.test(A) && (S[A] = f), /secret/i.test(A) && (S[A] = f);
    }
    function m(S, A) {
      if (typeof S == "object" && S !== null && typeof S[A] == "string") {
        const I = S[A];
        (/grant_type=/i.test(I) || /assertion=/i.test(I) || /secret/i.test(I)) && (S[A] = f);
      }
    }
    function p(S) {
      typeof S == "object" && S !== null && ("grant_type" in S && (S.grant_type = f), "assertion" in S && (S.assertion = f), "client_secret" in S && (S.client_secret = f));
    }
    if (u.config) {
      y(u.config.headers), m(u.config, "data"), p(u.config.data), m(u.config, "body"), p(u.config.body);
      try {
        const S = new n.URL("", u.config.url);
        S.searchParams.has("token") && S.searchParams.set("token", f), S.searchParams.has("client_secret") && S.searchParams.set("client_secret", f), u.config.url = S.toString();
      } catch {
      }
    }
    return u.response && (l({ config: u.response.config }), y(u.response.headers), m(u.response, "data"), p(u.response.data)), u;
  }
})(ef);
var tf = {};
Object.defineProperty(tf, "__esModule", { value: !0 });
tf.getRetryConfig = SA;
async function SA(t) {
  let e = sg(t);
  if (!t || !t.config || !e && !t.config.retry)
    return { shouldRetry: !1 };
  e = e || {}, e.currentRetryAttempt = e.currentRetryAttempt || 0, e.retry = e.retry === void 0 || e.retry === null ? 3 : e.retry, e.httpMethodsToRetry = e.httpMethodsToRetry || [
    "GET",
    "HEAD",
    "PUT",
    "OPTIONS",
    "DELETE"
  ], e.noResponseRetries = e.noResponseRetries === void 0 || e.noResponseRetries === null ? 2 : e.noResponseRetries, e.retryDelayMultiplier = e.retryDelayMultiplier ? e.retryDelayMultiplier : 2, e.timeOfFirstRequest = e.timeOfFirstRequest ? e.timeOfFirstRequest : Date.now(), e.totalTimeout = e.totalTimeout ? e.totalTimeout : Number.MAX_SAFE_INTEGER, e.maxRetryDelay = e.maxRetryDelay ? e.maxRetryDelay : Number.MAX_SAFE_INTEGER;
  const r = [
    // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
    // 1xx - Retry (Informational, request still processing)
    // 2xx - Do not retry (Success)
    // 3xx - Do not retry (Redirect)
    // 4xx - Do not retry (Client errors)
    // 408 - Retry ("Request Timeout")
    // 429 - Retry ("Too Many Requests")
    // 5xx - Retry (Server errors)
    [100, 199],
    [408, 408],
    [429, 429],
    [500, 599]
  ];
  if (e.statusCodesToRetry = e.statusCodesToRetry || r, t.config.retryConfig = e, !await (e.shouldRetry || IA)(t))
    return { shouldRetry: !1, config: t.config };
  const i = bA(e);
  t.config.retryConfig.currentRetryAttempt += 1;
  const a = e.retryBackoff ? e.retryBackoff(t, i) : new Promise((s) => {
    setTimeout(s, i);
  });
  return e.onRetryAttempt && e.onRetryAttempt(t), await a, { shouldRetry: !0, config: t.config };
}
function IA(t) {
  var e;
  const r = sg(t);
  if (t.name === "AbortError" || ((e = t.error) === null || e === void 0 ? void 0 : e.name) === "AbortError" || !r || r.retry === 0 || !t.response && (r.currentRetryAttempt || 0) >= r.noResponseRetries || !t.config.method || r.httpMethodsToRetry.indexOf(t.config.method.toUpperCase()) < 0)
    return !1;
  if (t.response && t.response.status) {
    let n = !1;
    for (const [i, a] of r.statusCodesToRetry) {
      const s = t.response.status;
      if (s >= i && s <= a) {
        n = !0;
        break;
      }
    }
    if (!n)
      return !1;
  }
  return r.currentRetryAttempt = r.currentRetryAttempt || 0, !(r.currentRetryAttempt >= r.retry);
}
function sg(t) {
  if (t && t.config && t.config.retryConfig)
    return t.config.retryConfig;
}
function bA(t) {
  var e;
  const n = (t.currentRetryAttempt ? 0 : (e = t.retryDelay) !== null && e !== void 0 ? e : 100) + (Math.pow(t.retryDelayMultiplier, t.currentRetryAttempt) - 1) / 2 * 1e3, i = t.totalTimeout - (Date.now() - t.timeOfFirstRequest);
  return Math.min(n, i, t.maxRetryDelay);
}
var og = {}, so = {}, oo = {};
Object.defineProperty(oo, "__esModule", {
  value: !0
});
oo.default = TA;
let Ja;
const wA = new Uint8Array(16);
function TA() {
  if (!Ja && (Ja = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ja))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ja(wA);
}
var Tn = {}, Zn = {}, co = {};
Object.defineProperty(co, "__esModule", {
  value: !0
});
co.default = void 0;
var RA = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
co.default = RA;
Object.defineProperty(Zn, "__esModule", {
  value: !0
});
Zn.default = void 0;
var NA = xA(co);
function xA(t) {
  return t && t.__esModule ? t : { default: t };
}
function OA(t) {
  return typeof t == "string" && NA.default.test(t);
}
var DA = OA;
Zn.default = DA;
Object.defineProperty(Tn, "__esModule", {
  value: !0
});
Tn.default = void 0;
Tn.unsafeStringify = cg;
var LA = PA(Zn);
function PA(t) {
  return t && t.__esModule ? t : { default: t };
}
const Ot = [];
for (let t = 0; t < 256; ++t)
  Ot.push((t + 256).toString(16).slice(1));
function cg(t, e = 0) {
  return Ot[t[e + 0]] + Ot[t[e + 1]] + Ot[t[e + 2]] + Ot[t[e + 3]] + "-" + Ot[t[e + 4]] + Ot[t[e + 5]] + "-" + Ot[t[e + 6]] + Ot[t[e + 7]] + "-" + Ot[t[e + 8]] + Ot[t[e + 9]] + "-" + Ot[t[e + 10]] + Ot[t[e + 11]] + Ot[t[e + 12]] + Ot[t[e + 13]] + Ot[t[e + 14]] + Ot[t[e + 15]];
}
function kA(t, e = 0) {
  const r = cg(t, e);
  if (!(0, LA.default)(r))
    throw TypeError("Stringified UUID is invalid");
  return r;
}
var BA = kA;
Tn.default = BA;
Object.defineProperty(so, "__esModule", {
  value: !0
});
so.default = void 0;
var UA = MA(oo), FA = Tn;
function MA(t) {
  return t && t.__esModule ? t : { default: t };
}
let jd, wc, Tc = 0, Rc = 0;
function VA(t, e, r) {
  let n = e && r || 0;
  const i = e || new Array(16);
  t = t || {};
  let a = t.node || jd, s = t.clockseq !== void 0 ? t.clockseq : wc;
  if (a == null || s == null) {
    const m = t.random || (t.rng || UA.default)();
    a == null && (a = jd = [m[0] | 1, m[1], m[2], m[3], m[4], m[5]]), s == null && (s = wc = (m[6] << 8 | m[7]) & 16383);
  }
  let o = t.msecs !== void 0 ? t.msecs : Date.now(), l = t.nsecs !== void 0 ? t.nsecs : Rc + 1;
  const u = o - Tc + (l - Rc) / 1e4;
  if (u < 0 && t.clockseq === void 0 && (s = s + 1 & 16383), (u < 0 || o > Tc) && t.nsecs === void 0 && (l = 0), l >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  Tc = o, Rc = l, wc = s, o += 122192928e5;
  const f = ((o & 268435455) * 1e4 + l) % 4294967296;
  i[n++] = f >>> 24 & 255, i[n++] = f >>> 16 & 255, i[n++] = f >>> 8 & 255, i[n++] = f & 255;
  const y = o / 4294967296 * 1e4 & 268435455;
  i[n++] = y >>> 8 & 255, i[n++] = y & 255, i[n++] = y >>> 24 & 15 | 16, i[n++] = y >>> 16 & 255, i[n++] = s >>> 8 | 128, i[n++] = s & 255;
  for (let m = 0; m < 6; ++m)
    i[n + m] = a[m];
  return e || (0, FA.unsafeStringify)(i);
}
var $A = VA;
so.default = $A;
var uo = {}, In = {}, ma = {};
Object.defineProperty(ma, "__esModule", {
  value: !0
});
ma.default = void 0;
var HA = KA(Zn);
function KA(t) {
  return t && t.__esModule ? t : { default: t };
}
function GA(t) {
  if (!(0, HA.default)(t))
    throw TypeError("Invalid UUID");
  let e;
  const r = new Uint8Array(16);
  return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = e & 255, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = e & 255, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = e & 255, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = e & 255, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = e & 255, r;
}
var jA = GA;
ma.default = jA;
Object.defineProperty(In, "__esModule", {
  value: !0
});
In.URL = In.DNS = void 0;
In.default = XA;
var qA = Tn, WA = JA(ma);
function JA(t) {
  return t && t.__esModule ? t : { default: t };
}
function zA(t) {
  t = unescape(encodeURIComponent(t));
  const e = [];
  for (let r = 0; r < t.length; ++r)
    e.push(t.charCodeAt(r));
  return e;
}
const ug = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
In.DNS = ug;
const lg = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
In.URL = lg;
function XA(t, e, r) {
  function n(i, a, s, o) {
    var l;
    if (typeof i == "string" && (i = zA(i)), typeof a == "string" && (a = (0, WA.default)(a)), ((l = a) === null || l === void 0 ? void 0 : l.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + i.length);
    if (u.set(a), u.set(i, a.length), u = r(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, s) {
      o = o || 0;
      for (let f = 0; f < 16; ++f)
        s[o + f] = u[f];
      return s;
    }
    return (0, qA.unsafeStringify)(u);
  }
  try {
    n.name = t;
  } catch {
  }
  return n.DNS = ug, n.URL = lg, n;
}
var lo = {};
Object.defineProperty(lo, "__esModule", {
  value: !0
});
lo.default = void 0;
function YA(t) {
  if (typeof t == "string") {
    const e = unescape(encodeURIComponent(t));
    t = new Uint8Array(e.length);
    for (let r = 0; r < e.length; ++r)
      t[r] = e.charCodeAt(r);
  }
  return QA(ZA(eC(t), t.length * 8));
}
function QA(t) {
  const e = [], r = t.length * 32, n = "0123456789abcdef";
  for (let i = 0; i < r; i += 8) {
    const a = t[i >> 5] >>> i % 32 & 255, s = parseInt(n.charAt(a >>> 4 & 15) + n.charAt(a & 15), 16);
    e.push(s);
  }
  return e;
}
function fg(t) {
  return (t + 64 >>> 9 << 4) + 14 + 1;
}
function ZA(t, e) {
  t[e >> 5] |= 128 << e % 32, t[fg(e) - 1] = e;
  let r = 1732584193, n = -271733879, i = -1732584194, a = 271733878;
  for (let s = 0; s < t.length; s += 16) {
    const o = r, l = n, u = i, f = a;
    r = kt(r, n, i, a, t[s], 7, -680876936), a = kt(a, r, n, i, t[s + 1], 12, -389564586), i = kt(i, a, r, n, t[s + 2], 17, 606105819), n = kt(n, i, a, r, t[s + 3], 22, -1044525330), r = kt(r, n, i, a, t[s + 4], 7, -176418897), a = kt(a, r, n, i, t[s + 5], 12, 1200080426), i = kt(i, a, r, n, t[s + 6], 17, -1473231341), n = kt(n, i, a, r, t[s + 7], 22, -45705983), r = kt(r, n, i, a, t[s + 8], 7, 1770035416), a = kt(a, r, n, i, t[s + 9], 12, -1958414417), i = kt(i, a, r, n, t[s + 10], 17, -42063), n = kt(n, i, a, r, t[s + 11], 22, -1990404162), r = kt(r, n, i, a, t[s + 12], 7, 1804603682), a = kt(a, r, n, i, t[s + 13], 12, -40341101), i = kt(i, a, r, n, t[s + 14], 17, -1502002290), n = kt(n, i, a, r, t[s + 15], 22, 1236535329), r = Bt(r, n, i, a, t[s + 1], 5, -165796510), a = Bt(a, r, n, i, t[s + 6], 9, -1069501632), i = Bt(i, a, r, n, t[s + 11], 14, 643717713), n = Bt(n, i, a, r, t[s], 20, -373897302), r = Bt(r, n, i, a, t[s + 5], 5, -701558691), a = Bt(a, r, n, i, t[s + 10], 9, 38016083), i = Bt(i, a, r, n, t[s + 15], 14, -660478335), n = Bt(n, i, a, r, t[s + 4], 20, -405537848), r = Bt(r, n, i, a, t[s + 9], 5, 568446438), a = Bt(a, r, n, i, t[s + 14], 9, -1019803690), i = Bt(i, a, r, n, t[s + 3], 14, -187363961), n = Bt(n, i, a, r, t[s + 8], 20, 1163531501), r = Bt(r, n, i, a, t[s + 13], 5, -1444681467), a = Bt(a, r, n, i, t[s + 2], 9, -51403784), i = Bt(i, a, r, n, t[s + 7], 14, 1735328473), n = Bt(n, i, a, r, t[s + 12], 20, -1926607734), r = Ut(r, n, i, a, t[s + 5], 4, -378558), a = Ut(a, r, n, i, t[s + 8], 11, -2022574463), i = Ut(i, a, r, n, t[s + 11], 16, 1839030562), n = Ut(n, i, a, r, t[s + 14], 23, -35309556), r = Ut(r, n, i, a, t[s + 1], 4, -1530992060), a = Ut(a, r, n, i, t[s + 4], 11, 1272893353), i = Ut(i, a, r, n, t[s + 7], 16, -155497632), n = Ut(n, i, a, r, t[s + 10], 23, -1094730640), r = Ut(r, n, i, a, t[s + 13], 4, 681279174), a = Ut(a, r, n, i, t[s], 11, -358537222), i = Ut(i, a, r, n, t[s + 3], 16, -722521979), n = Ut(n, i, a, r, t[s + 6], 23, 76029189), r = Ut(r, n, i, a, t[s + 9], 4, -640364487), a = Ut(a, r, n, i, t[s + 12], 11, -421815835), i = Ut(i, a, r, n, t[s + 15], 16, 530742520), n = Ut(n, i, a, r, t[s + 2], 23, -995338651), r = Ft(r, n, i, a, t[s], 6, -198630844), a = Ft(a, r, n, i, t[s + 7], 10, 1126891415), i = Ft(i, a, r, n, t[s + 14], 15, -1416354905), n = Ft(n, i, a, r, t[s + 5], 21, -57434055), r = Ft(r, n, i, a, t[s + 12], 6, 1700485571), a = Ft(a, r, n, i, t[s + 3], 10, -1894986606), i = Ft(i, a, r, n, t[s + 10], 15, -1051523), n = Ft(n, i, a, r, t[s + 1], 21, -2054922799), r = Ft(r, n, i, a, t[s + 8], 6, 1873313359), a = Ft(a, r, n, i, t[s + 15], 10, -30611744), i = Ft(i, a, r, n, t[s + 6], 15, -1560198380), n = Ft(n, i, a, r, t[s + 13], 21, 1309151649), r = Ft(r, n, i, a, t[s + 4], 6, -145523070), a = Ft(a, r, n, i, t[s + 11], 10, -1120210379), i = Ft(i, a, r, n, t[s + 2], 15, 718787259), n = Ft(n, i, a, r, t[s + 9], 21, -343485551), r = An(r, o), n = An(n, l), i = An(i, u), a = An(a, f);
  }
  return [r, n, i, a];
}
function eC(t) {
  if (t.length === 0)
    return [];
  const e = t.length * 8, r = new Uint32Array(fg(e));
  for (let n = 0; n < e; n += 8)
    r[n >> 5] |= (t[n / 8] & 255) << n % 32;
  return r;
}
function An(t, e) {
  const r = (t & 65535) + (e & 65535);
  return (t >> 16) + (e >> 16) + (r >> 16) << 16 | r & 65535;
}
function tC(t, e) {
  return t << e | t >>> 32 - e;
}
function fo(t, e, r, n, i, a) {
  return An(tC(An(An(e, t), An(n, a)), i), r);
}
function kt(t, e, r, n, i, a, s) {
  return fo(e & r | ~e & n, t, e, i, a, s);
}
function Bt(t, e, r, n, i, a, s) {
  return fo(e & n | r & ~n, t, e, i, a, s);
}
function Ut(t, e, r, n, i, a, s) {
  return fo(e ^ r ^ n, t, e, i, a, s);
}
function Ft(t, e, r, n, i, a, s) {
  return fo(r ^ (e | ~n), t, e, i, a, s);
}
var rC = YA;
lo.default = rC;
Object.defineProperty(uo, "__esModule", {
  value: !0
});
uo.default = void 0;
var nC = dg(In), iC = dg(lo);
function dg(t) {
  return t && t.__esModule ? t : { default: t };
}
const aC = (0, nC.default)("v3", 48, iC.default);
var sC = aC;
uo.default = sC;
var ho = {}, po = {};
Object.defineProperty(po, "__esModule", {
  value: !0
});
po.default = void 0;
const oC = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var cC = {
  randomUUID: oC
};
po.default = cC;
Object.defineProperty(ho, "__esModule", {
  value: !0
});
ho.default = void 0;
var qd = hg(po), uC = hg(oo), lC = Tn;
function hg(t) {
  return t && t.__esModule ? t : { default: t };
}
function fC(t, e, r) {
  if (qd.default.randomUUID && !e && !t)
    return qd.default.randomUUID();
  t = t || {};
  const n = t.random || (t.rng || uC.default)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
    r = r || 0;
    for (let i = 0; i < 16; ++i)
      e[r + i] = n[i];
    return e;
  }
  return (0, lC.unsafeStringify)(n);
}
var dC = fC;
ho.default = dC;
var go = {}, yo = {};
Object.defineProperty(yo, "__esModule", {
  value: !0
});
yo.default = void 0;
function hC(t, e, r, n) {
  switch (t) {
    case 0:
      return e & r ^ ~e & n;
    case 1:
      return e ^ r ^ n;
    case 2:
      return e & r ^ e & n ^ r & n;
    case 3:
      return e ^ r ^ n;
  }
}
function Nc(t, e) {
  return t << e | t >>> 32 - e;
}
function pC(t) {
  const e = [1518500249, 1859775393, 2400959708, 3395469782], r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    const s = unescape(encodeURIComponent(t));
    t = [];
    for (let o = 0; o < s.length; ++o)
      t.push(s.charCodeAt(o));
  } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  const n = t.length / 4 + 2, i = Math.ceil(n / 16), a = new Array(i);
  for (let s = 0; s < i; ++s) {
    const o = new Uint32Array(16);
    for (let l = 0; l < 16; ++l)
      o[l] = t[s * 64 + l * 4] << 24 | t[s * 64 + l * 4 + 1] << 16 | t[s * 64 + l * 4 + 2] << 8 | t[s * 64 + l * 4 + 3];
    a[s] = o;
  }
  a[i - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), a[i - 1][14] = Math.floor(a[i - 1][14]), a[i - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (let s = 0; s < i; ++s) {
    const o = new Uint32Array(80);
    for (let p = 0; p < 16; ++p)
      o[p] = a[s][p];
    for (let p = 16; p < 80; ++p)
      o[p] = Nc(o[p - 3] ^ o[p - 8] ^ o[p - 14] ^ o[p - 16], 1);
    let l = r[0], u = r[1], f = r[2], y = r[3], m = r[4];
    for (let p = 0; p < 80; ++p) {
      const S = Math.floor(p / 20), A = Nc(l, 5) + hC(S, u, f, y) + m + e[S] + o[p] >>> 0;
      m = y, y = f, f = Nc(u, 30) >>> 0, u = l, l = A;
    }
    r[0] = r[0] + l >>> 0, r[1] = r[1] + u >>> 0, r[2] = r[2] + f >>> 0, r[3] = r[3] + y >>> 0, r[4] = r[4] + m >>> 0;
  }
  return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255];
}
var gC = pC;
yo.default = gC;
Object.defineProperty(go, "__esModule", {
  value: !0
});
go.default = void 0;
var yC = pg(In), mC = pg(yo);
function pg(t) {
  return t && t.__esModule ? t : { default: t };
}
const EC = (0, yC.default)("v5", 80, mC.default);
var vC = EC;
go.default = vC;
var mo = {};
Object.defineProperty(mo, "__esModule", {
  value: !0
});
mo.default = void 0;
var AC = "00000000-0000-0000-0000-000000000000";
mo.default = AC;
var Eo = {};
Object.defineProperty(Eo, "__esModule", {
  value: !0
});
Eo.default = void 0;
var CC = _C(Zn);
function _C(t) {
  return t && t.__esModule ? t : { default: t };
}
function SC(t) {
  if (!(0, CC.default)(t))
    throw TypeError("Invalid UUID");
  return parseInt(t.slice(14, 15), 16);
}
var IC = SC;
Eo.default = IC;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "NIL", {
    enumerable: !0,
    get: function() {
      return a.default;
    }
  }), Object.defineProperty(t, "parse", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), Object.defineProperty(t, "stringify", {
    enumerable: !0,
    get: function() {
      return l.default;
    }
  }), Object.defineProperty(t, "v1", {
    enumerable: !0,
    get: function() {
      return e.default;
    }
  }), Object.defineProperty(t, "v3", {
    enumerable: !0,
    get: function() {
      return r.default;
    }
  }), Object.defineProperty(t, "v4", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(t, "v5", {
    enumerable: !0,
    get: function() {
      return i.default;
    }
  }), Object.defineProperty(t, "validate", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  }), Object.defineProperty(t, "version", {
    enumerable: !0,
    get: function() {
      return s.default;
    }
  });
  var e = f(so), r = f(uo), n = f(ho), i = f(go), a = f(mo), s = f(Eo), o = f(Zn), l = f(Tn), u = f(ma);
  function f(y) {
    return y && y.__esModule ? y : { default: y };
  }
})(og);
var Ea = {};
Object.defineProperty(Ea, "__esModule", { value: !0 });
Ea.GaxiosInterceptorManager = void 0;
class bC extends Set {
}
Ea.GaxiosInterceptorManager = bC;
var Ji = {}, za = { exports: {} }, xc, Wd;
function wC() {
  if (Wd) return xc;
  Wd = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, a = n * 365.25;
  xc = function(f, y) {
    y = y || {};
    var m = typeof f;
    if (m === "string" && f.length > 0)
      return s(f);
    if (m === "number" && isFinite(f))
      return y.long ? l(f) : o(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function s(f) {
    if (f = String(f), !(f.length > 100)) {
      var y = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (y) {
        var m = parseFloat(y[1]), p = (y[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return m * a;
          case "weeks":
          case "week":
          case "w":
            return m * i;
          case "days":
          case "day":
          case "d":
            return m * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return m * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return m * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return m * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return m;
          default:
            return;
        }
      }
    }
  }
  function o(f) {
    var y = Math.abs(f);
    return y >= n ? Math.round(f / n) + "d" : y >= r ? Math.round(f / r) + "h" : y >= e ? Math.round(f / e) + "m" : y >= t ? Math.round(f / t) + "s" : f + "ms";
  }
  function l(f) {
    var y = Math.abs(f);
    return y >= n ? u(f, y, n, "day") : y >= r ? u(f, y, r, "hour") : y >= e ? u(f, y, e, "minute") : y >= t ? u(f, y, t, "second") : f + " ms";
  }
  function u(f, y, m, p) {
    var S = y >= m * 1.5;
    return Math.round(f / m) + " " + p + (S ? "s" : "");
  }
  return xc;
}
var Oc, Jd;
function TC() {
  if (Jd) return Oc;
  Jd = 1;
  function t(e) {
    n.debug = n, n.default = n, n.coerce = u, n.disable = o, n.enable = a, n.enabled = l, n.humanize = wC(), n.destroy = f, Object.keys(e).forEach((y) => {
      n[y] = e[y];
    }), n.names = [], n.skips = [], n.formatters = {};
    function r(y) {
      let m = 0;
      for (let p = 0; p < y.length; p++)
        m = (m << 5) - m + y.charCodeAt(p), m |= 0;
      return n.colors[Math.abs(m) % n.colors.length];
    }
    n.selectColor = r;
    function n(y) {
      let m, p = null, S, A;
      function I(...c) {
        if (!I.enabled)
          return;
        const E = I, v = Number(/* @__PURE__ */ new Date()), R = v - (m || v);
        E.diff = R, E.prev = m, E.curr = v, m = v, c[0] = n.coerce(c[0]), typeof c[0] != "string" && c.unshift("%O");
        let N = 0;
        c[0] = c[0].replace(/%([a-zA-Z%])/g, (h, d) => {
          if (h === "%%")
            return "%";
          N++;
          const O = n.formatters[d];
          if (typeof O == "function") {
            const P = c[N];
            h = O.call(E, P), c.splice(N, 1), N--;
          }
          return h;
        }), n.formatArgs.call(E, c), (E.log || n.log).apply(E, c);
      }
      return I.namespace = y, I.useColors = n.useColors(), I.color = n.selectColor(y), I.extend = i, I.destroy = n.destroy, Object.defineProperty(I, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (S !== n.namespaces && (S = n.namespaces, A = n.enabled(y)), A),
        set: (c) => {
          p = c;
        }
      }), typeof n.init == "function" && n.init(I), I;
    }
    function i(y, m) {
      const p = n(this.namespace + (typeof m > "u" ? ":" : m) + y);
      return p.log = this.log, p;
    }
    function a(y) {
      n.save(y), n.namespaces = y, n.names = [], n.skips = [];
      const m = (typeof y == "string" ? y : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const p of m)
        p[0] === "-" ? n.skips.push(p.slice(1)) : n.names.push(p);
    }
    function s(y, m) {
      let p = 0, S = 0, A = -1, I = 0;
      for (; p < y.length; )
        if (S < m.length && (m[S] === y[p] || m[S] === "*"))
          m[S] === "*" ? (A = S, I = p, S++) : (p++, S++);
        else if (A !== -1)
          S = A + 1, I++, p = I;
        else
          return !1;
      for (; S < m.length && m[S] === "*"; )
        S++;
      return S === m.length;
    }
    function o() {
      const y = [
        ...n.names,
        ...n.skips.map((m) => "-" + m)
      ].join(",");
      return n.enable(""), y;
    }
    function l(y) {
      for (const m of n.skips)
        if (s(y, m))
          return !1;
      for (const m of n.names)
        if (s(y, m))
          return !0;
      return !1;
    }
    function u(y) {
      return y instanceof Error ? y.stack || y.message : y;
    }
    function f() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n.enable(n.load()), n;
  }
  return Oc = t, Oc;
}
var zd;
function gg() {
  return zd || (zd = 1, function(t, e) {
    e.formatArgs = n, e.save = i, e.load = a, e.useColors = r, e.storage = s(), e.destroy = /* @__PURE__ */ (() => {
      let l = !1;
      return () => {
        l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let l;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(l) {
      if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      l.splice(1, 0, u, "color: inherit");
      let f = 0, y = 0;
      l[0].replace(/%[a-zA-Z%]/g, (m) => {
        m !== "%%" && (f++, m === "%c" && (y = f));
      }), l.splice(y, 0, u);
    }
    e.log = console.debug || console.log || (() => {
    });
    function i(l) {
      try {
        l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function a() {
      let l;
      try {
        l = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
      } catch {
      }
      return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    t.exports = TC()(e);
    const { formatters: o } = t.exports;
    o.j = function(l) {
      try {
        return JSON.stringify(l);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(za, za.exports)), za.exports;
}
var Dc = {}, Yr = {}, Xd;
function RC() {
  if (Xd) return Yr;
  Xd = 1;
  var t = pe && pe.__createBinding || (Object.create ? function(l, u, f, y) {
    y === void 0 && (y = f);
    var m = Object.getOwnPropertyDescriptor(u, f);
    (!m || ("get" in m ? !u.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return u[f];
    } }), Object.defineProperty(l, y, m);
  } : function(l, u, f, y) {
    y === void 0 && (y = f), l[y] = u[f];
  }), e = pe && pe.__setModuleDefault || (Object.create ? function(l, u) {
    Object.defineProperty(l, "default", { enumerable: !0, value: u });
  } : function(l, u) {
    l.default = u;
  }), r = pe && pe.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var u = {};
    if (l != null) for (var f in l) f !== "default" && Object.prototype.hasOwnProperty.call(l, f) && t(u, l, f);
    return e(u, l), u;
  };
  Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.req = Yr.json = Yr.toBuffer = void 0;
  const n = r(ge), i = r(ge);
  async function a(l) {
    let u = 0;
    const f = [];
    for await (const y of l)
      u += y.length, f.push(y);
    return Buffer.concat(f, u);
  }
  Yr.toBuffer = a;
  async function s(l) {
    const f = (await a(l)).toString("utf8");
    try {
      return JSON.parse(f);
    } catch (y) {
      const m = y;
      throw m.message += ` (input: ${f})`, m;
    }
  }
  Yr.json = s;
  function o(l, u = {}) {
    const y = ((typeof l == "string" ? l : l.href).startsWith("https:") ? i : n).request(l, u), m = new Promise((p, S) => {
      y.once("response", p).once("error", S).end();
    });
    return y.then = m.then.bind(m), y;
  }
  return Yr.req = o, Yr;
}
var Yd;
function NC() {
  return Yd || (Yd = 1, function(t) {
    var e = pe && pe.__createBinding || (Object.create ? function(f, y, m, p) {
      p === void 0 && (p = m);
      var S = Object.getOwnPropertyDescriptor(y, m);
      (!S || ("get" in S ? !y.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
        return y[m];
      } }), Object.defineProperty(f, p, S);
    } : function(f, y, m, p) {
      p === void 0 && (p = m), f[p] = y[m];
    }), r = pe && pe.__setModuleDefault || (Object.create ? function(f, y) {
      Object.defineProperty(f, "default", { enumerable: !0, value: y });
    } : function(f, y) {
      f.default = y;
    }), n = pe && pe.__importStar || function(f) {
      if (f && f.__esModule) return f;
      var y = {};
      if (f != null) for (var m in f) m !== "default" && Object.prototype.hasOwnProperty.call(f, m) && e(y, f, m);
      return r(y, f), y;
    }, i = pe && pe.__exportStar || function(f, y) {
      for (var m in f) m !== "default" && !Object.prototype.hasOwnProperty.call(y, m) && e(y, f, m);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Agent = void 0;
    const a = n(ge), s = n(ge), o = ge;
    i(RC(), t);
    const l = Symbol("AgentBaseInternalState");
    class u extends s.Agent {
      constructor(y) {
        super(y), this[l] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(y) {
        if (y) {
          if (typeof y.secureEndpoint == "boolean")
            return y.secureEndpoint;
          if (typeof y.protocol == "string")
            return y.protocol === "https:";
        }
        const { stack: m } = new Error();
        return typeof m != "string" ? !1 : m.split(`
`).some((p) => p.indexOf("(https.js:") !== -1 || p.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(y) {
        if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
          return null;
        this.sockets[y] || (this.sockets[y] = []);
        const m = new a.Socket({ writable: !1 });
        return this.sockets[y].push(m), this.totalSocketCount++, m;
      }
      decrementSockets(y, m) {
        if (!this.sockets[y] || m === null)
          return;
        const p = this.sockets[y], S = p.indexOf(m);
        S !== -1 && (p.splice(S, 1), this.totalSocketCount--, p.length === 0 && delete this.sockets[y]);
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(y) {
        return this.isSecureEndpoint(y) ? o.Agent.prototype.getName.call(this, y) : super.getName(y);
      }
      createSocket(y, m, p) {
        const S = {
          ...m,
          secureEndpoint: this.isSecureEndpoint(m)
        }, A = this.getName(S), I = this.incrementSockets(A);
        Promise.resolve().then(() => this.connect(y, S)).then((c) => {
          if (this.decrementSockets(A, I), c instanceof s.Agent)
            try {
              return c.addRequest(y, S);
            } catch (E) {
              return p(E);
            }
          this[l].currentSocket = c, super.createSocket(y, m, p);
        }, (c) => {
          this.decrementSockets(A, I), p(c);
        });
      }
      createConnection() {
        const y = this[l].currentSocket;
        if (this[l].currentSocket = void 0, !y)
          throw new Error("No socket was returned in the `connect()` function");
        return y;
      }
      get defaultPort() {
        return this[l].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(y) {
        this[l] && (this[l].defaultPort = y);
      }
      get protocol() {
        return this[l].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(y) {
        this[l] && (this[l].protocol = y);
      }
    }
    t.Agent = u;
  }(Dc)), Dc;
}
var zi = {}, Qd;
function xC() {
  if (Qd) return zi;
  Qd = 1;
  var t = pe && pe.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(zi, "__esModule", { value: !0 }), zi.parseProxyResponse = void 0;
  const r = (0, t(gg()).default)("https-proxy-agent:parse-proxy-response");
  function n(i) {
    return new Promise((a, s) => {
      let o = 0;
      const l = [];
      function u() {
        const S = i.read();
        S ? p(S) : i.once("readable", u);
      }
      function f() {
        i.removeListener("end", y), i.removeListener("error", m), i.removeListener("readable", u);
      }
      function y() {
        f(), r("onend"), s(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function m(S) {
        f(), r("onerror %o", S), s(S);
      }
      function p(S) {
        l.push(S), o += S.length;
        const A = Buffer.concat(l, o), I = A.indexOf(`\r
\r
`);
        if (I === -1) {
          r("have not received end of HTTP headers yet..."), u();
          return;
        }
        const c = A.slice(0, I).toString("ascii").split(`\r
`), E = c.shift();
        if (!E)
          return i.destroy(), s(new Error("No header received from proxy CONNECT response"));
        const v = E.split(" "), R = +v[1], N = v.slice(2).join(" "), C = {};
        for (const h of c) {
          if (!h)
            continue;
          const d = h.indexOf(":");
          if (d === -1)
            return i.destroy(), s(new Error(`Invalid header from proxy CONNECT response: "${h}"`));
          const O = h.slice(0, d).toLowerCase(), P = h.slice(d + 1).trimStart(), L = C[O];
          typeof L == "string" ? C[O] = [L, P] : Array.isArray(L) ? L.push(P) : C[O] = P;
        }
        r("got proxy server response: %o %o", E, C), f(), a({
          connect: {
            statusCode: R,
            statusText: N,
            headers: C
          },
          buffered: A
        });
      }
      i.on("error", m), i.on("end", y), u();
    });
  }
  return zi.parseProxyResponse = n, zi;
}
var Zd;
function OC() {
  if (Zd) return Ji;
  Zd = 1;
  var t = pe && pe.__createBinding || (Object.create ? function(I, c, E, v) {
    v === void 0 && (v = E);
    var R = Object.getOwnPropertyDescriptor(c, E);
    (!R || ("get" in R ? !c.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return c[E];
    } }), Object.defineProperty(I, v, R);
  } : function(I, c, E, v) {
    v === void 0 && (v = E), I[v] = c[E];
  }), e = pe && pe.__setModuleDefault || (Object.create ? function(I, c) {
    Object.defineProperty(I, "default", { enumerable: !0, value: c });
  } : function(I, c) {
    I.default = c;
  }), r = pe && pe.__importStar || function(I) {
    if (I && I.__esModule) return I;
    var c = {};
    if (I != null) for (var E in I) E !== "default" && Object.prototype.hasOwnProperty.call(I, E) && t(c, I, E);
    return e(c, I), c;
  }, n = pe && pe.__importDefault || function(I) {
    return I && I.__esModule ? I : { default: I };
  };
  Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.HttpsProxyAgent = void 0;
  const i = r(ge), a = r(ge), s = n(ge), o = n(gg()), l = NC(), u = ge, f = xC(), y = (0, o.default)("https-proxy-agent"), m = (I) => I.servername === void 0 && I.host && !i.isIP(I.host) ? {
    ...I,
    servername: I.host
  } : I;
  class p extends l.Agent {
    constructor(c, E) {
      super(E), this.options = { path: void 0 }, this.proxy = typeof c == "string" ? new u.URL(c) : c, this.proxyHeaders = (E == null ? void 0 : E.headers) ?? {}, y("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const v = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), R = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        // Attempt to negotiate http/1.1 for proxy servers that support http/2
        ALPNProtocols: ["http/1.1"],
        ...E ? A(E, "headers") : null,
        host: v,
        port: R
      };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(c, E) {
      const { proxy: v } = this;
      if (!E.host)
        throw new TypeError('No "host" provided');
      let R;
      v.protocol === "https:" ? (y("Creating `tls.Socket`: %o", this.connectOpts), R = a.connect(m(this.connectOpts))) : (y("Creating `net.Socket`: %o", this.connectOpts), R = i.connect(this.connectOpts));
      const N = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, C = i.isIPv6(E.host) ? `[${E.host}]` : E.host;
      let h = `CONNECT ${C}:${E.port} HTTP/1.1\r
`;
      if (v.username || v.password) {
        const D = `${decodeURIComponent(v.username)}:${decodeURIComponent(v.password)}`;
        N["Proxy-Authorization"] = `Basic ${Buffer.from(D).toString("base64")}`;
      }
      N.Host = `${C}:${E.port}`, N["Proxy-Connection"] || (N["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (const D of Object.keys(N))
        h += `${D}: ${N[D]}\r
`;
      const d = (0, f.parseProxyResponse)(R);
      R.write(`${h}\r
`);
      const { connect: O, buffered: P } = await d;
      if (c.emit("proxyConnect", O), this.emit("proxyConnect", O, c), O.statusCode === 200)
        return c.once("socket", S), E.secureEndpoint ? (y("Upgrading socket connection to TLS"), a.connect({
          ...A(m(E), "host", "path", "port"),
          socket: R
        })) : R;
      R.destroy();
      const L = new i.Socket({ writable: !1 });
      return L.readable = !0, c.once("socket", (D) => {
        y("Replaying proxy buffer for failed request"), (0, s.default)(D.listenerCount("data") > 0), D.push(P), D.push(null);
      }), L;
    }
  }
  p.protocols = ["http", "https"], Ji.HttpsProxyAgent = p;
  function S(I) {
    I.resume();
  }
  function A(I, ...c) {
    const E = {};
    let v;
    for (v in I)
      c.includes(v) || (E[v] = I[v]);
    return E;
  }
  return Ji;
}
var DC = pe && pe.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), LC = pe && pe.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), PC = pe && pe.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && DC(e, t, r);
  return LC(e, t), e;
}, $n = pe && pe.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, kC = pe && pe.__classPrivateFieldSet || function(t, e, r, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r;
}, vo = pe && pe.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
}, Ii, Ln, eh, yg, mg, Eg, ys, th;
Object.defineProperty(io, "__esModule", { value: !0 });
io.Gaxios = void 0;
const BC = vo(ag), UC = ge, FC = vo(sA), MC = vo(ge), VC = vo(oA), rh = ge, ms = ef, $C = tf, nh = ge, HC = og, ih = Ea, KC = jC() ? window.fetch : FC.default;
function GC() {
  return typeof window < "u" && !!window;
}
function jC() {
  return GC() && !!window.fetch;
}
function qC() {
  return typeof Buffer < "u";
}
function ah(t, e) {
  return !!vg(t, e);
}
function vg(t, e) {
  e = e.toLowerCase();
  for (const r of Object.keys((t == null ? void 0 : t.headers) || {}))
    if (e === r.toLowerCase())
      return t.headers[r];
}
class Ag {
  /**
   * The Gaxios class is responsible for making HTTP requests.
   * @param defaults The default set of options to be used for this instance.
   */
  constructor(e) {
    Ii.add(this), this.agentCache = /* @__PURE__ */ new Map(), this.defaults = e || {}, this.interceptors = {
      request: new ih.GaxiosInterceptorManager(),
      response: new ih.GaxiosInterceptorManager()
    };
  }
  /**
   * Perform an HTTP request with the given options.
   * @param opts Set of HTTP options that will be used for this HTTP request.
   */
  async request(e = {}) {
    return e = await $n(this, Ii, "m", Eg).call(this, e), e = await $n(this, Ii, "m", yg).call(this, e), $n(this, Ii, "m", mg).call(this, this._request(e));
  }
  async _defaultAdapter(e) {
    const n = await (e.fetchImplementation || KC)(e.url, e), i = await this.getResponseData(e, n);
    return this.translateResponse(e, n, i);
  }
  /**
   * Internal, retryable version of the `request` method.
   * @param opts Set of HTTP options that will be used for this HTTP request.
   */
  async _request(e = {}) {
    var r;
    try {
      let n;
      if (e.adapter ? n = await e.adapter(e, this._defaultAdapter.bind(this)) : n = await this._defaultAdapter(e), !e.validateStatus(n.status)) {
        if (e.responseType === "stream") {
          let i = "";
          await new Promise((a) => {
            (n == null ? void 0 : n.data).on("data", (s) => {
              i += s;
            }), (n == null ? void 0 : n.data).on("end", a);
          }), n.data = i;
        }
        throw new ms.GaxiosError(`Request failed with status code ${n.status}`, e, n);
      }
      return n;
    } catch (n) {
      const i = n instanceof ms.GaxiosError ? n : new ms.GaxiosError(n.message, e, void 0, n), { shouldRetry: a, config: s } = await (0, $C.getRetryConfig)(i);
      if (a && s)
        return i.config.retryConfig.currentRetryAttempt = s.retryConfig.currentRetryAttempt, e.retryConfig = (r = i.config) === null || r === void 0 ? void 0 : r.retryConfig, this._request(e);
      throw i;
    }
  }
  async getResponseData(e, r) {
    switch (e.responseType) {
      case "stream":
        return r.body;
      case "json": {
        let n = await r.text();
        try {
          n = JSON.parse(n);
        } catch {
        }
        return n;
      }
      case "arraybuffer":
        return r.arrayBuffer();
      case "blob":
        return r.blob();
      case "text":
        return r.text();
      default:
        return this.getResponseDataFromContentType(r);
    }
  }
  /**
   * By default, throw for any non-2xx status code
   * @param status status code from the HTTP response
   */
  validateStatus(e) {
    return e >= 200 && e < 300;
  }
  /**
   * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
   * @param params key value pars to encode
   */
  paramsSerializer(e) {
    return MC.default.stringify(e);
  }
  translateResponse(e, r, n) {
    const i = {};
    return r.headers.forEach((a, s) => {
      i[s] = a;
    }), {
      config: e,
      data: n,
      headers: i,
      status: r.status,
      statusText: r.statusText,
      // XMLHttpRequestLike
      request: {
        responseURL: r.url
      }
    };
  }
  /**
   * Attempts to parse a response by looking at the Content-Type header.
   * @param {FetchResponse} response the HTTP response.
   * @returns {Promise<any>} a promise that resolves to the response data.
   */
  async getResponseDataFromContentType(e) {
    let r = e.headers.get("Content-Type");
    if (r === null)
      return e.text();
    if (r = r.toLowerCase(), r.includes("application/json")) {
      let n = await e.text();
      try {
        n = JSON.parse(n);
      } catch {
      }
      return n;
    } else return r.match(/^text\//) ? e.text() : e.blob();
  }
  /**
   * Creates an async generator that yields the pieces of a multipart/related request body.
   * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
   * multipart/related requests are not currently supported.
   *
   * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
   * @param {string} boundary the boundary string to be placed between each part.
   */
  async *getMultipartRequest(e, r) {
    const n = `--${r}--`;
    for (const i of e) {
      const a = i.headers["Content-Type"] || "application/octet-stream";
      yield `--${r}\r
Content-Type: ${a}\r
\r
`, typeof i.content == "string" ? yield i.content : yield* i.content, yield `\r
`;
    }
    yield n;
  }
}
io.Gaxios = Ag;
Ln = Ag, Ii = /* @__PURE__ */ new WeakSet(), eh = function(e, r = []) {
  var n, i;
  const a = new rh.URL(e), s = [...r], o = ((i = (n = process.env.NO_PROXY) !== null && n !== void 0 ? n : process.env.no_proxy) === null || i === void 0 ? void 0 : i.split(",")) || [];
  for (const l of o)
    s.push(l.trim());
  for (const l of s)
    if (l instanceof RegExp) {
      if (l.test(a.toString()))
        return !1;
    } else if (l instanceof rh.URL) {
      if (l.origin === a.origin)
        return !1;
    } else if (l.startsWith("*.") || l.startsWith(".")) {
      const u = l.replace(/^\*\./, ".");
      if (a.hostname.endsWith(u))
        return !1;
    } else if (l === a.origin || l === a.hostname || l === a.href)
      return !1;
  return !0;
}, yg = /**
 * Applies the request interceptors. The request interceptors are applied after the
 * call to prepareRequest is completed.
 *
 * @param {GaxiosOptions} options The current set of options.
 *
 * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
 */
async function(e) {
  let r = Promise.resolve(e);
  for (const n of this.interceptors.request.values())
    n && (r = r.then(n.resolved, n.rejected));
  return r;
}, mg = /**
 * Applies the response interceptors. The response interceptors are applied after the
 * call to request is made.
 *
 * @param {GaxiosOptions} options The current set of options.
 *
 * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
 */
async function(e) {
  let r = Promise.resolve(e);
  for (const n of this.interceptors.response.values())
    n && (r = r.then(n.resolved, n.rejected));
  return r;
}, Eg = /**
 * Validates the options, merges them with defaults, and prepare request.
 *
 * @param options The original options passed from the client.
 * @returns Prepared options, ready to make a request
 */
async function(e) {
  var r, n, i, a;
  const s = (0, BC.default)(!0, {}, this.defaults, e);
  if (!s.url)
    throw new Error("URL is required.");
  const o = s.baseUrl || s.baseURL;
  if (o && (s.url = o.toString() + s.url), s.paramsSerializer = s.paramsSerializer || this.paramsSerializer, s.params && Object.keys(s.params).length > 0) {
    let f = s.paramsSerializer(s.params);
    f.startsWith("?") && (f = f.slice(1));
    const y = s.url.toString().includes("?") ? "&" : "?";
    s.url = s.url + y + f;
  }
  if (typeof e.maxContentLength == "number" && (s.size = e.maxContentLength), typeof e.maxRedirects == "number" && (s.follow = e.maxRedirects), s.headers = s.headers || {}, s.multipart === void 0 && s.data) {
    const f = typeof FormData > "u" ? !1 : (s == null ? void 0 : s.data) instanceof FormData;
    VC.default.readable(s.data) ? s.body = s.data : qC() && Buffer.isBuffer(s.data) ? (s.body = s.data, ah(s, "Content-Type") || (s.headers["Content-Type"] = "application/json")) : typeof s.data == "object" ? f || (vg(s, "content-type") === "application/x-www-form-urlencoded" ? s.body = s.paramsSerializer(s.data) : (ah(s, "Content-Type") || (s.headers["Content-Type"] = "application/json"), s.body = JSON.stringify(s.data))) : s.body = s.data;
  } else if (s.multipart && s.multipart.length > 0) {
    const f = (0, HC.v4)();
    s.headers["Content-Type"] = `multipart/related; boundary=${f}`;
    const y = new nh.PassThrough();
    s.body = y, (0, nh.pipeline)(this.getMultipartRequest(s.multipart, f), y, () => {
    });
  }
  s.validateStatus = s.validateStatus || this.validateStatus, s.responseType = s.responseType || "unknown", !s.headers.Accept && s.responseType === "json" && (s.headers.Accept = "application/json"), s.method = s.method || "GET";
  const l = s.proxy || ((r = process == null ? void 0 : process.env) === null || r === void 0 ? void 0 : r.HTTPS_PROXY) || ((n = process == null ? void 0 : process.env) === null || n === void 0 ? void 0 : n.https_proxy) || ((i = process == null ? void 0 : process.env) === null || i === void 0 ? void 0 : i.HTTP_PROXY) || ((a = process == null ? void 0 : process.env) === null || a === void 0 ? void 0 : a.http_proxy), u = $n(this, Ii, "m", eh).call(this, s.url, s.noProxy);
  if (!s.agent) if (l && u) {
    const f = await $n(Ln, Ln, "m", th).call(Ln);
    this.agentCache.has(l) ? s.agent = this.agentCache.get(l) : (s.agent = new f(l, {
      cert: s.cert,
      key: s.key
    }), this.agentCache.set(l, s.agent));
  } else s.cert && s.key && (this.agentCache.has(s.key) ? s.agent = this.agentCache.get(s.key) : (s.agent = new UC.Agent({
    cert: s.cert,
    key: s.key
  }), this.agentCache.set(s.key, s.agent)));
  return typeof s.errorRedactor != "function" && s.errorRedactor !== !1 && (s.errorRedactor = ms.defaultErrorRedactor), s;
}, th = async function() {
  return kC(this, Ln, $n(this, Ln, "f", ys) || (await Promise.resolve().then(() => PC(OC()))).HttpsProxyAgent, "f", ys), $n(this, Ln, "f", ys);
};
ys = { value: void 0 };
(function(t) {
  var e = pe && pe.__createBinding || (Object.create ? function(s, o, l, u) {
    u === void 0 && (u = l);
    var f = Object.getOwnPropertyDescriptor(o, l);
    (!f || ("get" in f ? !o.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return o[l];
    } }), Object.defineProperty(s, u, f);
  } : function(s, o, l, u) {
    u === void 0 && (u = l), s[u] = o[l];
  }), r = pe && pe.__exportStar || function(s, o) {
    for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(o, l) && e(o, s, l);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.instance = t.Gaxios = t.GaxiosError = void 0, t.request = a;
  const n = io;
  Object.defineProperty(t, "Gaxios", { enumerable: !0, get: function() {
    return n.Gaxios;
  } });
  var i = ef;
  Object.defineProperty(t, "GaxiosError", { enumerable: !0, get: function() {
    return i.GaxiosError;
  } }), r(Ea, t), t.instance = new n.Gaxios();
  async function a(s) {
    return t.instance.request(s);
  }
})(Lr);
var Ao = { exports: {} }, Cg = { exports: {} }, _g = { exports: {} };
(function(t) {
  (function(e) {
    var r, n = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, a = Math.floor, s = "[BigNumber Error] ", o = s + "Number primitive has more than 15 significant digits: ", l = 1e14, u = 14, f = 9007199254740991, y = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], m = 1e7, p = 1e9;
    function S(C) {
      var h, d, O, P = te.prototype = { constructor: te, toString: null, valueOf: null }, L = new te(1), D = 20, V = 4, $ = -7, K = 21, Q = -1e7, ee = 1e7, ne = !1, ae = 1, se = 0, me = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ye = "0123456789abcdefghijklmnopqrstuvwxyz", Se = !0;
      function te(b, T) {
        var g, x, U, k, W, q, z, j, Y = this;
        if (!(Y instanceof te)) return new te(b, T);
        if (T == null) {
          if (b && b._isBigNumber === !0) {
            Y.s = b.s, !b.c || b.e > ee ? Y.c = Y.e = null : b.e < Q ? Y.c = [Y.e = 0] : (Y.e = b.e, Y.c = b.c.slice());
            return;
          }
          if ((q = typeof b == "number") && b * 0 == 0) {
            if (Y.s = 1 / b < 0 ? (b = -b, -1) : 1, b === ~~b) {
              for (k = 0, W = b; W >= 10; W /= 10, k++) ;
              k > ee ? Y.c = Y.e = null : (Y.e = k, Y.c = [b]);
              return;
            }
            j = String(b);
          } else {
            if (!n.test(j = String(b))) return O(Y, j, q);
            Y.s = j.charCodeAt(0) == 45 ? (j = j.slice(1), -1) : 1;
          }
          (k = j.indexOf(".")) > -1 && (j = j.replace(".", "")), (W = j.search(/e/i)) > 0 ? (k < 0 && (k = W), k += +j.slice(W + 1), j = j.substring(0, W)) : k < 0 && (k = j.length);
        } else {
          if (E(T, 2, ye.length, "Base"), T == 10 && Se)
            return Y = new te(b), _e(Y, D + Y.e + 1, V);
          if (j = String(b), q = typeof b == "number") {
            if (b * 0 != 0) return O(Y, j, q, T);
            if (Y.s = 1 / b < 0 ? (j = j.slice(1), -1) : 1, te.DEBUG && j.replace(/^0\.0*|\./, "").length > 15)
              throw Error(o + b);
          } else
            Y.s = j.charCodeAt(0) === 45 ? (j = j.slice(1), -1) : 1;
          for (g = ye.slice(0, T), k = W = 0, z = j.length; W < z; W++)
            if (g.indexOf(x = j.charAt(W)) < 0) {
              if (x == ".") {
                if (W > k) {
                  k = z;
                  continue;
                }
              } else if (!U && (j == j.toUpperCase() && (j = j.toLowerCase()) || j == j.toLowerCase() && (j = j.toUpperCase()))) {
                U = !0, W = -1, k = 0;
                continue;
              }
              return O(Y, String(b), q, T);
            }
          q = !1, j = d(j, T, 10, Y.s), (k = j.indexOf(".")) > -1 ? j = j.replace(".", "") : k = j.length;
        }
        for (W = 0; j.charCodeAt(W) === 48; W++) ;
        for (z = j.length; j.charCodeAt(--z) === 48; ) ;
        if (j = j.slice(W, ++z)) {
          if (z -= W, q && te.DEBUG && z > 15 && (b > f || b !== a(b)))
            throw Error(o + Y.s * b);
          if ((k = k - W - 1) > ee)
            Y.c = Y.e = null;
          else if (k < Q)
            Y.c = [Y.e = 0];
          else {
            if (Y.e = k, Y.c = [], W = (k + 1) % u, k < 0 && (W += u), W < z) {
              for (W && Y.c.push(+j.slice(0, W)), z -= u; W < z; )
                Y.c.push(+j.slice(W, W += u));
              W = u - (j = j.slice(W)).length;
            } else
              W -= z;
            for (; W--; j += "0") ;
            Y.c.push(+j);
          }
        } else
          Y.c = [Y.e = 0];
      }
      te.clone = S, te.ROUND_UP = 0, te.ROUND_DOWN = 1, te.ROUND_CEIL = 2, te.ROUND_FLOOR = 3, te.ROUND_HALF_UP = 4, te.ROUND_HALF_DOWN = 5, te.ROUND_HALF_EVEN = 6, te.ROUND_HALF_CEIL = 7, te.ROUND_HALF_FLOOR = 8, te.EUCLID = 9, te.config = te.set = function(b) {
        var T, g;
        if (b != null)
          if (typeof b == "object") {
            if (b.hasOwnProperty(T = "DECIMAL_PLACES") && (g = b[T], E(g, 0, p, T), D = g), b.hasOwnProperty(T = "ROUNDING_MODE") && (g = b[T], E(g, 0, 8, T), V = g), b.hasOwnProperty(T = "EXPONENTIAL_AT") && (g = b[T], g && g.pop ? (E(g[0], -p, 0, T), E(g[1], 0, p, T), $ = g[0], K = g[1]) : (E(g, -p, p, T), $ = -(K = g < 0 ? -g : g))), b.hasOwnProperty(T = "RANGE"))
              if (g = b[T], g && g.pop)
                E(g[0], -p, -1, T), E(g[1], 1, p, T), Q = g[0], ee = g[1];
              else if (E(g, -p, p, T), g)
                Q = -(ee = g < 0 ? -g : g);
              else
                throw Error(s + T + " cannot be zero: " + g);
            if (b.hasOwnProperty(T = "CRYPTO"))
              if (g = b[T], g === !!g)
                if (g)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    ne = g;
                  else
                    throw ne = !g, Error(s + "crypto unavailable");
                else
                  ne = g;
              else
                throw Error(s + T + " not true or false: " + g);
            if (b.hasOwnProperty(T = "MODULO_MODE") && (g = b[T], E(g, 0, 9, T), ae = g), b.hasOwnProperty(T = "POW_PRECISION") && (g = b[T], E(g, 0, p, T), se = g), b.hasOwnProperty(T = "FORMAT"))
              if (g = b[T], typeof g == "object") me = g;
              else throw Error(s + T + " not an object: " + g);
            if (b.hasOwnProperty(T = "ALPHABET"))
              if (g = b[T], typeof g == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(g))
                Se = g.slice(0, 10) == "0123456789", ye = g;
              else
                throw Error(s + T + " invalid: " + g);
          } else
            throw Error(s + "Object expected: " + b);
        return {
          DECIMAL_PLACES: D,
          ROUNDING_MODE: V,
          EXPONENTIAL_AT: [$, K],
          RANGE: [Q, ee],
          CRYPTO: ne,
          MODULO_MODE: ae,
          POW_PRECISION: se,
          FORMAT: me,
          ALPHABET: ye
        };
      }, te.isBigNumber = function(b) {
        if (!b || b._isBigNumber !== !0) return !1;
        if (!te.DEBUG) return !0;
        var T, g, x = b.c, U = b.e, k = b.s;
        e: if ({}.toString.call(x) == "[object Array]") {
          if ((k === 1 || k === -1) && U >= -p && U <= p && U === a(U)) {
            if (x[0] === 0) {
              if (U === 0 && x.length === 1) return !0;
              break e;
            }
            if (T = (U + 1) % u, T < 1 && (T += u), String(x[0]).length == T) {
              for (T = 0; T < x.length; T++)
                if (g = x[T], g < 0 || g >= l || g !== a(g)) break e;
              if (g !== 0) return !0;
            }
          }
        } else if (x === null && U === null && (k === null || k === 1 || k === -1))
          return !0;
        throw Error(s + "Invalid BigNumber: " + b);
      }, te.maximum = te.max = function() {
        return fe(arguments, -1);
      }, te.minimum = te.min = function() {
        return fe(arguments, 1);
      }, te.random = function() {
        var b = 9007199254740992, T = Math.random() * b & 2097151 ? function() {
          return a(Math.random() * b);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(g) {
          var x, U, k, W, q, z = 0, j = [], Y = new te(L);
          if (g == null ? g = D : E(g, 0, p), W = i(g / u), ne)
            if (crypto.getRandomValues) {
              for (x = crypto.getRandomValues(new Uint32Array(W *= 2)); z < W; )
                q = x[z] * 131072 + (x[z + 1] >>> 11), q >= 9e15 ? (U = crypto.getRandomValues(new Uint32Array(2)), x[z] = U[0], x[z + 1] = U[1]) : (j.push(q % 1e14), z += 2);
              z = W / 2;
            } else if (crypto.randomBytes) {
              for (x = crypto.randomBytes(W *= 7); z < W; )
                q = (x[z] & 31) * 281474976710656 + x[z + 1] * 1099511627776 + x[z + 2] * 4294967296 + x[z + 3] * 16777216 + (x[z + 4] << 16) + (x[z + 5] << 8) + x[z + 6], q >= 9e15 ? crypto.randomBytes(7).copy(x, z) : (j.push(q % 1e14), z += 7);
              z = W / 7;
            } else
              throw ne = !1, Error(s + "crypto unavailable");
          if (!ne)
            for (; z < W; )
              q = T(), q < 9e15 && (j[z++] = q % 1e14);
          for (W = j[--z], g %= u, W && g && (q = y[u - g], j[z] = a(W / q) * q); j[z] === 0; j.pop(), z--) ;
          if (z < 0)
            j = [k = 0];
          else {
            for (k = -1; j[0] === 0; j.splice(0, 1), k -= u) ;
            for (z = 1, q = j[0]; q >= 10; q /= 10, z++) ;
            z < u && (k -= u - z);
          }
          return Y.e = k, Y.c = j, Y;
        };
      }(), te.sum = function() {
        for (var b = 1, T = arguments, g = new te(T[0]); b < T.length; ) g = g.plus(T[b++]);
        return g;
      }, d = /* @__PURE__ */ function() {
        var b = "0123456789";
        function T(g, x, U, k) {
          for (var W, q = [0], z, j = 0, Y = g.length; j < Y; ) {
            for (z = q.length; z--; q[z] *= x) ;
            for (q[0] += k.indexOf(g.charAt(j++)), W = 0; W < q.length; W++)
              q[W] > U - 1 && (q[W + 1] == null && (q[W + 1] = 0), q[W + 1] += q[W] / U | 0, q[W] %= U);
          }
          return q.reverse();
        }
        return function(g, x, U, k, W) {
          var q, z, j, Y, M, X, J, Z, oe = g.indexOf("."), he = D, Ee = V;
          for (oe >= 0 && (Y = se, se = 0, g = g.replace(".", ""), Z = new te(x), X = Z.pow(g.length - oe), se = Y, Z.c = T(
            N(I(X.c), X.e, "0"),
            10,
            U,
            b
          ), Z.e = Z.c.length), J = T(g, x, U, W ? (q = ye, b) : (q = b, ye)), j = Y = J.length; J[--Y] == 0; J.pop()) ;
          if (!J[0]) return q.charAt(0);
          if (oe < 0 ? --j : (X.c = J, X.e = j, X.s = k, X = h(X, Z, he, Ee, U), J = X.c, M = X.r, j = X.e), z = j + he + 1, oe = J[z], Y = U / 2, M = M || z < 0 || J[z + 1] != null, M = Ee < 4 ? (oe != null || M) && (Ee == 0 || Ee == (X.s < 0 ? 3 : 2)) : oe > Y || oe == Y && (Ee == 4 || M || Ee == 6 && J[z - 1] & 1 || Ee == (X.s < 0 ? 8 : 7)), z < 1 || !J[0])
            g = M ? N(q.charAt(1), -he, q.charAt(0)) : q.charAt(0);
          else {
            if (J.length = z, M)
              for (--U; ++J[--z] > U; )
                J[z] = 0, z || (++j, J = [1].concat(J));
            for (Y = J.length; !J[--Y]; ) ;
            for (oe = 0, g = ""; oe <= Y; g += q.charAt(J[oe++])) ;
            g = N(g, j, q.charAt(0));
          }
          return g;
        };
      }(), h = /* @__PURE__ */ function() {
        function b(x, U, k) {
          var W, q, z, j, Y = 0, M = x.length, X = U % m, J = U / m | 0;
          for (x = x.slice(); M--; )
            z = x[M] % m, j = x[M] / m | 0, W = J * z + j * X, q = X * z + W % m * m + Y, Y = (q / k | 0) + (W / m | 0) + J * j, x[M] = q % k;
          return Y && (x = [Y].concat(x)), x;
        }
        function T(x, U, k, W) {
          var q, z;
          if (k != W)
            z = k > W ? 1 : -1;
          else
            for (q = z = 0; q < k; q++)
              if (x[q] != U[q]) {
                z = x[q] > U[q] ? 1 : -1;
                break;
              }
          return z;
        }
        function g(x, U, k, W) {
          for (var q = 0; k--; )
            x[k] -= q, q = x[k] < U[k] ? 1 : 0, x[k] = q * W + x[k] - U[k];
          for (; !x[0] && x.length > 1; x.splice(0, 1)) ;
        }
        return function(x, U, k, W, q) {
          var z, j, Y, M, X, J, Z, oe, he, Ee, be, Re, ze, nt, it, je, Ze, qe = x.s == U.s ? 1 : -1, He = x.c, ke = U.c;
          if (!He || !He[0] || !ke || !ke[0])
            return new te(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !U.s || (He ? ke && He[0] == ke[0] : !ke) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                He && He[0] == 0 || !ke ? qe * 0 : qe / 0
              )
            );
          for (oe = new te(qe), he = oe.c = [], j = x.e - U.e, qe = k + j + 1, q || (q = l, j = A(x.e / u) - A(U.e / u), qe = qe / u | 0), Y = 0; ke[Y] == (He[Y] || 0); Y++) ;
          if (ke[Y] > (He[Y] || 0) && j--, qe < 0)
            he.push(1), M = !0;
          else {
            for (nt = He.length, je = ke.length, Y = 0, qe += 2, X = a(q / (ke[0] + 1)), X > 1 && (ke = b(ke, X, q), He = b(He, X, q), je = ke.length, nt = He.length), ze = je, Ee = He.slice(0, je), be = Ee.length; be < je; Ee[be++] = 0) ;
            Ze = ke.slice(), Ze = [0].concat(Ze), it = ke[0], ke[1] >= q / 2 && it++;
            do {
              if (X = 0, z = T(ke, Ee, je, be), z < 0) {
                if (Re = Ee[0], je != be && (Re = Re * q + (Ee[1] || 0)), X = a(Re / it), X > 1)
                  for (X >= q && (X = q - 1), J = b(ke, X, q), Z = J.length, be = Ee.length; T(J, Ee, Z, be) == 1; )
                    X--, g(J, je < Z ? Ze : ke, Z, q), Z = J.length, z = 1;
                else
                  X == 0 && (z = X = 1), J = ke.slice(), Z = J.length;
                if (Z < be && (J = [0].concat(J)), g(Ee, J, be, q), be = Ee.length, z == -1)
                  for (; T(ke, Ee, je, be) < 1; )
                    X++, g(Ee, je < be ? Ze : ke, be, q), be = Ee.length;
              } else z === 0 && (X++, Ee = [0]);
              he[Y++] = X, Ee[0] ? Ee[be++] = He[ze] || 0 : (Ee = [He[ze]], be = 1);
            } while ((ze++ < nt || Ee[0] != null) && qe--);
            M = Ee[0] != null, he[0] || he.splice(0, 1);
          }
          if (q == l) {
            for (Y = 1, qe = he[0]; qe >= 10; qe /= 10, Y++) ;
            _e(oe, k + (oe.e = Y + j * u - 1) + 1, W, M);
          } else
            oe.e = j, oe.r = +M;
          return oe;
        };
      }();
      function Ce(b, T, g, x) {
        var U, k, W, q, z;
        if (g == null ? g = V : E(g, 0, 8), !b.c) return b.toString();
        if (U = b.c[0], W = b.e, T == null)
          z = I(b.c), z = x == 1 || x == 2 && (W <= $ || W >= K) ? R(z, W) : N(z, W, "0");
        else if (b = _e(new te(b), T, g), k = b.e, z = I(b.c), q = z.length, x == 1 || x == 2 && (T <= k || k <= $)) {
          for (; q < T; z += "0", q++) ;
          z = R(z, k);
        } else if (T -= W + (x === 2 && k > W), z = N(z, k, "0"), k + 1 > q) {
          if (--T > 0) for (z += "."; T--; z += "0") ;
        } else if (T += k - q, T > 0)
          for (k + 1 == q && (z += "."); T--; z += "0") ;
        return b.s < 0 && U ? "-" + z : z;
      }
      function fe(b, T) {
        for (var g, x, U = 1, k = new te(b[0]); U < b.length; U++)
          x = new te(b[U]), (!x.s || (g = c(k, x)) === T || g === 0 && k.s === T) && (k = x);
        return k;
      }
      function De(b, T, g) {
        for (var x = 1, U = T.length; !T[--U]; T.pop()) ;
        for (U = T[0]; U >= 10; U /= 10, x++) ;
        return (g = x + g * u - 1) > ee ? b.c = b.e = null : g < Q ? b.c = [b.e = 0] : (b.e = g, b.c = T), b;
      }
      O = /* @__PURE__ */ function() {
        var b = /^(-?)0([xbo])(?=\w[\w.]*$)/i, T = /^([^.]+)\.$/, g = /^\.([^.]+)$/, x = /^-?(Infinity|NaN)$/, U = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(k, W, q, z) {
          var j, Y = q ? W : W.replace(U, "");
          if (x.test(Y))
            k.s = isNaN(Y) ? null : Y < 0 ? -1 : 1;
          else {
            if (!q && (Y = Y.replace(b, function(M, X, J) {
              return j = (J = J.toLowerCase()) == "x" ? 16 : J == "b" ? 2 : 8, !z || z == j ? X : M;
            }), z && (j = z, Y = Y.replace(T, "$1").replace(g, "0.$1")), W != Y))
              return new te(Y, j);
            if (te.DEBUG)
              throw Error(s + "Not a" + (z ? " base " + z : "") + " number: " + W);
            k.s = null;
          }
          k.c = k.e = null;
        };
      }();
      function _e(b, T, g, x) {
        var U, k, W, q, z, j, Y, M = b.c, X = y;
        if (M) {
          e: {
            for (U = 1, q = M[0]; q >= 10; q /= 10, U++) ;
            if (k = T - U, k < 0)
              k += u, W = T, z = M[j = 0], Y = a(z / X[U - W - 1] % 10);
            else if (j = i((k + 1) / u), j >= M.length)
              if (x) {
                for (; M.length <= j; M.push(0)) ;
                z = Y = 0, U = 1, k %= u, W = k - u + 1;
              } else
                break e;
            else {
              for (z = q = M[j], U = 1; q >= 10; q /= 10, U++) ;
              k %= u, W = k - u + U, Y = W < 0 ? 0 : a(z / X[U - W - 1] % 10);
            }
            if (x = x || T < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            M[j + 1] != null || (W < 0 ? z : z % X[U - W - 1]), x = g < 4 ? (Y || x) && (g == 0 || g == (b.s < 0 ? 3 : 2)) : Y > 5 || Y == 5 && (g == 4 || x || g == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (k > 0 ? W > 0 ? z / X[U - W] : 0 : M[j - 1]) % 10 & 1 || g == (b.s < 0 ? 8 : 7)), T < 1 || !M[0])
              return M.length = 0, x ? (T -= b.e + 1, M[0] = X[(u - T % u) % u], b.e = -T || 0) : M[0] = b.e = 0, b;
            if (k == 0 ? (M.length = j, q = 1, j--) : (M.length = j + 1, q = X[u - k], M[j] = W > 0 ? a(z / X[U - W] % X[W]) * q : 0), x)
              for (; ; )
                if (j == 0) {
                  for (k = 1, W = M[0]; W >= 10; W /= 10, k++) ;
                  for (W = M[0] += q, q = 1; W >= 10; W /= 10, q++) ;
                  k != q && (b.e++, M[0] == l && (M[0] = 1));
                  break;
                } else {
                  if (M[j] += q, M[j] != l) break;
                  M[j--] = 0, q = 1;
                }
            for (k = M.length; M[--k] === 0; M.pop()) ;
          }
          b.e > ee ? b.c = b.e = null : b.e < Q && (b.c = [b.e = 0]);
        }
        return b;
      }
      function w(b) {
        var T, g = b.e;
        return g === null ? b.toString() : (T = I(b.c), T = g <= $ || g >= K ? R(T, g) : N(T, g, "0"), b.s < 0 ? "-" + T : T);
      }
      return P.absoluteValue = P.abs = function() {
        var b = new te(this);
        return b.s < 0 && (b.s = 1), b;
      }, P.comparedTo = function(b, T) {
        return c(this, new te(b, T));
      }, P.decimalPlaces = P.dp = function(b, T) {
        var g, x, U, k = this;
        if (b != null)
          return E(b, 0, p), T == null ? T = V : E(T, 0, 8), _e(new te(k), b + k.e + 1, T);
        if (!(g = k.c)) return null;
        if (x = ((U = g.length - 1) - A(this.e / u)) * u, U = g[U]) for (; U % 10 == 0; U /= 10, x--) ;
        return x < 0 && (x = 0), x;
      }, P.dividedBy = P.div = function(b, T) {
        return h(this, new te(b, T), D, V);
      }, P.dividedToIntegerBy = P.idiv = function(b, T) {
        return h(this, new te(b, T), 0, 1);
      }, P.exponentiatedBy = P.pow = function(b, T) {
        var g, x, U, k, W, q, z, j, Y, M = this;
        if (b = new te(b), b.c && !b.isInteger())
          throw Error(s + "Exponent not an integer: " + w(b));
        if (T != null && (T = new te(T)), q = b.e > 14, !M.c || !M.c[0] || M.c[0] == 1 && !M.e && M.c.length == 1 || !b.c || !b.c[0])
          return Y = new te(Math.pow(+w(M), q ? b.s * (2 - v(b)) : +w(b))), T ? Y.mod(T) : Y;
        if (z = b.s < 0, T) {
          if (T.c ? !T.c[0] : !T.s) return new te(NaN);
          x = !z && M.isInteger() && T.isInteger(), x && (M = M.mod(T));
        } else {
          if (b.e > 9 && (M.e > 0 || M.e < -1 || (M.e == 0 ? M.c[0] > 1 || q && M.c[1] >= 24e7 : M.c[0] < 8e13 || q && M.c[0] <= 9999975e7)))
            return k = M.s < 0 && v(b) ? -0 : 0, M.e > -1 && (k = 1 / k), new te(z ? 1 / k : k);
          se && (k = i(se / u + 2));
        }
        for (q ? (g = new te(0.5), z && (b.s = 1), j = v(b)) : (U = Math.abs(+w(b)), j = U % 2), Y = new te(L); ; ) {
          if (j) {
            if (Y = Y.times(M), !Y.c) break;
            k ? Y.c.length > k && (Y.c.length = k) : x && (Y = Y.mod(T));
          }
          if (U) {
            if (U = a(U / 2), U === 0) break;
            j = U % 2;
          } else if (b = b.times(g), _e(b, b.e + 1, 1), b.e > 14)
            j = v(b);
          else {
            if (U = +w(b), U === 0) break;
            j = U % 2;
          }
          M = M.times(M), k ? M.c && M.c.length > k && (M.c.length = k) : x && (M = M.mod(T));
        }
        return x ? Y : (z && (Y = L.div(Y)), T ? Y.mod(T) : k ? _e(Y, se, V, W) : Y);
      }, P.integerValue = function(b) {
        var T = new te(this);
        return b == null ? b = V : E(b, 0, 8), _e(T, T.e + 1, b);
      }, P.isEqualTo = P.eq = function(b, T) {
        return c(this, new te(b, T)) === 0;
      }, P.isFinite = function() {
        return !!this.c;
      }, P.isGreaterThan = P.gt = function(b, T) {
        return c(this, new te(b, T)) > 0;
      }, P.isGreaterThanOrEqualTo = P.gte = function(b, T) {
        return (T = c(this, new te(b, T))) === 1 || T === 0;
      }, P.isInteger = function() {
        return !!this.c && A(this.e / u) > this.c.length - 2;
      }, P.isLessThan = P.lt = function(b, T) {
        return c(this, new te(b, T)) < 0;
      }, P.isLessThanOrEqualTo = P.lte = function(b, T) {
        return (T = c(this, new te(b, T))) === -1 || T === 0;
      }, P.isNaN = function() {
        return !this.s;
      }, P.isNegative = function() {
        return this.s < 0;
      }, P.isPositive = function() {
        return this.s > 0;
      }, P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, P.minus = function(b, T) {
        var g, x, U, k, W = this, q = W.s;
        if (b = new te(b, T), T = b.s, !q || !T) return new te(NaN);
        if (q != T)
          return b.s = -T, W.plus(b);
        var z = W.e / u, j = b.e / u, Y = W.c, M = b.c;
        if (!z || !j) {
          if (!Y || !M) return Y ? (b.s = -T, b) : new te(M ? W : NaN);
          if (!Y[0] || !M[0])
            return M[0] ? (b.s = -T, b) : new te(Y[0] ? W : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              V == 3 ? -0 : 0
            ));
        }
        if (z = A(z), j = A(j), Y = Y.slice(), q = z - j) {
          for ((k = q < 0) ? (q = -q, U = Y) : (j = z, U = M), U.reverse(), T = q; T--; U.push(0)) ;
          U.reverse();
        } else
          for (x = (k = (q = Y.length) < (T = M.length)) ? q : T, q = T = 0; T < x; T++)
            if (Y[T] != M[T]) {
              k = Y[T] < M[T];
              break;
            }
        if (k && (U = Y, Y = M, M = U, b.s = -b.s), T = (x = M.length) - (g = Y.length), T > 0) for (; T--; Y[g++] = 0) ;
        for (T = l - 1; x > q; ) {
          if (Y[--x] < M[x]) {
            for (g = x; g && !Y[--g]; Y[g] = T) ;
            --Y[g], Y[x] += l;
          }
          Y[x] -= M[x];
        }
        for (; Y[0] == 0; Y.splice(0, 1), --j) ;
        return Y[0] ? De(b, Y, j) : (b.s = V == 3 ? -1 : 1, b.c = [b.e = 0], b);
      }, P.modulo = P.mod = function(b, T) {
        var g, x, U = this;
        return b = new te(b, T), !U.c || !b.s || b.c && !b.c[0] ? new te(NaN) : !b.c || U.c && !U.c[0] ? new te(U) : (ae == 9 ? (x = b.s, b.s = 1, g = h(U, b, 0, 3), b.s = x, g.s *= x) : g = h(U, b, 0, ae), b = U.minus(g.times(b)), !b.c[0] && ae == 1 && (b.s = U.s), b);
      }, P.multipliedBy = P.times = function(b, T) {
        var g, x, U, k, W, q, z, j, Y, M, X, J, Z, oe, he, Ee = this, be = Ee.c, Re = (b = new te(b, T)).c;
        if (!be || !Re || !be[0] || !Re[0])
          return !Ee.s || !b.s || be && !be[0] && !Re || Re && !Re[0] && !be ? b.c = b.e = b.s = null : (b.s *= Ee.s, !be || !Re ? b.c = b.e = null : (b.c = [0], b.e = 0)), b;
        for (x = A(Ee.e / u) + A(b.e / u), b.s *= Ee.s, z = be.length, M = Re.length, z < M && (Z = be, be = Re, Re = Z, U = z, z = M, M = U), U = z + M, Z = []; U--; Z.push(0)) ;
        for (oe = l, he = m, U = M; --U >= 0; ) {
          for (g = 0, X = Re[U] % he, J = Re[U] / he | 0, W = z, k = U + W; k > U; )
            j = be[--W] % he, Y = be[W] / he | 0, q = J * j + Y * X, j = X * j + q % he * he + Z[k] + g, g = (j / oe | 0) + (q / he | 0) + J * Y, Z[k--] = j % oe;
          Z[k] = g;
        }
        return g ? ++x : Z.splice(0, 1), De(b, Z, x);
      }, P.negated = function() {
        var b = new te(this);
        return b.s = -b.s || null, b;
      }, P.plus = function(b, T) {
        var g, x = this, U = x.s;
        if (b = new te(b, T), T = b.s, !U || !T) return new te(NaN);
        if (U != T)
          return b.s = -T, x.minus(b);
        var k = x.e / u, W = b.e / u, q = x.c, z = b.c;
        if (!k || !W) {
          if (!q || !z) return new te(U / 0);
          if (!q[0] || !z[0]) return z[0] ? b : new te(q[0] ? x : U * 0);
        }
        if (k = A(k), W = A(W), q = q.slice(), U = k - W) {
          for (U > 0 ? (W = k, g = z) : (U = -U, g = q), g.reverse(); U--; g.push(0)) ;
          g.reverse();
        }
        for (U = q.length, T = z.length, U - T < 0 && (g = z, z = q, q = g, T = U), U = 0; T; )
          U = (q[--T] = q[T] + z[T] + U) / l | 0, q[T] = l === q[T] ? 0 : q[T] % l;
        return U && (q = [U].concat(q), ++W), De(b, q, W);
      }, P.precision = P.sd = function(b, T) {
        var g, x, U, k = this;
        if (b != null && b !== !!b)
          return E(b, 1, p), T == null ? T = V : E(T, 0, 8), _e(new te(k), b, T);
        if (!(g = k.c)) return null;
        if (U = g.length - 1, x = U * u + 1, U = g[U]) {
          for (; U % 10 == 0; U /= 10, x--) ;
          for (U = g[0]; U >= 10; U /= 10, x++) ;
        }
        return b && k.e + 1 > x && (x = k.e + 1), x;
      }, P.shiftedBy = function(b) {
        return E(b, -f, f), this.times("1e" + b);
      }, P.squareRoot = P.sqrt = function() {
        var b, T, g, x, U, k = this, W = k.c, q = k.s, z = k.e, j = D + 4, Y = new te("0.5");
        if (q !== 1 || !W || !W[0])
          return new te(!q || q < 0 && (!W || W[0]) ? NaN : W ? k : 1 / 0);
        if (q = Math.sqrt(+w(k)), q == 0 || q == 1 / 0 ? (T = I(W), (T.length + z) % 2 == 0 && (T += "0"), q = Math.sqrt(+T), z = A((z + 1) / 2) - (z < 0 || z % 2), q == 1 / 0 ? T = "5e" + z : (T = q.toExponential(), T = T.slice(0, T.indexOf("e") + 1) + z), g = new te(T)) : g = new te(q + ""), g.c[0]) {
          for (z = g.e, q = z + j, q < 3 && (q = 0); ; )
            if (U = g, g = Y.times(U.plus(h(k, U, j, 1))), I(U.c).slice(0, q) === (T = I(g.c)).slice(0, q))
              if (g.e < z && --q, T = T.slice(q - 3, q + 1), T == "9999" || !x && T == "4999") {
                if (!x && (_e(U, U.e + D + 2, 0), U.times(U).eq(k))) {
                  g = U;
                  break;
                }
                j += 4, q += 4, x = 1;
              } else {
                (!+T || !+T.slice(1) && T.charAt(0) == "5") && (_e(g, g.e + D + 2, 1), b = !g.times(g).eq(k));
                break;
              }
        }
        return _e(g, g.e + D + 1, V, b);
      }, P.toExponential = function(b, T) {
        return b != null && (E(b, 0, p), b++), Ce(this, b, T, 1);
      }, P.toFixed = function(b, T) {
        return b != null && (E(b, 0, p), b = b + this.e + 1), Ce(this, b, T);
      }, P.toFormat = function(b, T, g) {
        var x, U = this;
        if (g == null)
          b != null && T && typeof T == "object" ? (g = T, T = null) : b && typeof b == "object" ? (g = b, b = T = null) : g = me;
        else if (typeof g != "object")
          throw Error(s + "Argument not an object: " + g);
        if (x = U.toFixed(b, T), U.c) {
          var k, W = x.split("."), q = +g.groupSize, z = +g.secondaryGroupSize, j = g.groupSeparator || "", Y = W[0], M = W[1], X = U.s < 0, J = X ? Y.slice(1) : Y, Z = J.length;
          if (z && (k = q, q = z, z = k, Z -= k), q > 0 && Z > 0) {
            for (k = Z % q || q, Y = J.substr(0, k); k < Z; k += q) Y += j + J.substr(k, q);
            z > 0 && (Y += j + J.slice(k)), X && (Y = "-" + Y);
          }
          x = M ? Y + (g.decimalSeparator || "") + ((z = +g.fractionGroupSize) ? M.replace(
            new RegExp("\\d{" + z + "}\\B", "g"),
            "$&" + (g.fractionGroupSeparator || "")
          ) : M) : Y;
        }
        return (g.prefix || "") + x + (g.suffix || "");
      }, P.toFraction = function(b) {
        var T, g, x, U, k, W, q, z, j, Y, M, X, J = this, Z = J.c;
        if (b != null && (q = new te(b), !q.isInteger() && (q.c || q.s !== 1) || q.lt(L)))
          throw Error(s + "Argument " + (q.isInteger() ? "out of range: " : "not an integer: ") + w(q));
        if (!Z) return new te(J);
        for (T = new te(L), j = g = new te(L), x = z = new te(L), X = I(Z), k = T.e = X.length - J.e - 1, T.c[0] = y[(W = k % u) < 0 ? u + W : W], b = !b || q.comparedTo(T) > 0 ? k > 0 ? T : j : q, W = ee, ee = 1 / 0, q = new te(X), z.c[0] = 0; Y = h(q, T, 0, 1), U = g.plus(Y.times(x)), U.comparedTo(b) != 1; )
          g = x, x = U, j = z.plus(Y.times(U = j)), z = U, T = q.minus(Y.times(U = T)), q = U;
        return U = h(b.minus(g), x, 0, 1), z = z.plus(U.times(j)), g = g.plus(U.times(x)), z.s = j.s = J.s, k = k * 2, M = h(j, x, k, V).minus(J).abs().comparedTo(
          h(z, g, k, V).minus(J).abs()
        ) < 1 ? [j, x] : [z, g], ee = W, M;
      }, P.toNumber = function() {
        return +w(this);
      }, P.toPrecision = function(b, T) {
        return b != null && E(b, 1, p), Ce(this, b, T, 2);
      }, P.toString = function(b) {
        var T, g = this, x = g.s, U = g.e;
        return U === null ? x ? (T = "Infinity", x < 0 && (T = "-" + T)) : T = "NaN" : (b == null ? T = U <= $ || U >= K ? R(I(g.c), U) : N(I(g.c), U, "0") : b === 10 && Se ? (g = _e(new te(g), D + U + 1, V), T = N(I(g.c), g.e, "0")) : (E(b, 2, ye.length, "Base"), T = d(N(I(g.c), U, "0"), 10, b, x, !0)), x < 0 && g.c[0] && (T = "-" + T)), T;
      }, P.valueOf = P.toJSON = function() {
        return w(this);
      }, P._isBigNumber = !0, C != null && te.set(C), te;
    }
    function A(C) {
      var h = C | 0;
      return C > 0 || C === h ? h : h - 1;
    }
    function I(C) {
      for (var h, d, O = 1, P = C.length, L = C[0] + ""; O < P; ) {
        for (h = C[O++] + "", d = u - h.length; d--; h = "0" + h) ;
        L += h;
      }
      for (P = L.length; L.charCodeAt(--P) === 48; ) ;
      return L.slice(0, P + 1 || 1);
    }
    function c(C, h) {
      var d, O, P = C.c, L = h.c, D = C.s, V = h.s, $ = C.e, K = h.e;
      if (!D || !V) return null;
      if (d = P && !P[0], O = L && !L[0], d || O) return d ? O ? 0 : -V : D;
      if (D != V) return D;
      if (d = D < 0, O = $ == K, !P || !L) return O ? 0 : !P ^ d ? 1 : -1;
      if (!O) return $ > K ^ d ? 1 : -1;
      for (V = ($ = P.length) < (K = L.length) ? $ : K, D = 0; D < V; D++) if (P[D] != L[D]) return P[D] > L[D] ^ d ? 1 : -1;
      return $ == K ? 0 : $ > K ^ d ? 1 : -1;
    }
    function E(C, h, d, O) {
      if (C < h || C > d || C !== a(C))
        throw Error(s + (O || "Argument") + (typeof C == "number" ? C < h || C > d ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(C));
    }
    function v(C) {
      var h = C.c.length - 1;
      return A(C.e / u) == h && C.c[h] % 2 != 0;
    }
    function R(C, h) {
      return (C.length > 1 ? C.charAt(0) + "." + C.slice(1) : C) + (h < 0 ? "e" : "e+") + h;
    }
    function N(C, h, d) {
      var O, P;
      if (h < 0) {
        for (P = d + "."; ++h; P += d) ;
        C = P + C;
      } else if (O = C.length, ++h > O) {
        for (P = d, h -= O; --h; P += d) ;
        C += P;
      } else h < O && (C = C.slice(0, h) + "." + C.slice(h));
      return C;
    }
    r = S(), r.default = r.BigNumber = r, t.exports ? t.exports = r : (e || (e = typeof self < "u" && self ? self : window), e.BigNumber = r);
  })(pe);
})(_g);
var Sg = _g.exports;
(function(t) {
  var e = Sg, r = t.exports;
  (function() {
    var n = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, i, a, s = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, o;
    function l(f) {
      return n.lastIndex = 0, n.test(f) ? '"' + f.replace(n, function(y) {
        var m = s[y];
        return typeof m == "string" ? m : "\\u" + ("0000" + y.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + f + '"';
    }
    function u(f, y) {
      var m, p, S, A, I = i, c, E = y[f], v = E != null && (E instanceof e || e.isBigNumber(E));
      switch (E && typeof E == "object" && typeof E.toJSON == "function" && (E = E.toJSON(f)), typeof o == "function" && (E = o.call(y, f, E)), typeof E) {
        case "string":
          return v ? E : l(E);
        case "number":
          return isFinite(E) ? String(E) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(E);
        case "object":
          if (!E)
            return "null";
          if (i += a, c = [], Object.prototype.toString.apply(E) === "[object Array]") {
            for (A = E.length, m = 0; m < A; m += 1)
              c[m] = u(m, E) || "null";
            return S = c.length === 0 ? "[]" : i ? `[
` + i + c.join(`,
` + i) + `
` + I + "]" : "[" + c.join(",") + "]", i = I, S;
          }
          if (o && typeof o == "object")
            for (A = o.length, m = 0; m < A; m += 1)
              typeof o[m] == "string" && (p = o[m], S = u(p, E), S && c.push(l(p) + (i ? ": " : ":") + S));
          else
            Object.keys(E).forEach(function(R) {
              var N = u(R, E);
              N && c.push(l(R) + (i ? ": " : ":") + N);
            });
          return S = c.length === 0 ? "{}" : i ? `{
` + i + c.join(`,
` + i) + `
` + I + "}" : "{" + c.join(",") + "}", i = I, S;
      }
    }
    typeof r.stringify != "function" && (r.stringify = function(f, y, m) {
      var p;
      if (i = "", a = "", typeof m == "number")
        for (p = 0; p < m; p += 1)
          a += " ";
      else typeof m == "string" && (a = m);
      if (o = y, y && typeof y != "function" && (typeof y != "object" || typeof y.length != "number"))
        throw new Error("JSON.stringify");
      return u("", { "": f });
    });
  })();
})(Cg);
var WC = Cg.exports, Xa = null;
const JC = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, zC = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var XC = function(t) {
  var e = {
    strict: !1,
    // not being strict means do not generate syntax errors for "duplicate key"
    storeAsString: !1,
    // toggles whether the values should be stored as BigNumber (default) or a string
    alwaysParseAsBig: !1,
    // toggles whether all numbers should be Big
    useNativeBigInt: !1,
    // toggles whether to use native BigInt instead of bignumber.js
    protoAction: "error",
    constructorAction: "error"
  };
  if (t != null) {
    if (t.strict === !0 && (e.strict = !0), t.storeAsString === !0 && (e.storeAsString = !0), e.alwaysParseAsBig = t.alwaysParseAsBig === !0 ? t.alwaysParseAsBig : !1, e.useNativeBigInt = t.useNativeBigInt === !0 ? t.useNativeBigInt : !1, typeof t.constructorAction < "u")
      if (t.constructorAction === "error" || t.constructorAction === "ignore" || t.constructorAction === "preserve")
        e.constructorAction = t.constructorAction;
      else
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${t.constructorAction}`
        );
    if (typeof t.protoAction < "u")
      if (t.protoAction === "error" || t.protoAction === "ignore" || t.protoAction === "preserve")
        e.protoAction = t.protoAction;
      else
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${t.protoAction}`
        );
  }
  var r, n, i = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, a, s = function(A) {
    throw {
      name: "SyntaxError",
      message: A,
      at: r,
      text: a
    };
  }, o = function(A) {
    return A && A !== n && s("Expected '" + A + "' instead of '" + n + "'"), n = a.charAt(r), r += 1, n;
  }, l = function() {
    var A, I = "";
    for (n === "-" && (I = "-", o("-")); n >= "0" && n <= "9"; )
      I += n, o();
    if (n === ".")
      for (I += "."; o() && n >= "0" && n <= "9"; )
        I += n;
    if (n === "e" || n === "E")
      for (I += n, o(), (n === "-" || n === "+") && (I += n, o()); n >= "0" && n <= "9"; )
        I += n, o();
    if (A = +I, !isFinite(A))
      s("Bad number");
    else
      return Xa == null && (Xa = Sg), I.length > 15 ? e.storeAsString ? I : e.useNativeBigInt ? BigInt(I) : new Xa(I) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(A) : new Xa(A) : A;
  }, u = function() {
    var A, I, c = "", E;
    if (n === '"')
      for (var v = r; o(); ) {
        if (n === '"')
          return r - 1 > v && (c += a.substring(v, r - 1)), o(), c;
        if (n === "\\") {
          if (r - 1 > v && (c += a.substring(v, r - 1)), o(), n === "u") {
            for (E = 0, I = 0; I < 4 && (A = parseInt(o(), 16), !!isFinite(A)); I += 1)
              E = E * 16 + A;
            c += String.fromCharCode(E);
          } else if (typeof i[n] == "string")
            c += i[n];
          else
            break;
          v = r;
        }
      }
    s("Bad string");
  }, f = function() {
    for (; n && n <= " "; )
      o();
  }, y = function() {
    switch (n) {
      case "t":
        return o("t"), o("r"), o("u"), o("e"), !0;
      case "f":
        return o("f"), o("a"), o("l"), o("s"), o("e"), !1;
      case "n":
        return o("n"), o("u"), o("l"), o("l"), null;
    }
    s("Unexpected '" + n + "'");
  }, m, p = function() {
    var A = [];
    if (n === "[") {
      if (o("["), f(), n === "]")
        return o("]"), A;
      for (; n; ) {
        if (A.push(m()), f(), n === "]")
          return o("]"), A;
        o(","), f();
      }
    }
    s("Bad array");
  }, S = function() {
    var A, I = /* @__PURE__ */ Object.create(null);
    if (n === "{") {
      if (o("{"), f(), n === "}")
        return o("}"), I;
      for (; n; ) {
        if (A = u(), f(), o(":"), e.strict === !0 && Object.hasOwnProperty.call(I, A) && s('Duplicate key "' + A + '"'), JC.test(A) === !0 ? e.protoAction === "error" ? s("Object contains forbidden prototype property") : e.protoAction === "ignore" ? m() : I[A] = m() : zC.test(A) === !0 ? e.constructorAction === "error" ? s("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? m() : I[A] = m() : I[A] = m(), f(), n === "}")
          return o("}"), I;
        o(","), f();
      }
    }
    s("Bad object");
  };
  return m = function() {
    switch (f(), n) {
      case "{":
        return S();
      case "[":
        return p();
      case '"':
        return u();
      case "-":
        return l();
      default:
        return n >= "0" && n <= "9" ? l() : y();
    }
  }, function(A, I) {
    var c;
    return a = A + "", r = 0, n = " ", c = m(), f(), n && s("Syntax error"), typeof I == "function" ? function E(v, R) {
      var N, C = v[R];
      return C && typeof C == "object" && Object.keys(C).forEach(function(h) {
        N = E(C, h), N !== void 0 ? C[h] = N : delete C[h];
      }), I.call(v, R, C);
    }({ "": c }, "") : c;
  };
}, YC = XC, Ig = WC.stringify, bg = YC;
Ao.exports = function(t) {
  return {
    parse: bg(t),
    stringify: Ig
  };
};
Ao.exports.parse = bg();
Ao.exports.stringify = Ig;
var QC = Ao.exports, Cl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.GCE_LINUX_BIOS_PATHS = void 0, t.isGoogleCloudServerless = i, t.isGoogleComputeEngineLinux = a, t.isGoogleComputeEngineMACAddress = s, t.isGoogleComputeEngine = o, t.detectGCPResidency = l;
  const e = ge, r = ge;
  t.GCE_LINUX_BIOS_PATHS = {
    BIOS_DATE: "/sys/class/dmi/id/bios_date",
    BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
  };
  const n = /^42:01/;
  function i() {
    return !!(process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE);
  }
  function a() {
    if ((0, r.platform)() !== "linux")
      return !1;
    try {
      (0, e.statSync)(t.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
      const u = (0, e.readFileSync)(t.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
      return /Google/.test(u);
    } catch {
      return !1;
    }
  }
  function s() {
    const u = (0, r.networkInterfaces)();
    for (const f of Object.values(u))
      if (f) {
        for (const { mac: y } of f)
          if (n.test(y))
            return !0;
      }
    return !1;
  }
  function o() {
    return a() || s();
  }
  function l() {
    return i() || o();
  }
})(Cl);
var wg = {}, Tg = {}, Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.Colours = void 0;
class Le {
  /**
   * @param stream The stream (e.g. process.stderr)
   * @returns true if the stream should have colourization enabled
   */
  static isEnabled(e) {
    return e.isTTY && (typeof e.getColorDepth == "function" ? e.getColorDepth() > 2 : !0);
  }
  static refresh() {
    Le.enabled = Le.isEnabled(process.stderr), this.enabled ? (Le.reset = "\x1B[0m", Le.bright = "\x1B[1m", Le.dim = "\x1B[2m", Le.red = "\x1B[31m", Le.green = "\x1B[32m", Le.yellow = "\x1B[33m", Le.blue = "\x1B[34m", Le.magenta = "\x1B[35m", Le.cyan = "\x1B[36m", Le.white = "\x1B[37m", Le.grey = "\x1B[90m") : (Le.reset = "", Le.bright = "", Le.dim = "", Le.red = "", Le.green = "", Le.yellow = "", Le.blue = "", Le.magenta = "", Le.cyan = "", Le.white = "", Le.grey = "");
  }
}
Co.Colours = Le;
Le.enabled = !1;
Le.reset = "";
Le.bright = "";
Le.dim = "";
Le.red = "";
Le.green = "";
Le.yellow = "";
Le.blue = "";
Le.magenta = "";
Le.cyan = "";
Le.white = "";
Le.grey = "";
Le.refresh();
(function(t) {
  var e = pe && pe.__createBinding || (Object.create ? function(N, C, h, d) {
    d === void 0 && (d = h);
    var O = Object.getOwnPropertyDescriptor(C, h);
    (!O || ("get" in O ? !C.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return C[h];
    } }), Object.defineProperty(N, d, O);
  } : function(N, C, h, d) {
    d === void 0 && (d = h), N[d] = C[h];
  }), r = pe && pe.__setModuleDefault || (Object.create ? function(N, C) {
    Object.defineProperty(N, "default", { enumerable: !0, value: C });
  } : function(N, C) {
    N.default = C;
  }), n = pe && pe.__importStar || function(N) {
    if (N && N.__esModule) return N;
    var C = {};
    if (N != null) for (var h in N) h !== "default" && Object.prototype.hasOwnProperty.call(N, h) && e(C, N, h);
    return r(C, N), C;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.env = t.DebugLogBackendBase = t.placeholder = t.AdhocDebugLogger = t.LogSeverity = void 0, t.getNodeBackend = m, t.getDebugBackend = S, t.getStructuredBackend = I, t.setBackend = v, t.log = R;
  const i = ge, a = n(ge), s = n(ge), o = Co;
  var l;
  (function(N) {
    N.DEFAULT = "DEFAULT", N.DEBUG = "DEBUG", N.INFO = "INFO", N.WARNING = "WARNING", N.ERROR = "ERROR";
  })(l || (t.LogSeverity = l = {}));
  class u extends i.EventEmitter {
    /**
     * @param upstream The backend will pass a function that will be
     *   called whenever our logger function is invoked.
     */
    constructor(C, h) {
      super(), this.namespace = C, this.upstream = h, this.func = Object.assign(this.invoke.bind(this), {
        // Also add an instance pointer back to us.
        instance: this,
        // And pull over the EventEmitter functionality.
        on: (d, O) => this.on(d, O)
      }), this.func.debug = (...d) => this.invokeSeverity(l.DEBUG, ...d), this.func.info = (...d) => this.invokeSeverity(l.INFO, ...d), this.func.warn = (...d) => this.invokeSeverity(l.WARNING, ...d), this.func.error = (...d) => this.invokeSeverity(l.ERROR, ...d), this.func.sublog = (d) => R(d, this.func);
    }
    invoke(C, ...h) {
      this.upstream && this.upstream(C, ...h), this.emit("log", C, h);
    }
    invokeSeverity(C, ...h) {
      this.invoke({ severity: C }, ...h);
    }
  }
  t.AdhocDebugLogger = u, t.placeholder = new u("", () => {
  }).func;
  class f {
    constructor() {
      var C;
      this.cached = /* @__PURE__ */ new Map(), this.filters = [], this.filtersSet = !1;
      let h = (C = a.env[t.env.nodeEnables]) !== null && C !== void 0 ? C : "*";
      h === "all" && (h = "*"), this.filters = h.split(",");
    }
    log(C, h, ...d) {
      try {
        this.filtersSet || (this.setFilters(), this.filtersSet = !0);
        let O = this.cached.get(C);
        O || (O = this.makeLogger(C), this.cached.set(C, O)), O(h, ...d);
      } catch (O) {
        console.error(O);
      }
    }
  }
  t.DebugLogBackendBase = f;
  class y extends f {
    constructor() {
      super(...arguments), this.enabledRegexp = /.*/g;
    }
    isEnabled(C) {
      return this.enabledRegexp.test(C);
    }
    makeLogger(C) {
      return this.enabledRegexp.test(C) ? (h, ...d) => {
        var O;
        const P = `${o.Colours.green}${C}${o.Colours.reset}`, L = `${o.Colours.yellow}${a.pid}${o.Colours.reset}`;
        let D;
        switch (h.severity) {
          case l.ERROR:
            D = `${o.Colours.red}${h.severity}${o.Colours.reset}`;
            break;
          case l.INFO:
            D = `${o.Colours.magenta}${h.severity}${o.Colours.reset}`;
            break;
          case l.WARNING:
            D = `${o.Colours.yellow}${h.severity}${o.Colours.reset}`;
            break;
          default:
            D = (O = h.severity) !== null && O !== void 0 ? O : l.DEFAULT;
            break;
        }
        const V = s.formatWithOptions({ colors: o.Colours.enabled }, ...d), $ = Object.assign({}, h);
        delete $.severity;
        const K = Object.getOwnPropertyNames($).length ? JSON.stringify($) : "", Q = K ? `${o.Colours.grey}${K}${o.Colours.reset}` : "";
        console.error("%s [%s|%s] %s%s", L, P, D, V, K ? ` ${Q}` : "");
      } : () => {
      };
    }
    // Regexp patterns below are from here:
    // https://github.com/nodejs/node/blob/c0aebed4b3395bd65d54b18d1fd00f071002ac20/lib/internal/util/debuglog.js#L36
    setFilters() {
      const h = this.filters.join(",").replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
      this.enabledRegexp = new RegExp(`^${h}$`, "i");
    }
  }
  function m() {
    return new y();
  }
  class p extends f {
    constructor(C) {
      super(), this.debugPkg = C;
    }
    makeLogger(C) {
      const h = this.debugPkg(C);
      return (d, ...O) => {
        h(O[0], ...O.slice(1));
      };
    }
    setFilters() {
      var C;
      const h = (C = a.env.NODE_DEBUG) !== null && C !== void 0 ? C : "";
      a.env.NODE_DEBUG = `${h}${h ? "," : ""}${this.filters.join(",")}`;
    }
  }
  function S(N) {
    return new p(N);
  }
  class A extends f {
    constructor(C) {
      var h;
      super(), this.upstream = (h = C) !== null && h !== void 0 ? h : new y();
    }
    makeLogger(C) {
      const h = this.upstream.makeLogger(C);
      return (d, ...O) => {
        var P;
        const L = (P = d.severity) !== null && P !== void 0 ? P : l.INFO, D = Object.assign({
          severity: L,
          message: s.format(...O)
        }, d), V = JSON.stringify(D);
        h(d, V);
      };
    }
    setFilters() {
      this.upstream.setFilters();
    }
  }
  function I(N) {
    return new A(N);
  }
  t.env = {
    /**
     * Filter wildcards specific to the Node syntax, and similar to the built-in
     * utils.debuglog() environment variable. If missing, disables logging.
     */
    nodeEnables: "GOOGLE_SDK_NODE_LOGGING"
  };
  const c = /* @__PURE__ */ new Map();
  let E;
  function v(N) {
    E = N, c.clear();
  }
  function R(N, C) {
    if (!a.env[t.env.nodeEnables] || !N)
      return t.placeholder;
    C && (N = `${C.instance.namespace}:${N}`);
    const d = c.get(N);
    if (d)
      return d.func;
    if (E === null)
      return t.placeholder;
    E === void 0 && (E = m());
    const O = (() => {
      let P;
      return new u(N, (D, ...V) => {
        if (P !== E) {
          if (E === null)
            return;
          E === void 0 && (E = m()), P = E;
        }
        E == null || E.log(N, D, ...V);
      });
    })();
    return c.set(N, O), O.func;
  }
})(Tg);
(function(t) {
  var e = pe && pe.__createBinding || (Object.create ? function(n, i, a, s) {
    s === void 0 && (s = a);
    var o = Object.getOwnPropertyDescriptor(i, a);
    (!o || ("get" in o ? !i.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return i[a];
    } }), Object.defineProperty(n, s, o);
  } : function(n, i, a, s) {
    s === void 0 && (s = a), n[s] = i[a];
  }), r = pe && pe.__exportStar || function(n, i) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, n, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Tg, t);
})(wg);
(function(t) {
  var e = pe && pe.__createBinding || (Object.create ? function(h, d, O, P) {
    P === void 0 && (P = O);
    var L = Object.getOwnPropertyDescriptor(d, O);
    (!L || ("get" in L ? !d.__esModule : L.writable || L.configurable)) && (L = { enumerable: !0, get: function() {
      return d[O];
    } }), Object.defineProperty(h, P, L);
  } : function(h, d, O, P) {
    P === void 0 && (P = O), h[P] = d[O];
  }), r = pe && pe.__exportStar || function(h, d) {
    for (var O in h) O !== "default" && !Object.prototype.hasOwnProperty.call(d, O) && e(d, h, O);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.gcpResidencyCache = t.METADATA_SERVER_DETECTION = t.HEADERS = t.HEADER_VALUE = t.HEADER_NAME = t.SECONDARY_HOST_ADDRESS = t.HOST_ADDRESS = t.BASE_PATH = void 0, t.instance = m, t.project = p, t.universe = S, t.bulk = A, t.isAvailable = E, t.resetIsAvailableCache = v, t.getGCPResidency = R, t.setGCPResidency = N, t.requestTimeout = C;
  const n = Lr, i = QC, a = Cl, s = wg;
  t.BASE_PATH = "/computeMetadata/v1", t.HOST_ADDRESS = "http://169.254.169.254", t.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.", t.HEADER_NAME = "Metadata-Flavor", t.HEADER_VALUE = "Google", t.HEADERS = Object.freeze({ [t.HEADER_NAME]: t.HEADER_VALUE });
  const o = s.log("gcp metadata");
  t.METADATA_SERVER_DETECTION = Object.freeze({
    "assume-present": "don't try to ping the metadata server, but assume it's present",
    none: "don't try to ping the metadata server, but don't try to use it either",
    "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
    "ping-only": "skip the BIOS probe, and go straight to pinging"
  });
  function l(h) {
    return h || (h = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || t.HOST_ADDRESS), /^https?:\/\//.test(h) || (h = `http://${h}`), new URL(t.BASE_PATH, h).href;
  }
  function u(h) {
    Object.keys(h).forEach((d) => {
      switch (d) {
        case "params":
        case "property":
        case "headers":
          break;
        case "qs":
          throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
        default:
          throw new Error(`'${d}' is not a valid configuration option.`);
      }
    });
  }
  async function f(h, d = {}, O = 3, P = !1) {
    let L = "", D = {}, V = {};
    if (typeof h == "object") {
      const ee = h;
      L = ee.metadataKey, D = ee.params || D, V = ee.headers || V, O = ee.noResponseRetries || O, P = ee.fastFail || P;
    } else
      L = h;
    typeof d == "string" ? L += `/${d}` : (u(d), d.property && (L += `/${d.property}`), V = d.headers || V, D = d.params || D);
    const $ = P ? y : n.request, K = {
      url: `${l()}/${L}`,
      headers: { ...t.HEADERS, ...V },
      retryConfig: { noResponseRetries: O },
      params: D,
      responseType: "text",
      timeout: C()
    };
    o.info("instance request %j", K);
    const Q = await $(K);
    if (o.info("instance metadata is %s", Q.data), Q.headers[t.HEADER_NAME.toLowerCase()] !== t.HEADER_VALUE)
      throw new Error(`Invalid response from metadata service: incorrect ${t.HEADER_NAME} header. Expected '${t.HEADER_VALUE}', got ${Q.headers[t.HEADER_NAME.toLowerCase()] ? `'${Q.headers[t.HEADER_NAME.toLowerCase()]}'` : "no header"}`);
    if (typeof Q.data == "string")
      try {
        return i.parse(Q.data);
      } catch {
      }
    return Q.data;
  }
  async function y(h) {
    var d;
    const O = {
      ...h,
      url: (d = h.url) === null || d === void 0 ? void 0 : d.toString().replace(l(), l(t.SECONDARY_HOST_ADDRESS))
    };
    let P = !1;
    const L = (0, n.request)(h).then((V) => (P = !0, V)).catch((V) => {
      if (P)
        return D;
      throw P = !0, V;
    }), D = (0, n.request)(O).then((V) => (P = !0, V)).catch((V) => {
      if (P)
        return L;
      throw P = !0, V;
    });
    return Promise.race([L, D]);
  }
  function m(h) {
    return f("instance", h);
  }
  function p(h) {
    return f("project", h);
  }
  function S(h) {
    return f("universe", h);
  }
  async function A(h) {
    const d = {};
    return await Promise.all(h.map((O) => (async () => {
      const P = await f(O), L = O.metadataKey;
      d[L] = P;
    })())), d;
  }
  function I() {
    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
  }
  let c;
  async function E() {
    if (process.env.METADATA_SERVER_DETECTION) {
      const h = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
      if (!(h in t.METADATA_SERVER_DETECTION))
        throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${h}\`, but it should be \`${Object.keys(t.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
      switch (h) {
        case "assume-present":
          return !0;
        case "none":
          return !1;
        case "bios-only":
          return R();
      }
    }
    try {
      return c === void 0 && (c = f(
        "instance",
        void 0,
        I(),
        // If the default HOST_ADDRESS has been overridden, we should not
        // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
        // a non-GCP environment):
        !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
      )), await c, !0;
    } catch (h) {
      const d = h;
      if (process.env.DEBUG_AUTH && console.info(d), d.type === "request-timeout" || d.response && d.response.status === 404)
        return !1;
      if (!(d.response && d.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code
      // is not populated:
      (!d.code || ![
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "ENETUNREACH",
        "ENOENT",
        "ENOTFOUND",
        "ECONNREFUSED"
      ].includes(d.code))) {
        let O = "UNKNOWN";
        d.code && (O = d.code), process.emitWarning(`received unexpected error = ${d.message} code = ${O}`, "MetadataLookupWarning");
      }
      return !1;
    }
  }
  function v() {
    c = void 0;
  }
  t.gcpResidencyCache = null;
  function R() {
    return t.gcpResidencyCache === null && N(), t.gcpResidencyCache;
  }
  function N(h = null) {
    t.gcpResidencyCache = h !== null ? h : (0, a.detectGCPResidency)();
  }
  function C() {
    return R() ? 0 : 3e3;
  }
  r(Cl, t);
})(ya);
var di = {}, Xi = {}, _o = {};
_o.byteLength = t_;
_o.toByteArray = n_;
_o.fromByteArray = s_;
var Kr = [], dr = [], ZC = typeof Uint8Array < "u" ? Uint8Array : Array, Lc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var hi = 0, e_ = Lc.length; hi < e_; ++hi)
  Kr[hi] = Lc[hi], dr[Lc.charCodeAt(hi)] = hi;
dr[45] = 62;
dr[95] = 63;
function Rg(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - r % 4;
  return [r, n];
}
function t_(t) {
  var e = Rg(t), r = e[0], n = e[1];
  return (r + n) * 3 / 4 - n;
}
function r_(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function n_(t) {
  var e, r = Rg(t), n = r[0], i = r[1], a = new ZC(r_(t, n, i)), s = 0, o = i > 0 ? n - 4 : n, l;
  for (l = 0; l < o; l += 4)
    e = dr[t.charCodeAt(l)] << 18 | dr[t.charCodeAt(l + 1)] << 12 | dr[t.charCodeAt(l + 2)] << 6 | dr[t.charCodeAt(l + 3)], a[s++] = e >> 16 & 255, a[s++] = e >> 8 & 255, a[s++] = e & 255;
  return i === 2 && (e = dr[t.charCodeAt(l)] << 2 | dr[t.charCodeAt(l + 1)] >> 4, a[s++] = e & 255), i === 1 && (e = dr[t.charCodeAt(l)] << 10 | dr[t.charCodeAt(l + 1)] << 4 | dr[t.charCodeAt(l + 2)] >> 2, a[s++] = e >> 8 & 255, a[s++] = e & 255), a;
}
function i_(t) {
  return Kr[t >> 18 & 63] + Kr[t >> 12 & 63] + Kr[t >> 6 & 63] + Kr[t & 63];
}
function a_(t, e, r) {
  for (var n, i = [], a = e; a < r; a += 3)
    n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (t[a + 2] & 255), i.push(i_(n));
  return i.join("");
}
function s_(t) {
  for (var e, r = t.length, n = r % 3, i = [], a = 16383, s = 0, o = r - n; s < o; s += a)
    i.push(a_(t, s, s + a > o ? o : s + a));
  return n === 1 ? (e = t[r - 1], i.push(
    Kr[e >> 2] + Kr[e << 4 & 63] + "=="
  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(
    Kr[e >> 10] + Kr[e >> 4 & 63] + Kr[e << 2 & 63] + "="
  )), i.join("");
}
var sh;
function o_() {
  if (sh) return Xi;
  sh = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.BrowserCrypto = void 0;
  const t = _o, e = va();
  class r {
    constructor() {
      if (typeof window > "u" || window.crypto === void 0 || window.crypto.subtle === void 0)
        throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
    }
    async sha256DigestBase64(i) {
      const a = new TextEncoder().encode(i), s = await window.crypto.subtle.digest("SHA-256", a);
      return t.fromByteArray(new Uint8Array(s));
    }
    randomBytesBase64(i) {
      const a = new Uint8Array(i);
      return window.crypto.getRandomValues(a), t.fromByteArray(a);
    }
    static padBase64(i) {
      for (; i.length % 4 !== 0; )
        i += "=";
      return i;
    }
    async verify(i, a, s) {
      const o = {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, l = new TextEncoder().encode(a), u = t.toByteArray(r.padBase64(s)), f = await window.crypto.subtle.importKey("jwk", i, o, !0, ["verify"]);
      return await window.crypto.subtle.verify(o, f, u, l);
    }
    async sign(i, a) {
      const s = {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, o = new TextEncoder().encode(a), l = await window.crypto.subtle.importKey("jwk", i, s, !0, ["sign"]), u = await window.crypto.subtle.sign(s, l, o);
      return t.fromByteArray(new Uint8Array(u));
    }
    decodeBase64StringUtf8(i) {
      const a = t.toByteArray(r.padBase64(i));
      return new TextDecoder().decode(a);
    }
    encodeBase64StringUtf8(i) {
      const a = new TextEncoder().encode(i);
      return t.fromByteArray(a);
    }
    /**
     * Computes the SHA-256 hash of the provided string.
     * @param str The plain text string to hash.
     * @return A promise that resolves with the SHA-256 hash of the provided
     *   string in hexadecimal encoding.
     */
    async sha256DigestHex(i) {
      const a = new TextEncoder().encode(i), s = await window.crypto.subtle.digest("SHA-256", a);
      return (0, e.fromArrayBufferToHex)(s);
    }
    /**
     * Computes the HMAC hash of a message using the provided crypto key and the
     * SHA-256 algorithm.
     * @param key The secret crypto key in utf-8 or ArrayBuffer format.
     * @param msg The plain text message.
     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
     *   format.
     */
    async signWithHmacSha256(i, a) {
      const s = typeof i == "string" ? i : String.fromCharCode(...new Uint16Array(i)), o = new TextEncoder(), l = await window.crypto.subtle.importKey("raw", o.encode(s), {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      }, !1, ["sign"]);
      return window.crypto.subtle.sign("HMAC", l, o.encode(a));
    }
  }
  return Xi.BrowserCrypto = r, Xi;
}
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.NodeCrypto = void 0;
const pi = ge;
class c_ {
  async sha256DigestBase64(e) {
    return pi.createHash("sha256").update(e).digest("base64");
  }
  randomBytesBase64(e) {
    return pi.randomBytes(e).toString("base64");
  }
  async verify(e, r, n) {
    const i = pi.createVerify("RSA-SHA256");
    return i.update(r), i.end(), i.verify(e, n, "base64");
  }
  async sign(e, r) {
    const n = pi.createSign("RSA-SHA256");
    return n.update(r), n.end(), n.sign(e, "base64");
  }
  decodeBase64StringUtf8(e) {
    return Buffer.from(e, "base64").toString("utf-8");
  }
  encodeBase64StringUtf8(e) {
    return Buffer.from(e, "utf-8").toString("base64");
  }
  /**
   * Computes the SHA-256 hash of the provided string.
   * @param str The plain text string to hash.
   * @return A promise that resolves with the SHA-256 hash of the provided
   *   string in hexadecimal encoding.
   */
  async sha256DigestHex(e) {
    return pi.createHash("sha256").update(e).digest("hex");
  }
  /**
   * Computes the HMAC hash of a message using the provided crypto key and the
   * SHA-256 algorithm.
   * @param key The secret crypto key in utf-8 or ArrayBuffer format.
   * @param msg The plain text message.
   * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
   *   format.
   */
  async signWithHmacSha256(e, r) {
    const n = typeof e == "string" ? e : l_(e);
    return u_(pi.createHmac("sha256", n).update(r).digest());
  }
}
So.NodeCrypto = c_;
function u_(t) {
  return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
}
function l_(t) {
  return Buffer.from(t);
}
var oh;
function va() {
  if (oh) return di;
  oh = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.createCrypto = r, di.hasBrowserCrypto = n, di.fromArrayBufferToHex = i;
  const t = o_(), e = So;
  function r() {
    return n() ? new t.BrowserCrypto() : new e.NodeCrypto();
  }
  function n() {
    return typeof window < "u" && typeof window.crypto < "u" && typeof window.crypto.subtle < "u";
  }
  function i(a) {
    return Array.from(new Uint8Array(a)).map((o) => o.toString(16).padStart(2, "0")).join("");
  }
  return di;
}
var ei = {}, rf = {};
Object.defineProperty(rf, "__esModule", { value: !0 });
rf.validate = f_;
function f_(t) {
  const e = [
    { invalid: "uri", expected: "url" },
    { invalid: "json", expected: "data" },
    { invalid: "qs", expected: "params" }
  ];
  for (const r of e)
    if (t[r.invalid]) {
      const n = `'${r.invalid}' is not a valid configuration option. Please use '${r.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
      throw new Error(n);
    }
}
const d_ = "9.15.1", Ng = {
  version: d_
};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.DefaultTransporter = void 0;
const h_ = Lr, p_ = rf, g_ = Ng, xg = "google-api-nodejs-client";
class da {
  constructor() {
    this.instance = new h_.Gaxios();
  }
  /**
   * Configures request options before making a request.
   * @param opts GaxiosOptions options.
   * @return Configured options.
   */
  configure(e = {}) {
    if (e.headers = e.headers || {}, typeof window > "u") {
      const r = e.headers["User-Agent"];
      if (r ? r.includes(`${xg}/`) || (e.headers["User-Agent"] = `${r} ${da.USER_AGENT}`) : e.headers["User-Agent"] = da.USER_AGENT, !e.headers["x-goog-api-client"]) {
        const n = process.version.replace(/^v/, "");
        e.headers["x-goog-api-client"] = `gl-node/${n}`;
      }
    }
    return e;
  }
  /**
   * Makes a request using Gaxios with given options.
   * @param opts GaxiosOptions options.
   * @param callback optional callback that contains GaxiosResponse object.
   * @return GaxiosPromise, assuming no callback is passed.
   */
  request(e) {
    return e = this.configure(e), (0, p_.validate)(e), this.instance.request(e).catch((r) => {
      throw this.processError(r);
    });
  }
  get defaults() {
    return this.instance.defaults;
  }
  set defaults(e) {
    this.instance.defaults = e;
  }
  /**
   * Changes the error to include details from the body.
   */
  processError(e) {
    const r = e.response, n = e, i = r ? r.data : null;
    return r && i && i.error && r.status !== 200 ? typeof i.error == "string" ? (n.message = i.error, n.status = r.status) : Array.isArray(i.error.errors) ? (n.message = i.error.errors.map((a) => a.message).join(`
`), n.code = i.error.code, n.errors = i.error.errors) : (n.message = i.error.message, n.code = i.error.code) : r && r.status >= 400 && (n.message = i, n.status = r.status), n;
  }
}
ei.DefaultTransporter = da;
da.USER_AGENT = `${xg}/${g_.version}`;
var Aa = {}, qt = {}, _l = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
  var r = ge, n = r.Buffer;
  function i(s, o) {
    for (var l in s)
      o[l] = s[l];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = a);
  function a(s, o, l) {
    return n(s, o, l);
  }
  a.prototype = Object.create(n.prototype), i(n, a), a.from = function(s, o, l) {
    if (typeof s == "number")
      throw new TypeError("Argument must not be a number");
    return n(s, o, l);
  }, a.alloc = function(s, o, l) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    var u = n(s);
    return o !== void 0 ? typeof l == "string" ? u.fill(o, l) : u.fill(o) : u.fill(0), u;
  }, a.allocUnsafe = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return n(s);
  }, a.allocUnsafeSlow = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(s);
  };
})(_l, _l.exports);
var ln = _l.exports;
function Pc(t) {
  var e = (t / 8 | 0) + (t % 8 === 0 ? 0 : 1);
  return e;
}
var y_ = {
  ES256: Pc(256),
  ES384: Pc(384),
  ES512: Pc(521)
};
function m_(t) {
  var e = y_[t];
  if (e)
    return e;
  throw new Error('Unknown algorithm "' + t + '"');
}
var E_ = m_, bs = ln.Buffer, Og = E_, ws = 128, Dg = 0, v_ = 32, A_ = 16, C_ = 2, Lg = A_ | v_ | Dg << 6, Ts = C_ | Dg << 6;
function __(t) {
  return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function Pg(t) {
  if (bs.isBuffer(t))
    return t;
  if (typeof t == "string")
    return bs.from(t, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function S_(t, e) {
  t = Pg(t);
  var r = Og(e), n = r + 1, i = t.length, a = 0;
  if (t[a++] !== Lg)
    throw new Error('Could not find expected "seq"');
  var s = t[a++];
  if (s === (ws | 1) && (s = t[a++]), i - a < s)
    throw new Error('"seq" specified length of "' + s + '", only "' + (i - a) + '" remaining');
  if (t[a++] !== Ts)
    throw new Error('Could not find expected "int" for "r"');
  var o = t[a++];
  if (i - a - 2 < o)
    throw new Error('"r" specified length of "' + o + '", only "' + (i - a - 2) + '" available');
  if (n < o)
    throw new Error('"r" specified length of "' + o + '", max of "' + n + '" is acceptable');
  var l = a;
  if (a += o, t[a++] !== Ts)
    throw new Error('Could not find expected "int" for "s"');
  var u = t[a++];
  if (i - a !== u)
    throw new Error('"s" specified length of "' + u + '", expected "' + (i - a) + '"');
  if (n < u)
    throw new Error('"s" specified length of "' + u + '", max of "' + n + '" is acceptable');
  var f = a;
  if (a += u, a !== i)
    throw new Error('Expected to consume entire buffer, but "' + (i - a) + '" bytes remain');
  var y = r - o, m = r - u, p = bs.allocUnsafe(y + o + m + u);
  for (a = 0; a < y; ++a)
    p[a] = 0;
  t.copy(p, a, l + Math.max(-y, 0), l + o), a = r;
  for (var S = a; a < S + m; ++a)
    p[a] = 0;
  return t.copy(p, a, f + Math.max(-m, 0), f + u), p = p.toString("base64"), p = __(p), p;
}
function ch(t, e, r) {
  for (var n = 0; e + n < r && t[e + n] === 0; )
    ++n;
  var i = t[e + n] >= ws;
  return i && --n, n;
}
function I_(t, e) {
  t = Pg(t);
  var r = Og(e), n = t.length;
  if (n !== r * 2)
    throw new TypeError('"' + e + '" signatures must be "' + r * 2 + '" bytes, saw "' + n + '"');
  var i = ch(t, 0, r), a = ch(t, r, t.length), s = r - i, o = r - a, l = 2 + s + 1 + 1 + o, u = l < ws, f = bs.allocUnsafe((u ? 2 : 3) + l), y = 0;
  return f[y++] = Lg, u ? f[y++] = l : (f[y++] = ws | 1, f[y++] = l & 255), f[y++] = Ts, f[y++] = s, i < 0 ? (f[y++] = 0, y += t.copy(f, y, 0, r)) : y += t.copy(f, y, i, r), f[y++] = Ts, f[y++] = o, a < 0 ? (f[y++] = 0, t.copy(f, y, r)) : t.copy(f, y, r + a), f;
}
var nf = {
  derToJose: S_,
  joseToDer: I_
}, qr = {}, Er = {}, Tr = pe && pe.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, Ai, Zr, Sl, Il;
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.LRUCache = void 0;
Er.snakeToCamel = kg;
Er.originalOrCamelOptions = b_;
function kg(t) {
  return t.replace(/([_][^_])/g, (e) => e.slice(1).toUpperCase());
}
function b_(t) {
  function e(r) {
    var n;
    const i = t || {};
    return (n = i[r]) !== null && n !== void 0 ? n : i[kg(r)];
  }
  return { get: e };
}
let w_ = class {
  constructor(e) {
    Ai.add(this), Zr.set(this, /* @__PURE__ */ new Map()), this.capacity = e.capacity, this.maxAge = e.maxAge;
  }
  /**
   * Add an item to the cache.
   *
   * @param key the key to upsert
   * @param value the value of the key
   */
  set(e, r) {
    Tr(this, Ai, "m", Sl).call(this, e, r), Tr(this, Ai, "m", Il).call(this);
  }
  /**
   * Get an item from the cache.
   *
   * @param key the key to retrieve
   */
  get(e) {
    const r = Tr(this, Zr, "f").get(e);
    if (r)
      return Tr(this, Ai, "m", Sl).call(this, e, r.value), Tr(this, Ai, "m", Il).call(this), r.value;
  }
};
Er.LRUCache = w_;
Zr = /* @__PURE__ */ new WeakMap(), Ai = /* @__PURE__ */ new WeakSet(), Sl = function(e, r) {
  Tr(this, Zr, "f").delete(e), Tr(this, Zr, "f").set(e, {
    value: r,
    lastAccessed: Date.now()
  });
}, Il = function() {
  const e = this.maxAge ? Date.now() - this.maxAge : 0;
  let r = Tr(this, Zr, "f").entries().next();
  for (; !r.done && (Tr(this, Zr, "f").size > this.capacity || // too many
  r.value[1].lastAccessed < e); )
    Tr(this, Zr, "f").delete(r.value[0]), r = Tr(this, Zr, "f").entries().next();
};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AuthClient = t.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = t.DEFAULT_UNIVERSE = void 0;
  const e = ge, r = Lr, n = ei, i = Er;
  t.DEFAULT_UNIVERSE = "googleapis.com", t.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
  class a extends e.EventEmitter {
    constructor(o = {}) {
      var l, u, f, y, m;
      super(), this.credentials = {}, this.eagerRefreshThresholdMillis = t.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS, this.forceRefreshOnFailure = !1, this.universeDomain = t.DEFAULT_UNIVERSE;
      const p = (0, i.originalOrCamelOptions)(o);
      this.apiKey = o.apiKey, this.projectId = (l = p.get("project_id")) !== null && l !== void 0 ? l : null, this.quotaProjectId = p.get("quota_project_id"), this.credentials = (u = p.get("credentials")) !== null && u !== void 0 ? u : {}, this.universeDomain = (f = p.get("universe_domain")) !== null && f !== void 0 ? f : t.DEFAULT_UNIVERSE, this.transporter = (y = o.transporter) !== null && y !== void 0 ? y : new n.DefaultTransporter(), o.transporterOptions && (this.transporter.defaults = o.transporterOptions), o.eagerRefreshThresholdMillis && (this.eagerRefreshThresholdMillis = o.eagerRefreshThresholdMillis), this.forceRefreshOnFailure = (m = o.forceRefreshOnFailure) !== null && m !== void 0 ? m : !1;
    }
    /**
     * Return the {@link Gaxios `Gaxios`} instance from the {@link AuthClient.transporter}.
     *
     * @expiremental
     */
    get gaxios() {
      return this.transporter instanceof r.Gaxios ? this.transporter : this.transporter instanceof n.DefaultTransporter ? this.transporter.instance : "instance" in this.transporter && this.transporter.instance instanceof r.Gaxios ? this.transporter.instance : null;
    }
    /**
     * Sets the auth credentials.
     */
    setCredentials(o) {
      this.credentials = o;
    }
    /**
     * Append additional headers, e.g., x-goog-user-project, shared across the
     * classes inheriting AuthClient. This method should be used by any method
     * that overrides getRequestMetadataAsync(), which is a shared helper for
     * setting request information in both gRPC and HTTP API calls.
     *
     * @param headers object to append additional headers to.
     */
    addSharedMetadataHeaders(o) {
      return !o["x-goog-user-project"] && // don't override a value the user sets.
      this.quotaProjectId && (o["x-goog-user-project"] = this.quotaProjectId), o;
    }
    /**
     * Retry config for Auth-related requests.
     *
     * @remarks
     *
     * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
     * config as some downstream APIs would prefer if customers explicitly enable retries,
     * such as GCS.
     */
    static get RETRY_CONFIG() {
      return {
        retry: !0,
        retryConfig: {
          httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
        }
      };
    }
  }
  t.AuthClient = a;
})(qr);
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.LoginTicket = void 0;
class T_ {
  /**
   * Create a simple class to extract user ID from an ID Token
   *
   * @param {string} env Envelope of the jwt
   * @param {TokenPayload} pay Payload of the jwt
   * @constructor
   */
  constructor(e, r) {
    this.envelope = e, this.payload = r;
  }
  getEnvelope() {
    return this.envelope;
  }
  getPayload() {
    return this.payload;
  }
  /**
   * Create a simple class to extract user ID from an ID Token
   *
   * @return The user ID
   */
  getUserId() {
    const e = this.getPayload();
    return e && e.sub ? e.sub : null;
  }
  /**
   * Returns attributes from the login ticket.  This can contain
   * various information about the user session.
   *
   * @return The envelope and payload
   */
  getAttributes() {
    return { envelope: this.getEnvelope(), payload: this.getPayload() };
  }
}
Ca.LoginTicket = T_;
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.OAuth2Client = qt.ClientAuthentication = qt.CertificateFormat = qt.CodeChallengeMethod = void 0;
const R_ = Lr, kc = ge, N_ = ge, x_ = nf, Bc = va(), O_ = qr, D_ = Ca;
var uh;
(function(t) {
  t.Plain = "plain", t.S256 = "S256";
})(uh || (qt.CodeChallengeMethod = uh = {}));
var en;
(function(t) {
  t.PEM = "PEM", t.JWK = "JWK";
})(en || (qt.CertificateFormat = en = {}));
var sa;
(function(t) {
  t.ClientSecretPost = "ClientSecretPost", t.ClientSecretBasic = "ClientSecretBasic", t.None = "None";
})(sa || (qt.ClientAuthentication = sa = {}));
class Gt extends O_.AuthClient {
  constructor(e, r, n) {
    const i = e && typeof e == "object" ? e : { clientId: e, clientSecret: r, redirectUri: n };
    super(i), this.certificateCache = {}, this.certificateExpiry = null, this.certificateCacheFormat = en.PEM, this.refreshTokenPromises = /* @__PURE__ */ new Map(), this._clientId = i.clientId, this._clientSecret = i.clientSecret, this.redirectUri = i.redirectUri, this.endpoints = {
      tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
      oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
      oauth2TokenUrl: "https://oauth2.googleapis.com/token",
      oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
      oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
      oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
      oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
      ...i.endpoints
    }, this.clientAuthentication = i.clientAuthentication || sa.ClientSecretPost, this.issuers = i.issuers || [
      "accounts.google.com",
      "https://accounts.google.com",
      this.universeDomain
    ];
  }
  /**
   * Generates URL for consent page landing.
   * @param opts Options.
   * @return URL to consent page.
   */
  generateAuthUrl(e = {}) {
    if (e.code_challenge_method && !e.code_challenge)
      throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
    return e.response_type = e.response_type || "code", e.client_id = e.client_id || this._clientId, e.redirect_uri = e.redirect_uri || this.redirectUri, Array.isArray(e.scope) && (e.scope = e.scope.join(" ")), this.endpoints.oauth2AuthBaseUrl.toString() + "?" + kc.stringify(e);
  }
  generateCodeVerifier() {
    throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
  }
  /**
   * Convenience method to automatically generate a code_verifier, and its
   * resulting SHA256. If used, this must be paired with a S256
   * code_challenge_method.
   *
   * For a full example see:
   * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
   */
  async generateCodeVerifierAsync() {
    const e = (0, Bc.createCrypto)(), n = e.randomBytesBase64(96).replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-"), a = (await e.sha256DigestBase64(n)).split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
    return { codeVerifier: n, codeChallenge: a };
  }
  getToken(e, r) {
    const n = typeof e == "string" ? { code: e } : e;
    if (r)
      this.getTokenAsync(n).then((i) => r(null, i.tokens, i.res), (i) => r(i, null, i.response));
    else
      return this.getTokenAsync(n);
  }
  async getTokenAsync(e) {
    const r = this.endpoints.oauth2TokenUrl.toString(), n = {
      "Content-Type": "application/x-www-form-urlencoded"
    }, i = {
      client_id: e.client_id || this._clientId,
      code_verifier: e.codeVerifier,
      code: e.code,
      grant_type: "authorization_code",
      redirect_uri: e.redirect_uri || this.redirectUri
    };
    if (this.clientAuthentication === sa.ClientSecretBasic) {
      const o = Buffer.from(`${this._clientId}:${this._clientSecret}`);
      n.Authorization = `Basic ${o.toString("base64")}`;
    }
    this.clientAuthentication === sa.ClientSecretPost && (i.client_secret = this._clientSecret);
    const a = await this.transporter.request({
      ...Gt.RETRY_CONFIG,
      method: "POST",
      url: r,
      data: kc.stringify(i),
      headers: n
    }), s = a.data;
    return a.data && a.data.expires_in && (s.expiry_date = (/* @__PURE__ */ new Date()).getTime() + a.data.expires_in * 1e3, delete s.expires_in), this.emit("tokens", s), { tokens: s, res: a };
  }
  /**
   * Refreshes the access token.
   * @param refresh_token Existing refresh token.
   * @private
   */
  async refreshToken(e) {
    if (!e)
      return this.refreshTokenNoCache(e);
    if (this.refreshTokenPromises.has(e))
      return this.refreshTokenPromises.get(e);
    const r = this.refreshTokenNoCache(e).then((n) => (this.refreshTokenPromises.delete(e), n), (n) => {
      throw this.refreshTokenPromises.delete(e), n;
    });
    return this.refreshTokenPromises.set(e, r), r;
  }
  async refreshTokenNoCache(e) {
    var r;
    if (!e)
      throw new Error("No refresh token is set.");
    const n = this.endpoints.oauth2TokenUrl.toString(), i = {
      refresh_token: e,
      client_id: this._clientId,
      client_secret: this._clientSecret,
      grant_type: "refresh_token"
    };
    let a;
    try {
      a = await this.transporter.request({
        ...Gt.RETRY_CONFIG,
        method: "POST",
        url: n,
        data: kc.stringify(i),
        headers: { "Content-Type": "application/x-www-form-urlencoded" }
      });
    } catch (o) {
      throw o instanceof R_.GaxiosError && o.message === "invalid_grant" && (!((r = o.response) === null || r === void 0) && r.data) && /ReAuth/i.test(o.response.data.error_description) && (o.message = JSON.stringify(o.response.data)), o;
    }
    const s = a.data;
    return a.data && a.data.expires_in && (s.expiry_date = (/* @__PURE__ */ new Date()).getTime() + a.data.expires_in * 1e3, delete s.expires_in), this.emit("tokens", s), { tokens: s, res: a };
  }
  refreshAccessToken(e) {
    if (e)
      this.refreshAccessTokenAsync().then((r) => e(null, r.credentials, r.res), e);
    else
      return this.refreshAccessTokenAsync();
  }
  async refreshAccessTokenAsync() {
    const e = await this.refreshToken(this.credentials.refresh_token), r = e.tokens;
    return r.refresh_token = this.credentials.refresh_token, this.credentials = r, { credentials: this.credentials, res: e.res };
  }
  getAccessToken(e) {
    if (e)
      this.getAccessTokenAsync().then((r) => e(null, r.token, r.res), e);
    else
      return this.getAccessTokenAsync();
  }
  async getAccessTokenAsync() {
    if (!this.credentials.access_token || this.isTokenExpiring()) {
      if (!this.credentials.refresh_token)
        if (this.refreshHandler) {
          const n = await this.processAndValidateRefreshHandler();
          if (n != null && n.access_token)
            return this.setCredentials(n), { token: this.credentials.access_token };
        } else
          throw new Error("No refresh token or refresh handler callback is set.");
      const r = await this.refreshAccessTokenAsync();
      if (!r.credentials || r.credentials && !r.credentials.access_token)
        throw new Error("Could not refresh access token.");
      return { token: r.credentials.access_token, res: r.res };
    } else
      return { token: this.credentials.access_token };
  }
  /**
   * The main authentication interface.  It takes an optional url which when
   * present is the endpoint being accessed, and returns a Promise which
   * resolves with authorization header fields.
   *
   * In OAuth2Client, the result has the form:
   * { Authorization: 'Bearer <access_token_value>' }
   * @param url The optional url being authorized
   */
  async getRequestHeaders(e) {
    return (await this.getRequestMetadataAsync(e)).headers;
  }
  async getRequestMetadataAsync(e) {
    const r = this.credentials;
    if (!r.access_token && !r.refresh_token && !this.apiKey && !this.refreshHandler)
      throw new Error("No access, refresh token, API key or refresh handler callback is set.");
    if (r.access_token && !this.isTokenExpiring()) {
      r.token_type = r.token_type || "Bearer";
      const o = {
        Authorization: r.token_type + " " + r.access_token
      };
      return { headers: this.addSharedMetadataHeaders(o) };
    }
    if (this.refreshHandler) {
      const o = await this.processAndValidateRefreshHandler();
      if (o != null && o.access_token) {
        this.setCredentials(o);
        const l = {
          Authorization: "Bearer " + this.credentials.access_token
        };
        return { headers: this.addSharedMetadataHeaders(l) };
      }
    }
    if (this.apiKey)
      return { headers: { "X-Goog-Api-Key": this.apiKey } };
    let n = null, i = null;
    try {
      n = await this.refreshToken(r.refresh_token), i = n.tokens;
    } catch (o) {
      const l = o;
      throw l.response && (l.response.status === 403 || l.response.status === 404) && (l.message = `Could not refresh access token: ${l.message}`), l;
    }
    const a = this.credentials;
    a.token_type = a.token_type || "Bearer", i.refresh_token = a.refresh_token, this.credentials = i;
    const s = {
      Authorization: a.token_type + " " + i.access_token
    };
    return { headers: this.addSharedMetadataHeaders(s), res: n.res };
  }
  /**
   * Generates an URL to revoke the given token.
   * @param token The existing token to be revoked.
   *
   * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
   */
  static getRevokeTokenUrl(e) {
    return new Gt().getRevokeTokenURL(e).toString();
  }
  /**
   * Generates a URL to revoke the given token.
   *
   * @param token The existing token to be revoked.
   */
  getRevokeTokenURL(e) {
    const r = new URL(this.endpoints.oauth2RevokeUrl);
    return r.searchParams.append("token", e), r;
  }
  revokeToken(e, r) {
    const n = {
      ...Gt.RETRY_CONFIG,
      url: this.getRevokeTokenURL(e).toString(),
      method: "POST"
    };
    if (r)
      this.transporter.request(n).then((i) => r(null, i), r);
    else
      return this.transporter.request(n);
  }
  revokeCredentials(e) {
    if (e)
      this.revokeCredentialsAsync().then((r) => e(null, r), e);
    else
      return this.revokeCredentialsAsync();
  }
  async revokeCredentialsAsync() {
    const e = this.credentials.access_token;
    if (this.credentials = {}, e)
      return this.revokeToken(e);
    throw new Error("No access token to revoke.");
  }
  request(e, r) {
    if (r)
      this.requestAsync(e).then((n) => r(null, n), (n) => r(n, n.response));
    else
      return this.requestAsync(e);
  }
  async requestAsync(e, r = !1) {
    let n;
    try {
      const i = await this.getRequestMetadataAsync(e.url);
      e.headers = e.headers || {}, i.headers && i.headers["x-goog-user-project"] && (e.headers["x-goog-user-project"] = i.headers["x-goog-user-project"]), i.headers && i.headers.Authorization && (e.headers.Authorization = i.headers.Authorization), this.apiKey && (e.headers["X-Goog-Api-Key"] = this.apiKey), n = await this.transporter.request(e);
    } catch (i) {
      const a = i.response;
      if (a) {
        const s = a.status, o = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure), l = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler, u = a.config.data instanceof N_.Readable, f = s === 401 || s === 403;
        if (!r && f && !u && o)
          return await this.refreshAccessTokenAsync(), this.requestAsync(e, !0);
        if (!r && f && !u && l) {
          const y = await this.processAndValidateRefreshHandler();
          return y != null && y.access_token && this.setCredentials(y), this.requestAsync(e, !0);
        }
      }
      throw i;
    }
    return n;
  }
  verifyIdToken(e, r) {
    if (r && typeof r != "function")
      throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
    if (r)
      this.verifyIdTokenAsync(e).then((n) => r(null, n), r);
    else
      return this.verifyIdTokenAsync(e);
  }
  async verifyIdTokenAsync(e) {
    if (!e.idToken)
      throw new Error("The verifyIdToken method requires an ID Token");
    const r = await this.getFederatedSignonCertsAsync();
    return await this.verifySignedJwtWithCertsAsync(e.idToken, r.certs, e.audience, this.issuers, e.maxExpiry);
  }
  /**
   * Obtains information about the provisioned access token.  Especially useful
   * if you want to check the scopes that were provisioned to a given token.
   *
   * @param accessToken Required.  The Access Token for which you want to get
   * user info.
   */
  async getTokenInfo(e) {
    const { data: r } = await this.transporter.request({
      ...Gt.RETRY_CONFIG,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `Bearer ${e}`
      },
      url: this.endpoints.tokenInfoUrl.toString()
    }), n = Object.assign({
      expiry_date: (/* @__PURE__ */ new Date()).getTime() + r.expires_in * 1e3,
      scopes: r.scope.split(" ")
    }, r);
    return delete n.expires_in, delete n.scope, n;
  }
  getFederatedSignonCerts(e) {
    if (e)
      this.getFederatedSignonCertsAsync().then((r) => e(null, r.certs, r.res), e);
    else
      return this.getFederatedSignonCertsAsync();
  }
  async getFederatedSignonCertsAsync() {
    const e = (/* @__PURE__ */ new Date()).getTime(), r = (0, Bc.hasBrowserCrypto)() ? en.JWK : en.PEM;
    if (this.certificateExpiry && e < this.certificateExpiry.getTime() && this.certificateCacheFormat === r)
      return { certs: this.certificateCache, format: r };
    let n, i;
    switch (r) {
      case en.PEM:
        i = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
        break;
      case en.JWK:
        i = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
        break;
      default:
        throw new Error(`Unsupported certificate format ${r}`);
    }
    try {
      n = await this.transporter.request({
        ...Gt.RETRY_CONFIG,
        url: i
      });
    } catch (u) {
      throw u instanceof Error && (u.message = `Failed to retrieve verification certificates: ${u.message}`), u;
    }
    const a = n ? n.headers["cache-control"] : void 0;
    let s = -1;
    if (a) {
      const f = new RegExp("max-age=([0-9]*)").exec(a);
      f && f.length === 2 && (s = Number(f[1]) * 1e3);
    }
    let o = {};
    switch (r) {
      case en.PEM:
        o = n.data;
        break;
      case en.JWK:
        for (const u of n.data.keys)
          o[u.kid] = u;
        break;
      default:
        throw new Error(`Unsupported certificate format ${r}`);
    }
    const l = /* @__PURE__ */ new Date();
    return this.certificateExpiry = s === -1 ? null : new Date(l.getTime() + s), this.certificateCache = o, this.certificateCacheFormat = r, { certs: o, format: r, res: n };
  }
  getIapPublicKeys(e) {
    if (e)
      this.getIapPublicKeysAsync().then((r) => e(null, r.pubkeys, r.res), e);
    else
      return this.getIapPublicKeysAsync();
  }
  async getIapPublicKeysAsync() {
    let e;
    const r = this.endpoints.oauth2IapPublicKeyUrl.toString();
    try {
      e = await this.transporter.request({
        ...Gt.RETRY_CONFIG,
        url: r
      });
    } catch (n) {
      throw n instanceof Error && (n.message = `Failed to retrieve verification certificates: ${n.message}`), n;
    }
    return { pubkeys: e.data, res: e };
  }
  verifySignedJwtWithCerts() {
    throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
  }
  /**
   * Verify the id token is signed with the correct certificate
   * and is from the correct audience.
   * @param jwt The jwt to verify (The ID Token in this case).
   * @param certs The array of certs to test the jwt against.
   * @param requiredAudience The audience to test the jwt against.
   * @param issuers The allowed issuers of the jwt (Optional).
   * @param maxExpiry The max expiry the certificate can be (Optional).
   * @return Returns a promise resolving to LoginTicket on verification.
   */
  async verifySignedJwtWithCertsAsync(e, r, n, i, a) {
    const s = (0, Bc.createCrypto)();
    a || (a = Gt.DEFAULT_MAX_TOKEN_LIFETIME_SECS_);
    const o = e.split(".");
    if (o.length !== 3)
      throw new Error("Wrong number of segments in token: " + e);
    const l = o[0] + "." + o[1];
    let u = o[2], f, y;
    try {
      f = JSON.parse(s.decodeBase64StringUtf8(o[0]));
    } catch (v) {
      throw v instanceof Error && (v.message = `Can't parse token envelope: ${o[0]}': ${v.message}`), v;
    }
    if (!f)
      throw new Error("Can't parse token envelope: " + o[0]);
    try {
      y = JSON.parse(s.decodeBase64StringUtf8(o[1]));
    } catch (v) {
      throw v instanceof Error && (v.message = `Can't parse token payload '${o[0]}`), v;
    }
    if (!y)
      throw new Error("Can't parse token payload: " + o[1]);
    if (!Object.prototype.hasOwnProperty.call(r, f.kid))
      throw new Error("No pem found for envelope: " + JSON.stringify(f));
    const m = r[f.kid];
    if (f.alg === "ES256" && (u = x_.joseToDer(u, "ES256").toString("base64")), !await s.verify(m, l, u))
      throw new Error("Invalid token signature: " + e);
    if (!y.iat)
      throw new Error("No issue time in token: " + JSON.stringify(y));
    if (!y.exp)
      throw new Error("No expiration time in token: " + JSON.stringify(y));
    const S = Number(y.iat);
    if (isNaN(S))
      throw new Error("iat field using invalid format");
    const A = Number(y.exp);
    if (isNaN(A))
      throw new Error("exp field using invalid format");
    const I = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    if (A >= I + a)
      throw new Error("Expiration time too far in future: " + JSON.stringify(y));
    const c = S - Gt.CLOCK_SKEW_SECS_, E = A + Gt.CLOCK_SKEW_SECS_;
    if (I < c)
      throw new Error("Token used too early, " + I + " < " + c + ": " + JSON.stringify(y));
    if (I > E)
      throw new Error("Token used too late, " + I + " > " + E + ": " + JSON.stringify(y));
    if (i && i.indexOf(y.iss) < 0)
      throw new Error("Invalid issuer, expected one of [" + i + "], but got " + y.iss);
    if (typeof n < "u" && n !== null) {
      const v = y.aud;
      let R = !1;
      if (n.constructor === Array ? R = n.indexOf(v) > -1 : R = v === n, !R)
        throw new Error("Wrong recipient, payload audience != requiredAudience");
    }
    return new D_.LoginTicket(f, y);
  }
  /**
   * Returns a promise that resolves with AccessTokenResponse type if
   * refreshHandler is defined.
   * If not, nothing is returned.
   */
  async processAndValidateRefreshHandler() {
    if (this.refreshHandler) {
      const e = await this.refreshHandler();
      if (!e.access_token)
        throw new Error("No access token is returned by the refreshHandler callback.");
      return e;
    }
  }
  /**
   * Returns true if a token is expired or will expire within
   * eagerRefreshThresholdMillismilliseconds.
   * If there is no expiry time, assumes the token is not expired or expiring.
   */
  isTokenExpiring() {
    const e = this.credentials.expiry_date;
    return e ? e <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : !1;
  }
}
qt.OAuth2Client = Gt;
Gt.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
Gt.CLOCK_SKEW_SECS_ = 300;
Gt.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.Compute = void 0;
const L_ = Lr, lh = ya, P_ = qt;
class k_ extends P_.OAuth2Client {
  /**
   * Google Compute Engine service account credentials.
   *
   * Retrieve access token from the metadata server.
   * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
   */
  constructor(e = {}) {
    super(e), this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" }, this.serviceAccountEmail = e.serviceAccountEmail || "default", this.scopes = Array.isArray(e.scopes) ? e.scopes : e.scopes ? [e.scopes] : [];
  }
  /**
   * Refreshes the access token.
   * @param refreshToken Unused parameter
   */
  async refreshTokenNoCache(e) {
    const r = `service-accounts/${this.serviceAccountEmail}/token`;
    let n;
    try {
      const a = {
        property: r
      };
      this.scopes.length > 0 && (a.params = {
        scopes: this.scopes.join(",")
      }), n = await lh.instance(a);
    } catch (a) {
      throw a instanceof L_.GaxiosError && (a.message = `Could not refresh access token: ${a.message}`, this.wrapError(a)), a;
    }
    const i = n;
    return n && n.expires_in && (i.expiry_date = (/* @__PURE__ */ new Date()).getTime() + n.expires_in * 1e3, delete i.expires_in), this.emit("tokens", i), { tokens: i, res: null };
  }
  /**
   * Fetches an ID token.
   * @param targetAudience the audience for the fetched ID token.
   */
  async fetchIdToken(e) {
    const r = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${e}`;
    let n;
    try {
      const i = {
        property: r
      };
      n = await lh.instance(i);
    } catch (i) {
      throw i instanceof Error && (i.message = `Could not fetch ID token: ${i.message}`), i;
    }
    return n;
  }
  wrapError(e) {
    const r = e.response;
    r && r.status && (e.status = r.status, r.status === 403 ? e.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e.message : r.status === 404 && (e.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e.message));
  }
}
Aa.Compute = k_;
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.IdTokenClient = void 0;
const B_ = qt;
class U_ extends B_.OAuth2Client {
  /**
   * Google ID Token client
   *
   * Retrieve ID token from the metadata server.
   * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
   */
  constructor(e) {
    super(e), this.targetAudience = e.targetAudience, this.idTokenProvider = e.idTokenProvider;
  }
  async getRequestMetadataAsync(e) {
    if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
      const n = await this.idTokenProvider.fetchIdToken(this.targetAudience);
      this.credentials = {
        id_token: n,
        expiry_date: this.getIdTokenExpiryDate(n)
      };
    }
    return { headers: {
      Authorization: "Bearer " + this.credentials.id_token
    } };
  }
  getIdTokenExpiryDate(e) {
    const r = e.split(".")[1];
    if (r)
      return JSON.parse(Buffer.from(r, "base64").toString("ascii")).exp * 1e3;
  }
}
_a.IdTokenClient = U_;
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.GCPEnv = void 0;
ti.clear = F_;
ti.getEnv = M_;
const Bg = ya;
var tn;
(function(t) {
  t.APP_ENGINE = "APP_ENGINE", t.KUBERNETES_ENGINE = "KUBERNETES_ENGINE", t.CLOUD_FUNCTIONS = "CLOUD_FUNCTIONS", t.COMPUTE_ENGINE = "COMPUTE_ENGINE", t.CLOUD_RUN = "CLOUD_RUN", t.NONE = "NONE";
})(tn || (ti.GCPEnv = tn = {}));
let ra;
function F_() {
  ra = void 0;
}
async function M_() {
  return ra || (ra = V_(), ra);
}
async function V_() {
  let t = tn.NONE;
  return $_() ? t = tn.APP_ENGINE : H_() ? t = tn.CLOUD_FUNCTIONS : await j_() ? await G_() ? t = tn.KUBERNETES_ENGINE : K_() ? t = tn.CLOUD_RUN : t = tn.COMPUTE_ENGINE : t = tn.NONE, t;
}
function $_() {
  return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
}
function H_() {
  return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
}
function K_() {
  return !!process.env.K_CONFIGURATION;
}
async function G_() {
  try {
    return await Bg.instance("attributes/cluster-name"), !0;
  } catch {
    return !1;
  }
}
async function j_() {
  return Bg.isAvailable();
}
var Sa = {}, Io = {}, fn = {}, Rs = ln.Buffer, q_ = ge, W_ = ge;
function bo(t) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !t)
    return this.buffer = Rs.alloc(0), this;
  if (typeof t.pipe == "function")
    return this.buffer = Rs.alloc(0), t.pipe(this), this;
  if (t.length || typeof t == "object")
    return this.buffer = t, this.writable = !1, process.nextTick((function() {
      this.emit("end", t), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof t + ")");
}
W_.inherits(bo, q_);
bo.prototype.write = function(e) {
  this.buffer = Rs.concat([this.buffer, Rs.from(e)]), this.emit("data", e);
};
bo.prototype.end = function(e) {
  e && this.write(e), this.emit("end", e), this.emit("close"), this.writable = !1, this.readable = !1;
};
var Ug = bo, Uc, fh;
function Fg() {
  if (fh) return Uc;
  fh = 1;
  var t = ge.Buffer, e = ge.SlowBuffer;
  Uc = r;
  function r(a, s) {
    if (!t.isBuffer(a) || !t.isBuffer(s) || a.length !== s.length)
      return !1;
    for (var o = 0, l = 0; l < a.length; l++)
      o |= a[l] ^ s[l];
    return o === 0;
  }
  r.install = function() {
    t.prototype.equal = e.prototype.equal = function(s) {
      return r(this, s);
    };
  };
  var n = t.prototype.equal, i = e.prototype.equal;
  return r.restore = function() {
    t.prototype.equal = n, e.prototype.equal = i;
  }, Uc;
}
var Ri = ln.Buffer, pr = ge, Mg = nf, dh = ge, J_ = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, na = "secret must be a string or buffer", Ci = "key must be a string or a buffer", z_ = "key must be a string, a buffer or an object", af = typeof pr.createPublicKey == "function";
af && (Ci += " or a KeyObject", na += "or a KeyObject");
function Vg(t) {
  if (!Ri.isBuffer(t) && typeof t != "string" && (!af || typeof t != "object" || typeof t.type != "string" || typeof t.asymmetricKeyType != "string" || typeof t.export != "function"))
    throw xr(Ci);
}
function $g(t) {
  if (!Ri.isBuffer(t) && typeof t != "string" && typeof t != "object")
    throw xr(z_);
}
function X_(t) {
  if (!Ri.isBuffer(t)) {
    if (typeof t == "string")
      return t;
    if (!af || typeof t != "object" || t.type !== "secret" || typeof t.export != "function")
      throw xr(na);
  }
}
function sf(t) {
  return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function Hg(t) {
  t = t.toString();
  var e = 4 - t.length % 4;
  if (e !== 4)
    for (var r = 0; r < e; ++r)
      t += "=";
  return t.replace(/\-/g, "+").replace(/_/g, "/");
}
function xr(t) {
  var e = [].slice.call(arguments, 1), r = dh.format.bind(dh, t).apply(null, e);
  return new TypeError(r);
}
function Y_(t) {
  return Ri.isBuffer(t) || typeof t == "string";
}
function Ia(t) {
  return Y_(t) || (t = JSON.stringify(t)), t;
}
function Kg(t) {
  return function(r, n) {
    X_(n), r = Ia(r);
    var i = pr.createHmac("sha" + t, n), a = (i.update(r), i.digest("base64"));
    return sf(a);
  };
}
var Fc, Q_ = "timingSafeEqual" in pr ? function(e, r) {
  return e.byteLength !== r.byteLength ? !1 : pr.timingSafeEqual(e, r);
} : function(e, r) {
  return Fc || (Fc = Fg()), Fc(e, r);
};
function Z_(t) {
  return function(r, n, i) {
    var a = Kg(t)(r, i);
    return Q_(Ri.from(n), Ri.from(a));
  };
}
function Gg(t) {
  return function(r, n) {
    $g(n), r = Ia(r);
    var i = pr.createSign("RSA-SHA" + t), a = (i.update(r), i.sign(n, "base64"));
    return sf(a);
  };
}
function jg(t) {
  return function(r, n, i) {
    Vg(i), r = Ia(r), n = Hg(n);
    var a = pr.createVerify("RSA-SHA" + t);
    return a.update(r), a.verify(i, n, "base64");
  };
}
function eS(t) {
  return function(r, n) {
    $g(n), r = Ia(r);
    var i = pr.createSign("RSA-SHA" + t), a = (i.update(r), i.sign({
      key: n,
      padding: pr.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: pr.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return sf(a);
  };
}
function tS(t) {
  return function(r, n, i) {
    Vg(i), r = Ia(r), n = Hg(n);
    var a = pr.createVerify("RSA-SHA" + t);
    return a.update(r), a.verify({
      key: i,
      padding: pr.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: pr.constants.RSA_PSS_SALTLEN_DIGEST
    }, n, "base64");
  };
}
function rS(t) {
  var e = Gg(t);
  return function() {
    var n = e.apply(null, arguments);
    return n = Mg.derToJose(n, "ES" + t), n;
  };
}
function nS(t) {
  var e = jg(t);
  return function(n, i, a) {
    i = Mg.joseToDer(i, "ES" + t).toString("base64");
    var s = e(n, i, a);
    return s;
  };
}
function iS() {
  return function() {
    return "";
  };
}
function aS() {
  return function(e, r) {
    return r === "";
  };
}
var qg = function(e) {
  var r = {
    hs: Kg,
    rs: Gg,
    ps: eS,
    es: rS,
    none: iS
  }, n = {
    hs: Z_,
    rs: jg,
    ps: tS,
    es: nS,
    none: aS
  }, i = e.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
  if (!i)
    throw xr(J_, e);
  var a = (i[1] || i[3]).toLowerCase(), s = i[2];
  return {
    sign: r[a](s),
    verify: n[a](s)
  };
}, sS = ge.Buffer, Wg = function(e) {
  return typeof e == "string" ? e : typeof e == "number" || sS.isBuffer(e) ? e.toString() : JSON.stringify(e);
}, oS = ln.Buffer, hh = Ug, cS = qg, uS = ge, ph = Wg, of = ge;
function gh(t, e) {
  return oS.from(t, e).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function lS(t, e, r) {
  r = r || "utf8";
  var n = gh(ph(t), "binary"), i = gh(ph(e), r);
  return of.format("%s.%s", n, i);
}
function Jg(t) {
  var e = t.header, r = t.payload, n = t.secret || t.privateKey, i = t.encoding, a = cS(e.alg), s = lS(e, r, i), o = a.sign(s, n);
  return of.format("%s.%s", s, o);
}
function wo(t) {
  var e = t.secret || t.privateKey || t.key, r = new hh(e);
  this.readable = !0, this.header = t.header, this.encoding = t.encoding, this.secret = this.privateKey = this.key = r, this.payload = new hh(t.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
of.inherits(wo, uS);
wo.prototype.sign = function() {
  try {
    var e = Jg({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", e), this.emit("data", e), this.emit("end"), this.readable = !1, e;
  } catch (r) {
    this.readable = !1, this.emit("error", r), this.emit("close");
  }
};
wo.sign = Jg;
var fS = wo, zg = ln.Buffer, yh = Ug, dS = qg, hS = ge, Xg = Wg, pS = ge, gS = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function yS(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function mS(t) {
  if (yS(t))
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}
function Yg(t) {
  var e = t.split(".", 1)[0];
  return mS(zg.from(e, "base64").toString("binary"));
}
function ES(t) {
  return t.split(".", 2).join(".");
}
function Qg(t) {
  return t.split(".")[2];
}
function vS(t, e) {
  e = e || "utf8";
  var r = t.split(".")[1];
  return zg.from(r, "base64").toString(e);
}
function Zg(t) {
  return gS.test(t) && !!Yg(t);
}
function ey(t, e, r) {
  if (!e) {
    var n = new Error("Missing algorithm parameter for jws.verify");
    throw n.code = "MISSING_ALGORITHM", n;
  }
  t = Xg(t);
  var i = Qg(t), a = ES(t), s = dS(e);
  return s.verify(a, i, r);
}
function ty(t, e) {
  if (e = e || {}, t = Xg(t), !Zg(t))
    return null;
  var r = Yg(t);
  if (!r)
    return null;
  var n = vS(t);
  return (r.typ === "JWT" || e.json) && (n = JSON.parse(n, e.encoding)), {
    header: r,
    payload: n,
    signature: Qg(t)
  };
}
function Bi(t) {
  t = t || {};
  var e = t.secret || t.publicKey || t.key, r = new yh(e);
  this.readable = !0, this.algorithm = t.algorithm, this.encoding = t.encoding, this.secret = this.publicKey = this.key = r, this.signature = new yh(t.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
pS.inherits(Bi, hS);
Bi.prototype.verify = function() {
  try {
    var e = ey(this.signature.buffer, this.algorithm, this.key.buffer), r = ty(this.signature.buffer, this.encoding);
    return this.emit("done", e, r), this.emit("data", e), this.emit("end"), this.readable = !1, e;
  } catch (n) {
    this.readable = !1, this.emit("error", n), this.emit("close");
  }
};
Bi.decode = ty;
Bi.isValid = Zg;
Bi.verify = ey;
var AS = Bi, ry = fS, To = AS, CS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
fn.ALGORITHMS = CS;
fn.sign = ry.sign;
fn.verify = To.verify;
fn.decode = To.decode;
fn.isValid = To.isValid;
fn.createSign = function(e) {
  return new ry(e);
};
fn.createVerify = function(e) {
  return new To(e);
};
var Rr = pe && pe.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, mh = pe && pe.__classPrivateFieldSet || function(t, e, r, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r;
}, Nr, _i, bl, Eh, vh, wl, Tl, Ah;
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.GoogleToken = void 0;
const Ch = ge, _S = Lr, SS = fn, IS = ge, bS = ge, _h = Ch.readFile ? (0, bS.promisify)(Ch.readFile) : async () => {
  throw new oa("use key rather than keyFile.", "MISSING_CREDENTIALS");
}, Sh = "https://www.googleapis.com/oauth2/v4/token", wS = "https://accounts.google.com/o/oauth2/revoke?token=";
class oa extends Error {
  constructor(e, r) {
    super(e), this.code = r;
  }
}
class TS {
  get accessToken() {
    return this.rawToken ? this.rawToken.access_token : void 0;
  }
  get idToken() {
    return this.rawToken ? this.rawToken.id_token : void 0;
  }
  get tokenType() {
    return this.rawToken ? this.rawToken.token_type : void 0;
  }
  get refreshToken() {
    return this.rawToken ? this.rawToken.refresh_token : void 0;
  }
  /**
   * Create a GoogleToken.
   *
   * @param options  Configuration object.
   */
  constructor(e) {
    Nr.add(this), this.transporter = {
      request: (r) => (0, _S.request)(r)
    }, _i.set(this, void 0), Rr(this, Nr, "m", Tl).call(this, e);
  }
  /**
   * Returns whether the token has expired.
   *
   * @return true if the token has expired, false otherwise.
   */
  hasExpired() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    return this.rawToken && this.expiresAt ? e >= this.expiresAt : !0;
  }
  /**
   * Returns whether the token will expire within eagerRefreshThresholdMillis
   *
   * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
   */
  isTokenExpiring() {
    var e;
    const r = (/* @__PURE__ */ new Date()).getTime(), n = (e = this.eagerRefreshThresholdMillis) !== null && e !== void 0 ? e : 0;
    return this.rawToken && this.expiresAt ? this.expiresAt <= r + n : !0;
  }
  getToken(e, r = {}) {
    if (typeof e == "object" && (r = e, e = void 0), r = Object.assign({
      forceRefresh: !1
    }, r), e) {
      const n = e;
      Rr(this, Nr, "m", bl).call(this, r).then((i) => n(null, i), e);
      return;
    }
    return Rr(this, Nr, "m", bl).call(this, r);
  }
  /**
   * Given a keyFile, extract the key and client email if available
   * @param keyFile Path to a json, pem, or p12 file that contains the key.
   * @returns an object with privateKey and clientEmail properties
   */
  async getCredentials(e) {
    switch (IS.extname(e)) {
      case ".json": {
        const n = await _h(e, "utf8"), i = JSON.parse(n), a = i.private_key, s = i.client_email;
        if (!a || !s)
          throw new oa("private_key and client_email are required.", "MISSING_CREDENTIALS");
        return { privateKey: a, clientEmail: s };
      }
      case ".der":
      case ".crt":
      case ".pem":
        return { privateKey: await _h(e, "utf8") };
      case ".p12":
      case ".pfx":
        throw new oa("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
      default:
        throw new oa("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
    }
  }
  revokeToken(e) {
    if (e) {
      Rr(this, Nr, "m", wl).call(this).then(() => e(), e);
      return;
    }
    return Rr(this, Nr, "m", wl).call(this);
  }
}
Io.GoogleToken = TS;
_i = /* @__PURE__ */ new WeakMap(), Nr = /* @__PURE__ */ new WeakSet(), bl = async function(e) {
  if (Rr(this, _i, "f") && !e.forceRefresh)
    return Rr(this, _i, "f");
  try {
    return await mh(this, _i, Rr(this, Nr, "m", Eh).call(this, e), "f");
  } finally {
    mh(this, _i, void 0, "f");
  }
}, Eh = async function(e) {
  if (this.isTokenExpiring() === !1 && e.forceRefresh === !1)
    return Promise.resolve(this.rawToken);
  if (!this.key && !this.keyFile)
    throw new Error("No key or keyFile set.");
  if (!this.key && this.keyFile) {
    const r = await this.getCredentials(this.keyFile);
    this.key = r.privateKey, this.iss = r.clientEmail || this.iss, r.clientEmail || Rr(this, Nr, "m", vh).call(this);
  }
  return Rr(this, Nr, "m", Ah).call(this);
}, vh = function() {
  if (!this.iss)
    throw new oa("email is required.", "MISSING_CREDENTIALS");
}, wl = async function() {
  if (!this.accessToken)
    throw new Error("No token to revoke.");
  const e = wS + this.accessToken;
  await this.transporter.request({
    url: e,
    retry: !0
  }), Rr(this, Nr, "m", Tl).call(this, {
    email: this.iss,
    sub: this.sub,
    key: this.key,
    keyFile: this.keyFile,
    scope: this.scope,
    additionalClaims: this.additionalClaims
  });
}, Tl = function(e = {}) {
  this.keyFile = e.keyFile, this.key = e.key, this.rawToken = void 0, this.iss = e.email || e.iss, this.sub = e.sub, this.additionalClaims = e.additionalClaims, typeof e.scope == "object" ? this.scope = e.scope.join(" ") : this.scope = e.scope, this.eagerRefreshThresholdMillis = e.eagerRefreshThresholdMillis, e.transporter && (this.transporter = e.transporter);
}, Ah = /**
 * Request the token from Google.
 */
async function() {
  var e, r;
  const n = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), i = this.additionalClaims || {}, a = Object.assign({
    iss: this.iss,
    scope: this.scope,
    aud: Sh,
    exp: n + 3600,
    iat: n,
    sub: this.sub
  }, i), s = SS.sign({
    header: { alg: "RS256" },
    payload: a,
    secret: this.key
  });
  try {
    const o = await this.transporter.request({
      method: "POST",
      url: Sh,
      data: {
        grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
        assertion: s
      },
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      responseType: "json",
      retryConfig: {
        httpMethodsToRetry: ["POST"]
      }
    });
    return this.rawToken = o.data, this.expiresAt = o.data.expires_in === null || o.data.expires_in === void 0 ? void 0 : (n + o.data.expires_in) * 1e3, this.rawToken;
  } catch (o) {
    this.rawToken = void 0, this.tokenExpires = void 0;
    const l = o.response && (!((e = o.response) === null || e === void 0) && e.data) ? (r = o.response) === null || r === void 0 ? void 0 : r.data : {};
    if (l.error) {
      const u = l.error_description ? `: ${l.error_description}` : "";
      o.message = `${l.error}${u}`;
    }
    throw o;
  }
};
var ba = {};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.JWTAccess = void 0;
const RS = fn, NS = Er, Ih = {
  alg: "RS256",
  typ: "JWT"
};
class cf {
  /**
   * JWTAccess service account credentials.
   *
   * Create a new access token by using the credential to create a new JWT token
   * that's recognized as the access token.
   *
   * @param email the service account email address.
   * @param key the private key that will be used to sign the token.
   * @param keyId the ID of the private key used to sign the token.
   */
  constructor(e, r, n, i) {
    this.cache = new NS.LRUCache({
      capacity: 500,
      maxAge: 60 * 60 * 1e3
    }), this.email = e, this.key = r, this.keyId = n, this.eagerRefreshThresholdMillis = i ?? 5 * 60 * 1e3;
  }
  /**
   * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
   *
   * @param url The URI being authorized.
   * @param scopes The scope or scopes being authorized
   * @returns A string that returns the cached key.
   */
  getCachedKey(e, r) {
    let n = e;
    if (r && Array.isArray(r) && r.length ? n = e ? `${e}_${r.join("_")}` : `${r.join("_")}` : typeof r == "string" && (n = e ? `${e}_${r}` : r), !n)
      throw Error("Scopes or url must be provided");
    return n;
  }
  /**
   * Get a non-expired access token, after refreshing if necessary.
   *
   * @param url The URI being authorized.
   * @param additionalClaims An object with a set of additional claims to
   * include in the payload.
   * @returns An object that includes the authorization header.
   */
  getRequestHeaders(e, r, n) {
    const i = this.getCachedKey(e, n), a = this.cache.get(i), s = Date.now();
    if (a && a.expiration - s > this.eagerRefreshThresholdMillis)
      return a.headers;
    const o = Math.floor(Date.now() / 1e3), l = cf.getExpirationTime(o);
    let u;
    if (Array.isArray(n) && (n = n.join(" ")), n ? u = {
      iss: this.email,
      sub: this.email,
      scope: n,
      exp: l,
      iat: o
    } : u = {
      iss: this.email,
      sub: this.email,
      aud: e,
      exp: l,
      iat: o
    }, r) {
      for (const S in u)
        if (r[S])
          throw new Error(`The '${S}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
    }
    const f = this.keyId ? { ...Ih, kid: this.keyId } : Ih, y = Object.assign(u, r), p = { Authorization: `Bearer ${RS.sign({ header: f, payload: y, secret: this.key })}` };
    return this.cache.set(i, {
      expiration: l * 1e3,
      headers: p
    }), p;
  }
  /**
   * Returns an expiration time for the JWT token.
   *
   * @param iat The issued at time for the JWT.
   * @returns An expiration time for the JWT.
   */
  static getExpirationTime(e) {
    return e + 3600;
  }
  /**
   * Create a JWTAccess credentials instance using the given input options.
   * @param json The input object.
   */
  fromJSON(e) {
    if (!e)
      throw new Error("Must pass in a JSON object containing the service account auth settings.");
    if (!e.client_email)
      throw new Error("The incoming JSON object does not contain a client_email field");
    if (!e.private_key)
      throw new Error("The incoming JSON object does not contain a private_key field");
    this.email = e.client_email, this.key = e.private_key, this.keyId = e.private_key_id, this.projectId = e.project_id;
  }
  fromStream(e, r) {
    if (r)
      this.fromStreamAsync(e).then(() => r(), r);
    else
      return this.fromStreamAsync(e);
  }
  fromStreamAsync(e) {
    return new Promise((r, n) => {
      e || n(new Error("Must pass in a stream containing the service account auth settings."));
      let i = "";
      e.setEncoding("utf8").on("data", (a) => i += a).on("error", n).on("end", () => {
        try {
          const a = JSON.parse(i);
          this.fromJSON(a), r();
        } catch (a) {
          n(a);
        }
      });
    });
  }
}
ba.JWTAccess = cf;
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.JWT = void 0;
const bh = Io, xS = ba, OS = qt, Ya = qr;
class uf extends OS.OAuth2Client {
  constructor(e, r, n, i, a, s) {
    const o = e && typeof e == "object" ? e : { email: e, keyFile: r, key: n, keyId: s, scopes: i, subject: a };
    super(o), this.email = o.email, this.keyFile = o.keyFile, this.key = o.key, this.keyId = o.keyId, this.scopes = o.scopes, this.subject = o.subject, this.additionalClaims = o.additionalClaims, this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
  }
  /**
   * Creates a copy of the credential with the specified scopes.
   * @param scopes List of requested scopes or a single scope.
   * @return The cloned instance.
   */
  createScoped(e) {
    const r = new uf(this);
    return r.scopes = e, r;
  }
  /**
   * Obtains the metadata to be sent with the request.
   *
   * @param url the URI being authorized.
   */
  async getRequestMetadataAsync(e) {
    e = this.defaultServicePath ? `https://${this.defaultServicePath}/` : e;
    const r = !this.hasUserScopes() && e || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== Ya.DEFAULT_UNIVERSE;
    if (this.subject && this.universeDomain !== Ya.DEFAULT_UNIVERSE)
      throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${Ya.DEFAULT_UNIVERSE}`);
    if (!this.apiKey && r)
      if (this.additionalClaims && this.additionalClaims.target_audience) {
        const { tokens: n } = await this.refreshToken();
        return {
          headers: this.addSharedMetadataHeaders({
            Authorization: `Bearer ${n.id_token}`
          })
        };
      } else {
        this.access || (this.access = new xS.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis));
        let n;
        this.hasUserScopes() ? n = this.scopes : e || (n = this.defaultScopes);
        const i = this.useJWTAccessWithScope || this.universeDomain !== Ya.DEFAULT_UNIVERSE, a = await this.access.getRequestHeaders(
          e ?? void 0,
          this.additionalClaims,
          // Scopes take precedent over audience for signing,
          // so we only provide them if `useJWTAccessWithScope` is on or
          // if we are in a non-default universe
          i ? n : void 0
        );
        return { headers: this.addSharedMetadataHeaders(a) };
      }
    else return this.hasAnyScopes() || this.apiKey ? super.getRequestMetadataAsync(e) : { headers: {} };
  }
  /**
   * Fetches an ID token.
   * @param targetAudience the audience for the fetched ID token.
   */
  async fetchIdToken(e) {
    const r = new bh.GoogleToken({
      iss: this.email,
      sub: this.subject,
      scope: this.scopes || this.defaultScopes,
      keyFile: this.keyFile,
      key: this.key,
      additionalClaims: { target_audience: e },
      transporter: this.transporter
    });
    if (await r.getToken({
      forceRefresh: !0
    }), !r.idToken)
      throw new Error("Unknown error: Failed to fetch ID token");
    return r.idToken;
  }
  /**
   * Determine if there are currently scopes available.
   */
  hasUserScopes() {
    return this.scopes ? this.scopes.length > 0 : !1;
  }
  /**
   * Are there any default or user scopes defined.
   */
  hasAnyScopes() {
    return !!(this.scopes && this.scopes.length > 0 || this.defaultScopes && this.defaultScopes.length > 0);
  }
  authorize(e) {
    if (e)
      this.authorizeAsync().then((r) => e(null, r), e);
    else
      return this.authorizeAsync();
  }
  async authorizeAsync() {
    const e = await this.refreshToken();
    if (!e)
      throw new Error("No result returned");
    return this.credentials = e.tokens, this.credentials.refresh_token = "jwt-placeholder", this.key = this.gtoken.key, this.email = this.gtoken.iss, e.tokens;
  }
  /**
   * Refreshes the access token.
   * @param refreshToken ignored
   * @private
   */
  async refreshTokenNoCache(e) {
    const r = this.createGToken(), i = {
      access_token: (await r.getToken({
        forceRefresh: this.isTokenExpiring()
      })).access_token,
      token_type: "Bearer",
      expiry_date: r.expiresAt,
      id_token: r.idToken
    };
    return this.emit("tokens", i), { res: null, tokens: i };
  }
  /**
   * Create a gToken if it doesn't already exist.
   */
  createGToken() {
    return this.gtoken || (this.gtoken = new bh.GoogleToken({
      iss: this.email,
      sub: this.subject,
      scope: this.scopes || this.defaultScopes,
      keyFile: this.keyFile,
      key: this.key,
      additionalClaims: this.additionalClaims,
      transporter: this.transporter
    })), this.gtoken;
  }
  /**
   * Create a JWT credentials instance using the given input options.
   * @param json The input object.
   *
   * @remarks
   *
   * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
   */
  fromJSON(e) {
    if (!e)
      throw new Error("Must pass in a JSON object containing the service account auth settings.");
    if (!e.client_email)
      throw new Error("The incoming JSON object does not contain a client_email field");
    if (!e.private_key)
      throw new Error("The incoming JSON object does not contain a private_key field");
    this.email = e.client_email, this.key = e.private_key, this.keyId = e.private_key_id, this.projectId = e.project_id, this.quotaProjectId = e.quota_project_id, this.universeDomain = e.universe_domain || this.universeDomain;
  }
  fromStream(e, r) {
    if (r)
      this.fromStreamAsync(e).then(() => r(), r);
    else
      return this.fromStreamAsync(e);
  }
  fromStreamAsync(e) {
    return new Promise((r, n) => {
      if (!e)
        throw new Error("Must pass in a stream containing the service account auth settings.");
      let i = "";
      e.setEncoding("utf8").on("error", n).on("data", (a) => i += a).on("end", () => {
        try {
          const a = JSON.parse(i);
          this.fromJSON(a), r();
        } catch (a) {
          n(a);
        }
      });
    });
  }
  /**
   * Creates a JWT credentials instance using an API Key for authentication.
   * @param apiKey The API Key in string form.
   */
  fromAPIKey(e) {
    if (typeof e != "string")
      throw new Error("Must provide an API Key string.");
    this.apiKey = e;
  }
  /**
   * Using the key or keyFile on the JWT client, obtain an object that contains
   * the key and the client email.
   */
  async getCredentials() {
    if (this.key)
      return { private_key: this.key, client_email: this.email };
    if (this.keyFile) {
      const r = await this.createGToken().getCredentials(this.keyFile);
      return { private_key: r.privateKey, client_email: r.clientEmail };
    }
    throw new Error("A key or a keyFile must be provided to getCredentials.");
  }
}
Sa.JWT = uf;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.UserRefreshClient = Gn.USER_REFRESH_ACCOUNT_TYPE = void 0;
const DS = qt, LS = ge;
Gn.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
class Ns extends DS.OAuth2Client {
  constructor(e, r, n, i, a) {
    const s = e && typeof e == "object" ? e : {
      clientId: e,
      clientSecret: r,
      refreshToken: n,
      eagerRefreshThresholdMillis: i,
      forceRefreshOnFailure: a
    };
    super(s), this._refreshToken = s.refreshToken, this.credentials.refresh_token = s.refreshToken;
  }
  /**
   * Refreshes the access token.
   * @param refreshToken An ignored refreshToken..
   * @param callback Optional callback.
   */
  async refreshTokenNoCache(e) {
    return super.refreshTokenNoCache(this._refreshToken);
  }
  async fetchIdToken(e) {
    return (await this.transporter.request({
      ...Ns.RETRY_CONFIG,
      url: this.endpoints.oauth2TokenUrl,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      method: "POST",
      data: (0, LS.stringify)({
        client_id: this._clientId,
        client_secret: this._clientSecret,
        grant_type: "refresh_token",
        refresh_token: this._refreshToken,
        target_audience: e
      })
    })).data.id_token;
  }
  /**
   * Create a UserRefreshClient credentials instance using the given input
   * options.
   * @param json The input object.
   */
  fromJSON(e) {
    if (!e)
      throw new Error("Must pass in a JSON object containing the user refresh token");
    if (e.type !== "authorized_user")
      throw new Error('The incoming JSON object does not have the "authorized_user" type');
    if (!e.client_id)
      throw new Error("The incoming JSON object does not contain a client_id field");
    if (!e.client_secret)
      throw new Error("The incoming JSON object does not contain a client_secret field");
    if (!e.refresh_token)
      throw new Error("The incoming JSON object does not contain a refresh_token field");
    this._clientId = e.client_id, this._clientSecret = e.client_secret, this._refreshToken = e.refresh_token, this.credentials.refresh_token = e.refresh_token, this.quotaProjectId = e.quota_project_id, this.universeDomain = e.universe_domain || this.universeDomain;
  }
  fromStream(e, r) {
    if (r)
      this.fromStreamAsync(e).then(() => r(), r);
    else
      return this.fromStreamAsync(e);
  }
  async fromStreamAsync(e) {
    return new Promise((r, n) => {
      if (!e)
        return n(new Error("Must pass in a stream containing the user refresh token."));
      let i = "";
      e.setEncoding("utf8").on("error", n).on("data", (a) => i += a).on("end", () => {
        try {
          const a = JSON.parse(i);
          return this.fromJSON(a), r();
        } catch (a) {
          return n(a);
        }
      });
    });
  }
  /**
   * Create a UserRefreshClient credentials instance using the given input
   * options.
   * @param json The input object.
   */
  static fromJSON(e) {
    const r = new Ns();
    return r.fromJSON(e), r;
  }
}
Gn.UserRefreshClient = Ns;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.Impersonated = jn.IMPERSONATED_ACCOUNT_TYPE = void 0;
const wh = qt, PS = Lr, kS = Er;
jn.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
class ca extends wh.OAuth2Client {
  /**
   * Impersonated service account credentials.
   *
   * Create a new access token by impersonating another service account.
   *
   * Impersonated Credentials allowing credentials issued to a user or
   * service account to impersonate another. The source project using
   * Impersonated Credentials must enable the "IAMCredentials" API.
   * Also, the target service account must grant the orginating principal
   * the "Service Account Token Creator" IAM role.
   *
   * @param {object} options - The configuration object.
   * @param {object} [options.sourceClient] the source credential used as to
   * acquire the impersonated credentials.
   * @param {string} [options.targetPrincipal] the service account to
   * impersonate.
   * @param {string[]} [options.delegates] the chained list of delegates
   * required to grant the final access_token. If set, the sequence of
   * identities must have "Service Account Token Creator" capability granted to
   * the preceding identity. For example, if set to [serviceAccountB,
   * serviceAccountC], the sourceCredential must have the Token Creator role on
   * serviceAccountB. serviceAccountB must have the Token Creator on
   * serviceAccountC. Finally, C must have Token Creator on target_principal.
   * If left unset, sourceCredential must have that role on targetPrincipal.
   * @param {string[]} [options.targetScopes] scopes to request during the
   * authorization grant.
   * @param {number} [options.lifetime] number of seconds the delegated
   * credential should be valid for up to 3600 seconds by default, or 43,200
   * seconds by extending the token's lifetime, see:
   * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
   * @param {string} [options.endpoint] api endpoint override.
   */
  constructor(e = {}) {
    var r, n, i, a, s, o;
    if (super(e), this.credentials = {
      expiry_date: 1,
      refresh_token: "impersonated-placeholder"
    }, this.sourceClient = (r = e.sourceClient) !== null && r !== void 0 ? r : new wh.OAuth2Client(), this.targetPrincipal = (n = e.targetPrincipal) !== null && n !== void 0 ? n : "", this.delegates = (i = e.delegates) !== null && i !== void 0 ? i : [], this.targetScopes = (a = e.targetScopes) !== null && a !== void 0 ? a : [], this.lifetime = (s = e.lifetime) !== null && s !== void 0 ? s : 3600, !!!(0, kS.originalOrCamelOptions)(e).get("universe_domain"))
      this.universeDomain = this.sourceClient.universeDomain;
    else if (this.sourceClient.universeDomain !== this.universeDomain)
      throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
    this.endpoint = (o = e.endpoint) !== null && o !== void 0 ? o : `https://iamcredentials.${this.universeDomain}`;
  }
  /**
   * Signs some bytes.
   *
   * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
   * @param blobToSign String to sign.
   *
   * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
   */
  async sign(e) {
    await this.sourceClient.getAccessToken();
    const r = `projects/-/serviceAccounts/${this.targetPrincipal}`, n = `${this.endpoint}/v1/${r}:signBlob`, i = {
      delegates: this.delegates,
      payload: Buffer.from(e).toString("base64")
    };
    return (await this.sourceClient.request({
      ...ca.RETRY_CONFIG,
      url: n,
      data: i,
      method: "POST"
    })).data;
  }
  /** The service account email to be impersonated. */
  getTargetPrincipal() {
    return this.targetPrincipal;
  }
  /**
   * Refreshes the access token.
   */
  async refreshToken() {
    var e, r, n, i, a, s;
    try {
      await this.sourceClient.getAccessToken();
      const o = "projects/-/serviceAccounts/" + this.targetPrincipal, l = `${this.endpoint}/v1/${o}:generateAccessToken`, u = {
        delegates: this.delegates,
        scope: this.targetScopes,
        lifetime: this.lifetime + "s"
      }, f = await this.sourceClient.request({
        ...ca.RETRY_CONFIG,
        url: l,
        data: u,
        method: "POST"
      }), y = f.data;
      return this.credentials.access_token = y.accessToken, this.credentials.expiry_date = Date.parse(y.expireTime), {
        tokens: this.credentials,
        res: f
      };
    } catch (o) {
      if (!(o instanceof Error))
        throw o;
      let l = 0, u = "";
      throw o instanceof PS.GaxiosError && (l = (n = (r = (e = o == null ? void 0 : o.response) === null || e === void 0 ? void 0 : e.data) === null || r === void 0 ? void 0 : r.error) === null || n === void 0 ? void 0 : n.status, u = (s = (a = (i = o == null ? void 0 : o.response) === null || i === void 0 ? void 0 : i.data) === null || a === void 0 ? void 0 : a.error) === null || s === void 0 ? void 0 : s.message), l && u ? (o.message = `${l}: unable to impersonate: ${u}`, o) : (o.message = `unable to impersonate: ${o}`, o);
    }
  }
  /**
   * Generates an OpenID Connect ID token for a service account.
   *
   * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
   *
   * @param targetAudience the audience for the fetched ID token.
   * @param options the for the request
   * @return an OpenID Connect ID token
   */
  async fetchIdToken(e, r) {
    var n, i;
    await this.sourceClient.getAccessToken();
    const a = `projects/-/serviceAccounts/${this.targetPrincipal}`, s = `${this.endpoint}/v1/${a}:generateIdToken`, o = {
      delegates: this.delegates,
      audience: e,
      includeEmail: (n = r == null ? void 0 : r.includeEmail) !== null && n !== void 0 ? n : !0,
      useEmailAzp: (i = r == null ? void 0 : r.includeEmail) !== null && i !== void 0 ? i : !0
    };
    return (await this.sourceClient.request({
      ...ca.RETRY_CONFIG,
      url: s,
      data: o,
      method: "POST"
    })).data.token;
  }
}
jn.Impersonated = ca;
var wa = {}, Rn = {}, Ta = {}, Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.OAuthClientAuthHandler = void 0;
Ui.getErrorFromOAuthErrorResponse = MS;
const Th = ge, BS = va(), US = ["PUT", "POST", "PATCH"];
class FS {
  /**
   * Instantiates an OAuth client authentication handler.
   * @param clientAuthentication The client auth credentials.
   */
  constructor(e) {
    this.clientAuthentication = e, this.crypto = (0, BS.createCrypto)();
  }
  /**
   * Applies client authentication on the OAuth request's headers or POST
   * body but does not process the request.
   * @param opts The GaxiosOptions whose headers or data are to be modified
   *   depending on the client authentication mechanism to be used.
   * @param bearerToken The optional bearer token to use for authentication.
   *   When this is used, no client authentication credentials are needed.
   */
  applyClientAuthenticationOptions(e, r) {
    this.injectAuthenticatedHeaders(e, r), r || this.injectAuthenticatedRequestBody(e);
  }
  /**
   * Applies client authentication on the request's header if either
   * basic authentication or bearer token authentication is selected.
   *
   * @param opts The GaxiosOptions whose headers or data are to be modified
   *   depending on the client authentication mechanism to be used.
   * @param bearerToken The optional bearer token to use for authentication.
   *   When this is used, no client authentication credentials are needed.
   */
  injectAuthenticatedHeaders(e, r) {
    var n;
    if (r)
      e.headers = e.headers || {}, Object.assign(e.headers, {
        Authorization: `Bearer ${r}}`
      });
    else if (((n = this.clientAuthentication) === null || n === void 0 ? void 0 : n.confidentialClientType) === "basic") {
      e.headers = e.headers || {};
      const i = this.clientAuthentication.clientId, a = this.clientAuthentication.clientSecret || "", s = this.crypto.encodeBase64StringUtf8(`${i}:${a}`);
      Object.assign(e.headers, {
        Authorization: `Basic ${s}`
      });
    }
  }
  /**
   * Applies client authentication on the request's body if request-body
   * client authentication is selected.
   *
   * @param opts The GaxiosOptions whose headers or data are to be modified
   *   depending on the client authentication mechanism to be used.
   */
  injectAuthenticatedRequestBody(e) {
    var r;
    if (((r = this.clientAuthentication) === null || r === void 0 ? void 0 : r.confidentialClientType) === "request-body") {
      const n = (e.method || "GET").toUpperCase();
      if (US.indexOf(n) !== -1) {
        let i;
        const a = e.headers || {};
        for (const s in a)
          if (s.toLowerCase() === "content-type" && a[s]) {
            i = a[s].toLowerCase();
            break;
          }
        if (i === "application/x-www-form-urlencoded") {
          e.data = e.data || "";
          const s = Th.parse(e.data);
          Object.assign(s, {
            client_id: this.clientAuthentication.clientId,
            client_secret: this.clientAuthentication.clientSecret || ""
          }), e.data = Th.stringify(s);
        } else if (i === "application/json")
          e.data = e.data || {}, Object.assign(e.data, {
            client_id: this.clientAuthentication.clientId,
            client_secret: this.clientAuthentication.clientSecret || ""
          });
        else
          throw new Error(`${i} content-types are not supported with ${this.clientAuthentication.confidentialClientType} client authentication`);
      } else
        throw new Error(`${n} HTTP method does not support ${this.clientAuthentication.confidentialClientType} client authentication`);
    }
  }
  /**
   * Retry config for Auth-related requests.
   *
   * @remarks
   *
   * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
   * config as some downstream APIs would prefer if customers explicitly enable retries,
   * such as GCS.
   */
  static get RETRY_CONFIG() {
    return {
      retry: !0,
      retryConfig: {
        httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
      }
    };
  }
}
Ui.OAuthClientAuthHandler = FS;
function MS(t, e) {
  const r = t.error, n = t.error_description, i = t.error_uri;
  let a = `Error code ${r}`;
  typeof n < "u" && (a += `: ${n}`), typeof i < "u" && (a += ` - ${i}`);
  const s = new Error(a);
  if (e) {
    const o = Object.keys(e);
    e.stack && o.push("stack"), o.forEach((l) => {
      l !== "message" && Object.defineProperty(s, l, {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        value: e[l],
        writable: !1,
        enumerable: !0
      });
    });
  }
  return s;
}
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.StsCredentials = void 0;
const VS = Lr, $S = ge, HS = ei, Rh = Ui;
class lf extends Rh.OAuthClientAuthHandler {
  /**
   * Initializes an STS credentials instance.
   * @param tokenExchangeEndpoint The token exchange endpoint.
   * @param clientAuthentication The client authentication credentials if
   *   available.
   */
  constructor(e, r) {
    super(r), this.tokenExchangeEndpoint = e, this.transporter = new HS.DefaultTransporter();
  }
  /**
   * Exchanges the provided token for another type of token based on the
   * rfc8693 spec.
   * @param stsCredentialsOptions The token exchange options used to populate
   *   the token exchange request.
   * @param additionalHeaders Optional additional headers to pass along the
   *   request.
   * @param options Optional additional GCP-specific non-spec defined options
   *   to send with the request.
   *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
   * @return A promise that resolves with the token exchange response containing
   *   the requested token and its expiration time.
   */
  async exchangeToken(e, r, n) {
    var i, a, s;
    const o = {
      grant_type: e.grantType,
      resource: e.resource,
      audience: e.audience,
      scope: (i = e.scope) === null || i === void 0 ? void 0 : i.join(" "),
      requested_token_type: e.requestedTokenType,
      subject_token: e.subjectToken,
      subject_token_type: e.subjectTokenType,
      actor_token: (a = e.actingParty) === null || a === void 0 ? void 0 : a.actorToken,
      actor_token_type: (s = e.actingParty) === null || s === void 0 ? void 0 : s.actorTokenType,
      // Non-standard GCP-specific options.
      options: n && JSON.stringify(n)
    };
    Object.keys(o).forEach((f) => {
      typeof o[f] > "u" && delete o[f];
    });
    const l = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    Object.assign(l, r || {});
    const u = {
      ...lf.RETRY_CONFIG,
      url: this.tokenExchangeEndpoint.toString(),
      method: "POST",
      headers: l,
      data: $S.stringify(o),
      responseType: "json"
    };
    this.applyClientAuthenticationOptions(u);
    try {
      const f = await this.transporter.request(u), y = f.data;
      return y.res = f, y;
    } catch (f) {
      throw f instanceof VS.GaxiosError && f.response ? (0, Rh.getErrorFromOAuthErrorResponse)(
        f.response.data,
        // Preserve other fields from the original error.
        f
      ) : f;
    }
  }
}
Ta.StsCredentials = lf;
(function(t) {
  var e = pe && pe.__classPrivateFieldGet || function(v, R, N, C) {
    if (N === "a" && !C) throw new TypeError("Private accessor was defined without a getter");
    if (typeof R == "function" ? v !== R || !C : !R.has(v)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return N === "m" ? C : N === "a" ? C.call(v) : C ? C.value : R.get(v);
  }, r = pe && pe.__classPrivateFieldSet || function(v, R, N, C, h) {
    if (C === "m") throw new TypeError("Private method is not writable");
    if (C === "a" && !h) throw new TypeError("Private accessor was defined without a setter");
    if (typeof R == "function" ? v !== R || !h : !R.has(v)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return C === "a" ? h.call(v, N) : h ? h.value = N : R.set(v, N), N;
  }, n, i, a;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseExternalAccountClient = t.DEFAULT_UNIVERSE = t.CLOUD_RESOURCE_MANAGER = t.EXTERNAL_ACCOUNT_TYPE = t.EXPIRATION_TIME_OFFSET = void 0;
  const s = ge, o = qr, l = Ta, u = Er, f = "urn:ietf:params:oauth:grant-type:token-exchange", y = "urn:ietf:params:oauth:token-type:access_token", m = "https://www.googleapis.com/auth/cloud-platform", p = 3600;
  t.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3, t.EXTERNAL_ACCOUNT_TYPE = "external_account", t.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
  const S = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+", A = "https://sts.{universeDomain}/v1/token", I = Ng;
  var c = qr;
  Object.defineProperty(t, "DEFAULT_UNIVERSE", { enumerable: !0, get: function() {
    return c.DEFAULT_UNIVERSE;
  } });
  class E extends o.AuthClient {
    /**
     * Instantiate a BaseExternalAccountClient instance using the provided JSON
     * object loaded from an external account credentials file.
     * @param options The external account options object typically loaded
     *   from the external account JSON credential file. The camelCased options
     *   are aliases for the snake_cased options.
     * @param additionalOptions **DEPRECATED, all options are available in the
     *   `options` parameter.** Optional additional behavior customization options.
     *   These currently customize expiration threshold time and whether to retry
     *   on 401/403 API request errors.
     */
    constructor(R, N) {
      var C;
      super({ ...R, ...N }), n.add(this), i.set(this, null);
      const h = (0, u.originalOrCamelOptions)(R), d = h.get("type");
      if (d && d !== t.EXTERNAL_ACCOUNT_TYPE)
        throw new Error(`Expected "${t.EXTERNAL_ACCOUNT_TYPE}" type but received "${R.type}"`);
      const O = h.get("client_id"), P = h.get("client_secret"), L = (C = h.get("token_url")) !== null && C !== void 0 ? C : A.replace("{universeDomain}", this.universeDomain), D = h.get("subject_token_type"), V = h.get("workforce_pool_user_project"), $ = h.get("service_account_impersonation_url"), K = h.get("service_account_impersonation"), Q = (0, u.originalOrCamelOptions)(K).get("token_lifetime_seconds");
      this.cloudResourceManagerURL = new URL(h.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`), O && (this.clientAuth = {
        confidentialClientType: "basic",
        clientId: O,
        clientSecret: P
      }), this.stsCredential = new l.StsCredentials(L, this.clientAuth), this.scopes = h.get("scopes") || [m], this.cachedAccessToken = null, this.audience = h.get("audience"), this.subjectTokenType = D, this.workforcePoolUserProject = V;
      const ee = new RegExp(S);
      if (this.workforcePoolUserProject && !this.audience.match(ee))
        throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
      this.serviceAccountImpersonationUrl = $, this.serviceAccountImpersonationLifetime = Q, this.serviceAccountImpersonationLifetime ? this.configLifetimeRequested = !0 : (this.configLifetimeRequested = !1, this.serviceAccountImpersonationLifetime = p), this.projectNumber = this.getProjectNumber(this.audience), this.supplierContext = {
        audience: this.audience,
        subjectTokenType: this.subjectTokenType,
        transporter: this.transporter
      };
    }
    /** The service account email to be impersonated, if available. */
    getServiceAccountEmail() {
      var R;
      if (this.serviceAccountImpersonationUrl) {
        if (this.serviceAccountImpersonationUrl.length > 256)
          throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
        const C = /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/.exec(this.serviceAccountImpersonationUrl);
        return ((R = C == null ? void 0 : C.groups) === null || R === void 0 ? void 0 : R.email) || null;
      }
      return null;
    }
    /**
     * Provides a mechanism to inject GCP access tokens directly.
     * When the provided credential expires, a new credential, using the
     * external account options, is retrieved.
     * @param credentials The Credentials object to set on the current client.
     */
    setCredentials(R) {
      super.setCredentials(R), this.cachedAccessToken = R;
    }
    /**
     * @return A promise that resolves with the current GCP access token
     *   response. If the current credential is expired, a new one is retrieved.
     */
    async getAccessToken() {
      return (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) && await this.refreshAccessTokenAsync(), {
        token: this.cachedAccessToken.access_token,
        res: this.cachedAccessToken.res
      };
    }
    /**
     * The main authentication interface. It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * The result has the form:
     * { Authorization: 'Bearer <access_token_value>' }
     */
    async getRequestHeaders() {
      const N = {
        Authorization: `Bearer ${(await this.getAccessToken()).token}`
      };
      return this.addSharedMetadataHeaders(N);
    }
    request(R, N) {
      if (N)
        this.requestAsync(R).then((C) => N(null, C), (C) => N(C, C.response));
      else
        return this.requestAsync(R);
    }
    /**
     * @return A promise that resolves with the project ID corresponding to the
     *   current workload identity pool or current workforce pool if
     *   determinable. For workforce pool credential, it returns the project ID
     *   corresponding to the workforcePoolUserProject.
     *   This is introduced to match the current pattern of using the Auth
     *   library:
     *   const projectId = await auth.getProjectId();
     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
     *   const res = await client.request({ url });
     *   The resource may not have permission
     *   (resourcemanager.projects.get) to call this API or the required
     *   scopes may not be selected:
     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
     */
    async getProjectId() {
      const R = this.projectNumber || this.workforcePoolUserProject;
      if (this.projectId)
        return this.projectId;
      if (R) {
        const N = await this.getRequestHeaders(), C = await this.transporter.request({
          ...E.RETRY_CONFIG,
          headers: N,
          url: `${this.cloudResourceManagerURL.toString()}${R}`,
          responseType: "json"
        });
        return this.projectId = C.data.projectId, this.projectId;
      }
      return null;
    }
    /**
     * Authenticates the provided HTTP request, processes it and resolves with the
     * returned response.
     * @param opts The HTTP request options.
     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
     * @return A promise that resolves with the successful response.
     */
    async requestAsync(R, N = !1) {
      let C;
      try {
        const h = await this.getRequestHeaders();
        R.headers = R.headers || {}, h && h["x-goog-user-project"] && (R.headers["x-goog-user-project"] = h["x-goog-user-project"]), h && h.Authorization && (R.headers.Authorization = h.Authorization), C = await this.transporter.request(R);
      } catch (h) {
        const d = h.response;
        if (d) {
          const O = d.status, P = d.config.data instanceof s.Readable;
          if (!N && (O === 401 || O === 403) && !P && this.forceRefreshOnFailure)
            return await this.refreshAccessTokenAsync(), await this.requestAsync(R, !0);
        }
        throw h;
      }
      return C;
    }
    /**
     * Forces token refresh, even if unexpired tokens are currently cached.
     * External credentials are exchanged for GCP access tokens via the token
     * exchange endpoint and other settings provided in the client options
     * object.
     * If the service_account_impersonation_url is provided, an additional
     * step to exchange the external account GCP access token for a service
     * account impersonated token is performed.
     * @return A promise that resolves with the fresh GCP access tokens.
     */
    async refreshAccessTokenAsync() {
      r(this, i, e(this, i, "f") || e(this, n, "m", a).call(this), "f");
      try {
        return await e(this, i, "f");
      } finally {
        r(this, i, null, "f");
      }
    }
    /**
     * Returns the workload identity pool project number if it is determinable
     * from the audience resource name.
     * @param audience The STS audience used to determine the project number.
     * @return The project number associated with the workload identity pool, if
     *   this can be determined from the STS audience field. Otherwise, null is
     *   returned.
     */
    getProjectNumber(R) {
      const N = R.match(/\/projects\/([^/]+)/);
      return N ? N[1] : null;
    }
    /**
     * Exchanges an external account GCP access token for a service
     * account impersonated access token using iamcredentials
     * GenerateAccessToken API.
     * @param token The access token to exchange for a service account access
     *   token.
     * @return A promise that resolves with the service account impersonated
     *   credentials response.
     */
    async getImpersonatedAccessToken(R) {
      const N = {
        ...E.RETRY_CONFIG,
        url: this.serviceAccountImpersonationUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${R}`
        },
        data: {
          scope: this.getScopesArray(),
          lifetime: this.serviceAccountImpersonationLifetime + "s"
        },
        responseType: "json"
      }, C = await this.transporter.request(N), h = C.data;
      return {
        access_token: h.accessToken,
        // Convert from ISO format to timestamp.
        expiry_date: new Date(h.expireTime).getTime(),
        res: C
      };
    }
    /**
     * Returns whether the provided credentials are expired or not.
     * If there is no expiry time, assumes the token is not expired or expiring.
     * @param accessToken The credentials to check for expiration.
     * @return Whether the credentials are expired or not.
     */
    isExpired(R) {
      const N = (/* @__PURE__ */ new Date()).getTime();
      return R.expiry_date ? N >= R.expiry_date - this.eagerRefreshThresholdMillis : !1;
    }
    /**
     * @return The list of scopes for the requested GCP access token.
     */
    getScopesArray() {
      return typeof this.scopes == "string" ? [this.scopes] : this.scopes || [m];
    }
    getMetricsHeaderValue() {
      const R = process.version.replace(/^v/, ""), N = this.serviceAccountImpersonationUrl !== void 0, C = this.credentialSourceType ? this.credentialSourceType : "unknown";
      return `gl-node/${R} auth/${I.version} google-byoid-sdk source/${C} sa-impersonation/${N} config-lifetime/${this.configLifetimeRequested}`;
    }
  }
  t.BaseExternalAccountClient = E, i = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakSet(), a = async function() {
    const R = await this.retrieveSubjectToken(), N = {
      grantType: f,
      audience: this.audience,
      requestedTokenType: y,
      subjectToken: R,
      subjectTokenType: this.subjectTokenType,
      // generateAccessToken requires the provided access token to have
      // scopes:
      // https://www.googleapis.com/auth/iam or
      // https://www.googleapis.com/auth/cloud-platform
      // The new service account access token scopes will match the user
      // provided ones.
      scope: this.serviceAccountImpersonationUrl ? [m] : this.getScopesArray()
    }, C = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0, h = {
      "x-goog-api-client": this.getMetricsHeaderValue()
    }, d = await this.stsCredential.exchangeToken(N, h, C);
    return this.serviceAccountImpersonationUrl ? this.cachedAccessToken = await this.getImpersonatedAccessToken(d.access_token) : d.expires_in ? this.cachedAccessToken = {
      access_token: d.access_token,
      expiry_date: (/* @__PURE__ */ new Date()).getTime() + d.expires_in * 1e3,
      res: d.res
    } : this.cachedAccessToken = {
      access_token: d.access_token,
      res: d.res
    }, this.credentials = {}, Object.assign(this.credentials, this.cachedAccessToken), delete this.credentials.res, this.emit("tokens", {
      refresh_token: null,
      expiry_date: this.cachedAccessToken.expiry_date,
      access_token: this.cachedAccessToken.access_token,
      token_type: "Bearer",
      id_token: null
    }), this.cachedAccessToken;
  };
})(Rn);
var Ra = {}, Ro = {}, Mc, Vc, $c;
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.FileSubjectTokenSupplier = void 0;
const ff = ge, df = ge, KS = (0, ff.promisify)((Mc = df.readFile) !== null && Mc !== void 0 ? Mc : () => {
}), GS = (0, ff.promisify)((Vc = df.realpath) !== null && Vc !== void 0 ? Vc : () => {
}), jS = (0, ff.promisify)(($c = df.lstat) !== null && $c !== void 0 ? $c : () => {
});
class qS {
  /**
   * Instantiates a new file based subject token supplier.
   * @param opts The file subject token supplier options to build the supplier
   *   with.
   */
  constructor(e) {
    this.filePath = e.filePath, this.formatType = e.formatType, this.subjectTokenFieldName = e.subjectTokenFieldName;
  }
  /**
   * Returns the subject token stored at the file specified in the constructor.
   * @param context {@link ExternalAccountSupplierContext} from the calling
   *   {@link IdentityPoolClient}, contains the requested audience and subject
   *   token type for the external account identity. Not used.
   */
  async getSubjectToken(e) {
    let r = this.filePath;
    try {
      if (r = await GS(r), !(await jS(r)).isFile())
        throw new Error();
    } catch (a) {
      throw a instanceof Error && (a.message = `The file at ${r} does not exist, or it is not a file. ${a.message}`), a;
    }
    let n;
    const i = await KS(r, { encoding: "utf8" });
    if (this.formatType === "text" ? n = i : this.formatType === "json" && this.subjectTokenFieldName && (n = JSON.parse(i)[this.subjectTokenFieldName]), !n)
      throw new Error("Unable to parse the subject_token from the credential_source file");
    return n;
  }
}
Ro.FileSubjectTokenSupplier = qS;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.UrlSubjectTokenSupplier = void 0;
class WS {
  /**
   * Instantiates a URL subject token supplier.
   * @param opts The URL subject token supplier options to build the supplier with.
   */
  constructor(e) {
    this.url = e.url, this.formatType = e.formatType, this.subjectTokenFieldName = e.subjectTokenFieldName, this.headers = e.headers, this.additionalGaxiosOptions = e.additionalGaxiosOptions;
  }
  /**
   * Sends a GET request to the URL provided in the constructor and resolves
   * with the returned external subject token.
   * @param context {@link ExternalAccountSupplierContext} from the calling
   *   {@link IdentityPoolClient}, contains the requested audience and subject
   *   token type for the external account identity. Not used.
   */
  async getSubjectToken(e) {
    const r = {
      ...this.additionalGaxiosOptions,
      url: this.url,
      method: "GET",
      headers: this.headers,
      responseType: this.formatType
    };
    let n;
    if (this.formatType === "text" ? n = (await e.transporter.request(r)).data : this.formatType === "json" && this.subjectTokenFieldName && (n = (await e.transporter.request(r)).data[this.subjectTokenFieldName]), !n)
      throw new Error("Unable to parse the subject_token from the credential_source URL");
    return n;
  }
}
No.UrlSubjectTokenSupplier = WS;
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.IdentityPoolClient = void 0;
const JS = Rn, Hc = Er, zS = Ro, XS = No;
class hf extends JS.BaseExternalAccountClient {
  /**
   * Instantiate an IdentityPoolClient instance using the provided JSON
   * object loaded from an external account credentials file.
   * An error is thrown if the credential is not a valid file-sourced or
   * url-sourced credential or a workforce pool user project is provided
   * with a non workforce audience.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file. The camelCased options
   *   are aliases for the snake_cased options.
   * @param additionalOptions **DEPRECATED, all options are available in the
   *   `options` parameter.** Optional additional behavior customization options.
   *   These currently customize expiration threshold time and whether to retry
   *   on 401/403 API request errors.
   */
  constructor(e, r) {
    super(e, r);
    const n = (0, Hc.originalOrCamelOptions)(e), i = n.get("credential_source"), a = n.get("subject_token_supplier");
    if (!i && !a)
      throw new Error("A credential source or subject token supplier must be specified.");
    if (i && a)
      throw new Error("Only one of credential source or subject token supplier can be specified.");
    if (a)
      this.subjectTokenSupplier = a, this.credentialSourceType = "programmatic";
    else {
      const s = (0, Hc.originalOrCamelOptions)(i), o = (0, Hc.originalOrCamelOptions)(s.get("format")), l = o.get("type") || "text", u = o.get("subject_token_field_name");
      if (l !== "json" && l !== "text")
        throw new Error(`Invalid credential_source format "${l}"`);
      if (l === "json" && !u)
        throw new Error("Missing subject_token_field_name for JSON credential_source format");
      const f = s.get("file"), y = s.get("url"), m = s.get("headers");
      if (f && y)
        throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
      if (f && !y)
        this.credentialSourceType = "file", this.subjectTokenSupplier = new zS.FileSubjectTokenSupplier({
          filePath: f,
          formatType: l,
          subjectTokenFieldName: u
        });
      else if (!f && y)
        this.credentialSourceType = "url", this.subjectTokenSupplier = new XS.UrlSubjectTokenSupplier({
          url: y,
          formatType: l,
          subjectTokenFieldName: u,
          headers: m,
          additionalGaxiosOptions: hf.RETRY_CONFIG
        });
      else
        throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
    }
  }
  /**
   * Triggered when a external subject token is needed to be exchanged for a GCP
   * access token via GCP STS endpoint. Gets a subject token by calling
   * the configured {@link SubjectTokenSupplier}
   * @return A promise that resolves with the external subject token.
   */
  async retrieveSubjectToken() {
    return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
  }
}
Ra.IdentityPoolClient = hf;
var Na = {}, xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.AwsRequestSigner = void 0;
const ny = va(), Nh = "AWS4-HMAC-SHA256", YS = "aws4_request";
class QS {
  /**
   * Instantiates an AWS API request signer used to send authenticated signed
   * requests to AWS APIs based on the AWS Signature Version 4 signing process.
   * This also provides a mechanism to generate the signed request without
   * sending it.
   * @param getCredentials A mechanism to retrieve AWS security credentials
   *   when needed.
   * @param region The AWS region to use.
   */
  constructor(e, r) {
    this.getCredentials = e, this.region = r, this.crypto = (0, ny.createCrypto)();
  }
  /**
   * Generates the signed request for the provided HTTP request for calling
   * an AWS API. This follows the steps described at:
   * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
   * @param amzOptions The AWS request options that need to be signed.
   * @return A promise that resolves with the GaxiosOptions containing the
   *   signed HTTP request parameters.
   */
  async getRequestOptions(e) {
    if (!e.url)
      throw new Error('"url" is required in "amzOptions"');
    const r = typeof e.data == "object" ? JSON.stringify(e.data) : e.data, n = e.url, i = e.method || "GET", a = e.body || r, s = e.headers, o = await this.getCredentials(), l = new URL(n), u = await eI({
      crypto: this.crypto,
      host: l.host,
      canonicalUri: l.pathname,
      canonicalQuerystring: l.search.substr(1),
      method: i,
      region: this.region,
      securityCredentials: o,
      requestPayload: a,
      additionalAmzHeaders: s
    }), f = Object.assign(
      // Add x-amz-date if available.
      u.amzDate ? { "x-amz-date": u.amzDate } : {},
      {
        Authorization: u.authorizationHeader,
        host: l.host
      },
      s || {}
    );
    o.token && Object.assign(f, {
      "x-amz-security-token": o.token
    });
    const y = {
      url: n,
      method: i,
      headers: f
    };
    return typeof a < "u" && (y.body = a), y;
  }
}
xa.AwsRequestSigner = QS;
async function ia(t, e, r) {
  return await t.signWithHmacSha256(e, r);
}
async function ZS(t, e, r, n, i) {
  const a = await ia(t, `AWS4${e}`, r), s = await ia(t, a, n), o = await ia(t, s, i);
  return await ia(t, o, "aws4_request");
}
async function eI(t) {
  const e = t.additionalAmzHeaders || {}, r = t.requestPayload || "", n = t.host.split(".")[0], i = /* @__PURE__ */ new Date(), a = i.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, ""), s = i.toISOString().replace(/[-]/g, "").replace(/T.*/, ""), o = {};
  Object.keys(e).forEach((v) => {
    o[v.toLowerCase()] = e[v];
  }), t.securityCredentials.token && (o["x-amz-security-token"] = t.securityCredentials.token);
  const l = Object.assign(
    {
      host: t.host
    },
    // Previously the date was not fixed with x-amz- and could be provided manually.
    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
    o.date ? {} : { "x-amz-date": a },
    o
  );
  let u = "";
  const f = Object.keys(l).sort();
  f.forEach((v) => {
    u += `${v}:${l[v]}
`;
  });
  const y = f.join(";"), m = await t.crypto.sha256DigestHex(r), p = `${t.method}
${t.canonicalUri}
${t.canonicalQuerystring}
${u}
${y}
${m}`, S = `${s}/${t.region}/${n}/${YS}`, A = `${Nh}
${a}
${S}
` + await t.crypto.sha256DigestHex(p), I = await ZS(t.crypto, t.securityCredentials.secretAccessKey, s, t.region, n), c = await ia(t.crypto, I, A), E = `${Nh} Credential=${t.securityCredentials.accessKeyId}/${S}, SignedHeaders=${y}, Signature=${(0, ny.fromArrayBufferToHex)(c)}`;
  return {
    // Do not return x-amz-date if date is available.
    amzDate: o.date ? void 0 : a,
    authorizationHeader: E,
    canonicalQuerystring: t.canonicalQuerystring
  };
}
var xo = {}, Qr = pe && pe.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, br, Rl, iy, ay, Es, Nl;
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.DefaultAwsSecurityCredentialsSupplier = void 0;
class tI {
  /**
   * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
   * from the credential_source stored in the ADC file.
   * @param opts The default aws security credentials supplier options object to
   *   build the supplier with.
   */
  constructor(e) {
    br.add(this), this.regionUrl = e.regionUrl, this.securityCredentialsUrl = e.securityCredentialsUrl, this.imdsV2SessionTokenUrl = e.imdsV2SessionTokenUrl, this.additionalGaxiosOptions = e.additionalGaxiosOptions;
  }
  /**
   * Returns the active AWS region. This first checks to see if the region
   * is available as an environment variable. If it is not, then the supplier
   * will call the region URL.
   * @param context {@link ExternalAccountSupplierContext} from the calling
   *   {@link AwsClient}, contains the requested audience and subject token type
   *   for the external account identity.
   * @return A promise that resolves with the AWS region string.
   */
  async getAwsRegion(e) {
    if (Qr(this, br, "a", Es))
      return Qr(this, br, "a", Es);
    const r = {};
    if (!Qr(this, br, "a", Es) && this.imdsV2SessionTokenUrl && (r["x-aws-ec2-metadata-token"] = await Qr(this, br, "m", Rl).call(this, e.transporter)), !this.regionUrl)
      throw new Error('Unable to determine AWS region due to missing "options.credential_source.region_url"');
    const n = {
      ...this.additionalGaxiosOptions,
      url: this.regionUrl,
      method: "GET",
      responseType: "text",
      headers: r
    }, i = await e.transporter.request(n);
    return i.data.substr(0, i.data.length - 1);
  }
  /**
   * Returns AWS security credentials. This first checks to see if the credentials
   * is available as environment variables. If it is not, then the supplier
   * will call the security credentials URL.
   * @param context {@link ExternalAccountSupplierContext} from the calling
   *   {@link AwsClient}, contains the requested audience and subject token type
   *   for the external account identity.
   * @return A promise that resolves with the AWS security credentials.
   */
  async getAwsSecurityCredentials(e) {
    if (Qr(this, br, "a", Nl))
      return Qr(this, br, "a", Nl);
    const r = {};
    this.imdsV2SessionTokenUrl && (r["x-aws-ec2-metadata-token"] = await Qr(this, br, "m", Rl).call(this, e.transporter));
    const n = await Qr(this, br, "m", iy).call(this, r, e.transporter), i = await Qr(this, br, "m", ay).call(this, n, r, e.transporter);
    return {
      accessKeyId: i.AccessKeyId,
      secretAccessKey: i.SecretAccessKey,
      token: i.Token
    };
  }
}
xo.DefaultAwsSecurityCredentialsSupplier = tI;
br = /* @__PURE__ */ new WeakSet(), Rl = /**
 * @param transporter The transporter to use for requests.
 * @return A promise that resolves with the IMDSv2 Session Token.
 */
async function(e) {
  const r = {
    ...this.additionalGaxiosOptions,
    url: this.imdsV2SessionTokenUrl,
    method: "PUT",
    responseType: "text",
    headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
  };
  return (await e.request(r)).data;
}, iy = /**
 * @param headers The headers to be used in the metadata request.
 * @param transporter The transporter to use for requests.
 * @return A promise that resolves with the assigned role to the current
 *   AWS VM. This is needed for calling the security-credentials endpoint.
 */
async function(e, r) {
  if (!this.securityCredentialsUrl)
    throw new Error('Unable to determine AWS role name due to missing "options.credential_source.url"');
  const n = {
    ...this.additionalGaxiosOptions,
    url: this.securityCredentialsUrl,
    method: "GET",
    responseType: "text",
    headers: e
  };
  return (await r.request(n)).data;
}, ay = /**
 * Retrieves the temporary AWS credentials by calling the security-credentials
 * endpoint as specified in the `credential_source` object.
 * @param roleName The role attached to the current VM.
 * @param headers The headers to be used in the metadata request.
 * @param transporter The transporter to use for requests.
 * @return A promise that resolves with the temporary AWS credentials
 *   needed for creating the GetCallerIdentity signed request.
 */
async function(e, r, n) {
  return (await n.request({
    ...this.additionalGaxiosOptions,
    url: `${this.securityCredentialsUrl}/${e}`,
    responseType: "json",
    headers: r
  })).data;
}, Es = function() {
  return process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || null;
}, Nl = function() {
  return process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY ? {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    token: process.env.AWS_SESSION_TOKEN
  } : null;
};
var rI = pe && pe.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, vs, sy;
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.AwsClient = void 0;
const nI = xa, iI = Rn, aI = xo, xh = Er;
class Oo extends iI.BaseExternalAccountClient {
  /**
   * Instantiates an AwsClient instance using the provided JSON
   * object loaded from an external account credentials file.
   * An error is thrown if the credential is not a valid AWS credential.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file.
   * @param additionalOptions **DEPRECATED, all options are available in the
   *   `options` parameter.** Optional additional behavior customization options.
   *   These currently customize expiration threshold time and whether to retry
   *   on 401/403 API request errors.
   */
  constructor(e, r) {
    super(e, r);
    const n = (0, xh.originalOrCamelOptions)(e), i = n.get("credential_source"), a = n.get("aws_security_credentials_supplier");
    if (!i && !a)
      throw new Error("A credential source or AWS security credentials supplier must be specified.");
    if (i && a)
      throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
    if (a)
      this.awsSecurityCredentialsSupplier = a, this.regionalCredVerificationUrl = rI(vs, vs, "f", sy), this.credentialSourceType = "programmatic";
    else {
      const s = (0, xh.originalOrCamelOptions)(i);
      this.environmentId = s.get("environment_id");
      const o = s.get("region_url"), l = s.get("url"), u = s.get("imdsv2_session_token_url");
      this.awsSecurityCredentialsSupplier = new aI.DefaultAwsSecurityCredentialsSupplier({
        regionUrl: o,
        securityCredentialsUrl: l,
        imdsV2SessionTokenUrl: u
      }), this.regionalCredVerificationUrl = s.get("regional_cred_verification_url"), this.credentialSourceType = "aws", this.validateEnvironmentId();
    }
    this.awsRequestSigner = null, this.region = "";
  }
  validateEnvironmentId() {
    var e;
    const r = (e = this.environmentId) === null || e === void 0 ? void 0 : e.match(/^(aws)(\d+)$/);
    if (!r || !this.regionalCredVerificationUrl)
      throw new Error('No valid AWS "credential_source" provided');
    if (parseInt(r[2], 10) !== 1)
      throw new Error(`aws version "${r[2]}" is not supported in the current build.`);
  }
  /**
   * Triggered when an external subject token is needed to be exchanged for a
   * GCP access token via GCP STS endpoint. This will call the
   * {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
   * Security Credentials, then use them to create a signed AWS STS request that
   * can be exchanged for a GCP access token.
   * @return A promise that resolves with the external subject token.
   */
  async retrieveSubjectToken() {
    this.awsRequestSigner || (this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext), this.awsRequestSigner = new nI.AwsRequestSigner(async () => this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext), this.region));
    const e = await this.awsRequestSigner.getRequestOptions({
      ...vs.RETRY_CONFIG,
      url: this.regionalCredVerificationUrl.replace("{region}", this.region),
      method: "POST"
    }), r = [], n = Object.assign({
      // The full, canonical resource name of the workload identity pool
      // provider, with or without the HTTPS prefix.
      // Including this header as part of the signature is recommended to
      // ensure data integrity.
      "x-goog-cloud-target-resource": this.audience
    }, e.headers);
    for (const i in n)
      r.push({
        key: i,
        value: n[i]
      });
    return encodeURIComponent(JSON.stringify({
      url: e.url,
      method: e.method,
      headers: r
    }));
  }
}
Na.AwsClient = Oo;
vs = Oo;
sy = { value: "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15" };
Oo.AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
Oo.AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
var Pn = {}, ft = {};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.InvalidSubjectTokenError = ft.InvalidMessageFieldError = ft.InvalidCodeFieldError = ft.InvalidTokenTypeFieldError = ft.InvalidExpirationTimeFieldError = ft.InvalidSuccessFieldError = ft.InvalidVersionFieldError = ft.ExecutableResponseError = ft.ExecutableResponse = void 0;
const Qa = "urn:ietf:params:oauth:token-type:saml2", Kc = "urn:ietf:params:oauth:token-type:id_token", Gc = "urn:ietf:params:oauth:token-type:jwt";
class sI {
  /**
   * Instantiates an ExecutableResponse instance using the provided JSON object
   * from the output of the executable.
   * @param responseJson Response from a 3rd party executable, loaded from a
   * run of the executable or a cached output file.
   */
  constructor(e) {
    if (!e.version)
      throw new oy("Executable response must contain a 'version' field.");
    if (e.success === void 0)
      throw new cy("Executable response must contain a 'success' field.");
    if (this.version = e.version, this.success = e.success, this.success) {
      if (this.expirationTime = e.expiration_time, this.tokenType = e.token_type, this.tokenType !== Qa && this.tokenType !== Kc && this.tokenType !== Gc)
        throw new uy(`Executable response must contain a 'token_type' field when successful and it must be one of ${Kc}, ${Gc}, or ${Qa}.`);
      if (this.tokenType === Qa) {
        if (!e.saml_response)
          throw new xl(`Executable response must contain a 'saml_response' field when token_type=${Qa}.`);
        this.subjectToken = e.saml_response;
      } else {
        if (!e.id_token)
          throw new xl(`Executable response must contain a 'id_token' field when token_type=${Kc} or ${Gc}.`);
        this.subjectToken = e.id_token;
      }
    } else {
      if (!e.code)
        throw new ly("Executable response must contain a 'code' field when unsuccessful.");
      if (!e.message)
        throw new fy("Executable response must contain a 'message' field when unsuccessful.");
      this.errorCode = e.code, this.errorMessage = e.message;
    }
  }
  /**
   * @return A boolean representing if the response has a valid token. Returns
   * true when the response was successful and the token is not expired.
   */
  isValid() {
    return !this.isExpired() && this.success;
  }
  /**
   * @return A boolean representing if the response is expired. Returns true if the
   * provided timeout has passed.
   */
  isExpired() {
    return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
  }
}
ft.ExecutableResponse = sI;
class Nn extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, new.target.prototype);
  }
}
ft.ExecutableResponseError = Nn;
class oy extends Nn {
}
ft.InvalidVersionFieldError = oy;
class cy extends Nn {
}
ft.InvalidSuccessFieldError = cy;
class oI extends Nn {
}
ft.InvalidExpirationTimeFieldError = oI;
class uy extends Nn {
}
ft.InvalidTokenTypeFieldError = uy;
class ly extends Nn {
}
ft.InvalidCodeFieldError = ly;
class fy extends Nn {
}
ft.InvalidMessageFieldError = fy;
class xl extends Nn {
}
ft.InvalidSubjectTokenError = xl;
var Yi = {}, Oh;
function cI() {
  if (Oh) return Yi;
  Oh = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.PluggableAuthHandler = void 0;
  const t = pf(), e = ft, r = ge, n = ge;
  class i {
    /**
     * Instantiates a PluggableAuthHandler instance using the provided
     * PluggableAuthHandlerOptions object.
     */
    constructor(s) {
      if (!s.command)
        throw new Error("No command provided.");
      if (this.commandComponents = i.parseCommand(s.command), this.timeoutMillis = s.timeoutMillis, !this.timeoutMillis)
        throw new Error("No timeoutMillis provided.");
      this.outputFile = s.outputFile;
    }
    /**
     * Calls user provided executable to get a 3rd party subject token and
     * returns the response.
     * @param envMap a Map of additional Environment Variables required for
     *   the executable.
     * @return A promise that resolves with the executable response.
     */
    retrieveResponseFromExecutable(s) {
      return new Promise((o, l) => {
        const u = r.spawn(this.commandComponents[0], this.commandComponents.slice(1), {
          env: { ...process.env, ...Object.fromEntries(s) }
        });
        let f = "";
        u.stdout.on("data", (m) => {
          f += m;
        }), u.stderr.on("data", (m) => {
          f += m;
        });
        const y = setTimeout(() => (u.removeAllListeners(), u.kill(), l(new Error("The executable failed to finish within the timeout specified."))), this.timeoutMillis);
        u.on("close", (m) => {
          if (clearTimeout(y), m === 0)
            try {
              const p = JSON.parse(f), S = new e.ExecutableResponse(p);
              return o(S);
            } catch (p) {
              return p instanceof e.ExecutableResponseError ? l(p) : l(new e.ExecutableResponseError(`The executable returned an invalid response: ${f}`));
            }
          else
            return l(new t.ExecutableError(f, m.toString()));
        });
      });
    }
    /**
     * Checks user provided output file for response from previous run of
     * executable and return the response if it exists, is formatted correctly, and is not expired.
     */
    async retrieveCachedResponse() {
      if (!this.outputFile || this.outputFile.length === 0)
        return;
      let s;
      try {
        s = await n.promises.realpath(this.outputFile);
      } catch {
        return;
      }
      if (!(await n.promises.lstat(s)).isFile())
        return;
      const o = await n.promises.readFile(s, {
        encoding: "utf8"
      });
      if (o !== "")
        try {
          const l = JSON.parse(o);
          return new e.ExecutableResponse(l).isValid() ? new e.ExecutableResponse(l) : void 0;
        } catch (l) {
          throw l instanceof e.ExecutableResponseError ? l : new e.ExecutableResponseError(`The output file contained an invalid response: ${o}`);
        }
    }
    /**
     * Parses given command string into component array, splitting on spaces unless
     * spaces are between quotation marks.
     */
    static parseCommand(s) {
      const o = s.match(/(?:[^\s"]+|"[^"]*")+/g);
      if (!o)
        throw new Error(`Provided command: "${s}" could not be parsed.`);
      for (let l = 0; l < o.length; l++)
        o[l][0] === '"' && o[l].slice(-1) === '"' && (o[l] = o[l].slice(1, -1));
      return o;
    }
  }
  return Yi.PluggableAuthHandler = i, Yi;
}
var Dh;
function pf() {
  if (Dh) return Pn;
  Dh = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.PluggableAuthClient = Pn.ExecutableError = void 0;
  const t = Rn, e = ft, r = cI();
  class n extends Error {
    constructor(y, m) {
      super(`The executable failed with exit code: ${m} and error message: ${y}.`), this.code = m, Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  Pn.ExecutableError = n;
  const i = 30 * 1e3, a = 5 * 1e3, s = 120 * 1e3, o = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES", l = 1;
  class u extends t.BaseExternalAccountClient {
    /**
     * Instantiates a PluggableAuthClient instance using the provided JSON
     * object loaded from an external account credentials file.
     * An error is thrown if the credential is not a valid pluggable auth credential.
     * @param options The external account options object typically loaded from
     *   the external account JSON credential file.
     * @param additionalOptions **DEPRECATED, all options are available in the
     *   `options` parameter.** Optional additional behavior customization options.
     *   These currently customize expiration threshold time and whether to retry
     *   on 401/403 API request errors.
     */
    constructor(y, m) {
      if (super(y, m), !y.credential_source.executable)
        throw new Error('No valid Pluggable Auth "credential_source" provided.');
      if (this.command = y.credential_source.executable.command, !this.command)
        throw new Error('No valid Pluggable Auth "credential_source" provided.');
      if (y.credential_source.executable.timeout_millis === void 0)
        this.timeoutMillis = i;
      else if (this.timeoutMillis = y.credential_source.executable.timeout_millis, this.timeoutMillis < a || this.timeoutMillis > s)
        throw new Error(`Timeout must be between ${a} and ${s} milliseconds.`);
      this.outputFile = y.credential_source.executable.output_file, this.handler = new r.PluggableAuthHandler({
        command: this.command,
        timeoutMillis: this.timeoutMillis,
        outputFile: this.outputFile
      }), this.credentialSourceType = "executable";
    }
    /**
     * Triggered when an external subject token is needed to be exchanged for a
     * GCP access token via GCP STS endpoint.
     * This uses the `options.credential_source` object to figure out how
     * to retrieve the token using the current environment. In this case,
     * this calls a user provided executable which returns the subject token.
     * The logic is summarized as:
     * 1. Validated that the executable is allowed to run. The
     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
     *    1 for security reasons.
     * 2. If an output file is specified by the user, check the file location
     *    for a response. If the file exists and contains a valid response,
     *    return the subject token from the file.
     * 3. Call the provided executable and return response.
     * @return A promise that resolves with the external subject token.
     */
    async retrieveSubjectToken() {
      if (process.env[o] !== "1")
        throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
      let y;
      if (this.outputFile && (y = await this.handler.retrieveCachedResponse()), !y) {
        const m = /* @__PURE__ */ new Map();
        m.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience), m.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType), m.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0"), this.outputFile && m.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
        const p = this.getServiceAccountEmail();
        p && m.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", p), y = await this.handler.retrieveResponseFromExecutable(m);
      }
      if (y.version > l)
        throw new Error(`Version of executable is not currently supported, maximum supported version is ${l}.`);
      if (!y.success)
        throw new n(y.errorMessage, y.errorCode);
      if (this.outputFile && !y.expirationTime)
        throw new e.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
      if (y.isExpired())
        throw new Error("Executable response is expired.");
      return y.subjectToken;
    }
  }
  return Pn.PluggableAuthClient = u, Pn;
}
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.ExternalAccountClient = void 0;
const uI = Rn, lI = Ra, fI = Na, dI = pf();
class hI {
  constructor() {
    throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
  }
  /**
   * This static method will instantiate the
   * corresponding type of external account credential depending on the
   * underlying credential source.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file.
   * @param additionalOptions **DEPRECATED, all options are available in the
   *   `options` parameter.** Optional additional behavior customization options.
   *   These currently customize expiration threshold time and whether to retry
   *   on 401/403 API request errors.
   * @return A BaseExternalAccountClient instance or null if the options
   *   provided do not correspond to an external account credential.
   */
  static fromJSON(e, r) {
    var n, i;
    return e && e.type === uI.EXTERNAL_ACCOUNT_TYPE ? !((n = e.credential_source) === null || n === void 0) && n.environment_id ? new fI.AwsClient(e, r) : !((i = e.credential_source) === null || i === void 0) && i.executable ? new dI.PluggableAuthClient(e, r) : new lI.IdentityPoolClient(e, r) : null;
  }
}
wa.ExternalAccountClient = hI;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.ExternalAccountAuthorizedUserClient = Ni.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
const pI = qr, Lh = Ui, gI = Lr, yI = ge, mI = Rn;
Ni.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
const EI = "https://sts.{universeDomain}/v1/oauthtoken";
class gf extends Lh.OAuthClientAuthHandler {
  /**
   * Initializes an ExternalAccountAuthorizedUserHandler instance.
   * @param url The URL of the token refresh endpoint.
   * @param transporter The transporter to use for the refresh request.
   * @param clientAuthentication The client authentication credentials to use
   *   for the refresh request.
   */
  constructor(e, r, n) {
    super(n), this.url = e, this.transporter = r;
  }
  /**
   * Requests a new access token from the token_url endpoint using the provided
   *   refresh token.
   * @param refreshToken The refresh token to use to generate a new access token.
   * @param additionalHeaders Optional additional headers to pass along the
   *   request.
   * @return A promise that resolves with the token refresh response containing
   *   the requested access token and its expiration time.
   */
  async refreshToken(e, r) {
    const n = new URLSearchParams({
      grant_type: "refresh_token",
      refresh_token: e
    }), i = {
      "Content-Type": "application/x-www-form-urlencoded",
      ...r
    }, a = {
      ...gf.RETRY_CONFIG,
      url: this.url,
      method: "POST",
      headers: i,
      data: n.toString(),
      responseType: "json"
    };
    this.applyClientAuthenticationOptions(a);
    try {
      const s = await this.transporter.request(a), o = s.data;
      return o.res = s, o;
    } catch (s) {
      throw s instanceof gI.GaxiosError && s.response ? (0, Lh.getErrorFromOAuthErrorResponse)(
        s.response.data,
        // Preserve other fields from the original error.
        s
      ) : s;
    }
  }
}
class vI extends pI.AuthClient {
  /**
   * Instantiates an ExternalAccountAuthorizedUserClient instances using the
   * provided JSON object loaded from a credentials files.
   * An error is throws if the credential is not valid.
   * @param options The external account authorized user option object typically
   *   from the external accoutn authorized user JSON credential file.
   * @param additionalOptions **DEPRECATED, all options are available in the
   *   `options` parameter.** Optional additional behavior customization options.
   *   These currently customize expiration threshold time and whether to retry
   *   on 401/403 API request errors.
   */
  constructor(e, r) {
    var n;
    super({ ...e, ...r }), e.universe_domain && (this.universeDomain = e.universe_domain), this.refreshToken = e.refresh_token;
    const i = {
      confidentialClientType: "basic",
      clientId: e.client_id,
      clientSecret: e.client_secret
    };
    this.externalAccountAuthorizedUserHandler = new gf((n = e.token_url) !== null && n !== void 0 ? n : EI.replace("{universeDomain}", this.universeDomain), this.transporter, i), this.cachedAccessToken = null, this.quotaProjectId = e.quota_project_id, typeof (r == null ? void 0 : r.eagerRefreshThresholdMillis) != "number" ? this.eagerRefreshThresholdMillis = mI.EXPIRATION_TIME_OFFSET : this.eagerRefreshThresholdMillis = r.eagerRefreshThresholdMillis, this.forceRefreshOnFailure = !!(r != null && r.forceRefreshOnFailure);
  }
  async getAccessToken() {
    return (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) && await this.refreshAccessTokenAsync(), {
      token: this.cachedAccessToken.access_token,
      res: this.cachedAccessToken.res
    };
  }
  async getRequestHeaders() {
    const r = {
      Authorization: `Bearer ${(await this.getAccessToken()).token}`
    };
    return this.addSharedMetadataHeaders(r);
  }
  request(e, r) {
    if (r)
      this.requestAsync(e).then((n) => r(null, n), (n) => r(n, n.response));
    else
      return this.requestAsync(e);
  }
  /**
   * Authenticates the provided HTTP request, processes it and resolves with the
   * returned response.
   * @param opts The HTTP request options.
   * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
   * @return A promise that resolves with the successful response.
   */
  async requestAsync(e, r = !1) {
    let n;
    try {
      const i = await this.getRequestHeaders();
      e.headers = e.headers || {}, i && i["x-goog-user-project"] && (e.headers["x-goog-user-project"] = i["x-goog-user-project"]), i && i.Authorization && (e.headers.Authorization = i.Authorization), n = await this.transporter.request(e);
    } catch (i) {
      const a = i.response;
      if (a) {
        const s = a.status, o = a.config.data instanceof yI.Readable;
        if (!r && (s === 401 || s === 403) && !o && this.forceRefreshOnFailure)
          return await this.refreshAccessTokenAsync(), await this.requestAsync(e, !0);
      }
      throw i;
    }
    return n;
  }
  /**
   * Forces token refresh, even if unexpired tokens are currently cached.
   * @return A promise that resolves with the refreshed credential.
   */
  async refreshAccessTokenAsync() {
    const e = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
    return this.cachedAccessToken = {
      access_token: e.access_token,
      expiry_date: (/* @__PURE__ */ new Date()).getTime() + e.expires_in * 1e3,
      res: e.res
    }, e.refresh_token !== void 0 && (this.refreshToken = e.refresh_token), this.cachedAccessToken;
  }
  /**
   * Returns whether the provided credentials are expired or not.
   * If there is no expiry time, assumes the token is not expired or expiring.
   * @param credentials The credentials to check for expiration.
   * @return Whether the credentials are expired or not.
   */
  isExpired(e) {
    const r = (/* @__PURE__ */ new Date()).getTime();
    return e.expiry_date ? r >= e.expiry_date - this.eagerRefreshThresholdMillis : !1;
  }
}
Ni.ExternalAccountAuthorizedUserClient = vI;
(function(t) {
  var e = pe && pe.__classPrivateFieldGet || function(P, L, D, V) {
    if (D === "a" && !V) throw new TypeError("Private accessor was defined without a getter");
    if (typeof L == "function" ? P !== L || !V : !L.has(P)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return D === "m" ? V : D === "a" ? V.call(P) : V ? V.value : L.get(P);
  }, r = pe && pe.__classPrivateFieldSet || function(P, L, D, V, $) {
    if (V === "m") throw new TypeError("Private method is not writable");
    if (V === "a" && !$) throw new TypeError("Private accessor was defined without a setter");
    if (typeof L == "function" ? P !== L || !$ : !L.has(P)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return V === "a" ? $.call(P, D) : $ ? $.value = D : L.set(P, D), D;
  }, n, i, a, s;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.GoogleAuth = t.GoogleAuthExceptionMessages = t.CLOUD_SDK_CLIENT_ID = void 0;
  const o = ge, l = ge, u = ya, f = ge, y = ge, m = va(), p = ei, S = Aa, A = _a, I = ti, c = Sa, E = Gn, v = jn, R = wa, N = Rn, C = qr, h = Ni, d = Er;
  t.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com", t.GoogleAuthExceptionMessages = {
    API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
    NO_PROJECT_ID_FOUND: `Unable to detect a Project Id in the current environment. 
To learn more about authentication and Google APIs, visit: 
https://cloud.google.com/docs/authentication/getting-started`,
    NO_CREDENTIALS_FOUND: `Unable to find credentials in current environment. 
To learn more about authentication and Google APIs, visit: 
https://cloud.google.com/docs/authentication/getting-started`,
    NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
    NO_UNIVERSE_DOMAIN_FOUND: `Unable to detect a Universe Domain in the current environment.
To learn more about Universe Domain retrieval, visit: 
https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys`
  };
  class O {
    // Note:  this properly is only public to satisfy unit tests.
    // https://github.com/Microsoft/TypeScript/issues/5228
    get isGCE() {
      return this.checkIsGCE;
    }
    /**
     * Configuration is resolved in the following order of precedence:
     * - {@link GoogleAuthOptions.credentials `credentials`}
     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}
     * - {@link GoogleAuthOptions.keyFile `keyFile`}
     *
     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
     * {@link AuthClient `AuthClient`s}.
     *
     * @param opts
     */
    constructor(L = {}) {
      if (n.add(this), this.checkIsGCE = void 0, this.jsonContent = null, this.cachedCredential = null, i.set(this, null), this.clientOptions = {}, this._cachedProjectId = L.projectId || null, this.cachedCredential = L.authClient || null, this.keyFilename = L.keyFilename || L.keyFile, this.scopes = L.scopes, this.clientOptions = L.clientOptions || {}, this.jsonContent = L.credentials || null, this.apiKey = L.apiKey || this.clientOptions.apiKey || null, this.apiKey && (this.jsonContent || this.clientOptions.credentials))
        throw new RangeError(t.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
      L.universeDomain && (this.clientOptions.universeDomain = L.universeDomain);
    }
    // GAPIC client libraries should always use self-signed JWTs. The following
    // variables are set on the JWT client in order to indicate the type of library,
    // and sign the JWT with the correct audience and scopes (if not supplied).
    setGapicJWTValues(L) {
      L.defaultServicePath = this.defaultServicePath, L.useJWTAccessWithScope = this.useJWTAccessWithScope, L.defaultScopes = this.defaultScopes;
    }
    getProjectId(L) {
      if (L)
        this.getProjectIdAsync().then((D) => L(null, D), L);
      else
        return this.getProjectIdAsync();
    }
    /**
     * A temporary method for internal `getProjectId` usages where `null` is
     * acceptable. In a future major release, `getProjectId` should return `null`
     * (as the `Promise<string | null>` base signature describes) and this private
     * method should be removed.
     *
     * @returns Promise that resolves with project id (or `null`)
     */
    async getProjectIdOptional() {
      try {
        return await this.getProjectId();
      } catch (L) {
        if (L instanceof Error && L.message === t.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND)
          return null;
        throw L;
      }
    }
    /**
     * A private method for finding and caching a projectId.
     *
     * Supports environments in order of precedence:
     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
     * - GOOGLE_APPLICATION_CREDENTIALS JSON file
     * - Cloud SDK: `gcloud config config-helper --format json`
     * - GCE project ID from metadata server
     *
     * @returns projectId
     */
    async findAndCacheProjectId() {
      let L = null;
      if (L || (L = await this.getProductionProjectId()), L || (L = await this.getFileProjectId()), L || (L = await this.getDefaultServiceProjectId()), L || (L = await this.getGCEProjectId()), L || (L = await this.getExternalAccountClientProjectId()), L)
        return this._cachedProjectId = L, L;
      throw new Error(t.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
    }
    async getProjectIdAsync() {
      return this._cachedProjectId ? this._cachedProjectId : (this._findProjectIdPromise || (this._findProjectIdPromise = this.findAndCacheProjectId()), this._findProjectIdPromise);
    }
    /**
     * Retrieves a universe domain from the metadata server via
     * {@link gcpMetadata.universe}.
     *
     * @returns a universe domain
     */
    async getUniverseDomainFromMetadataServer() {
      var L;
      let D;
      try {
        D = await u.universe("universe-domain"), D || (D = C.DEFAULT_UNIVERSE);
      } catch (V) {
        if (V && ((L = V == null ? void 0 : V.response) === null || L === void 0 ? void 0 : L.status) === 404)
          D = C.DEFAULT_UNIVERSE;
        else
          throw V;
      }
      return D;
    }
    /**
     * Retrieves, caches, and returns the universe domain in the following order
     * of precedence:
     * - The universe domain in {@link GoogleAuth.clientOptions}
     * - An existing or ADC {@link AuthClient}'s universe domain
     * - {@link gcpMetadata.universe}, if {@link Compute} client
     *
     * @returns The universe domain
     */
    async getUniverseDomain() {
      let L = (0, d.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
      try {
        L ?? (L = (await this.getClient()).universeDomain);
      } catch {
        L ?? (L = C.DEFAULT_UNIVERSE);
      }
      return L;
    }
    /**
     * @returns Any scopes (user-specified or default scopes specified by the
     *   client library) that need to be set on the current Auth client.
     */
    getAnyScopes() {
      return this.scopes || this.defaultScopes;
    }
    getApplicationDefault(L = {}, D) {
      let V;
      if (typeof L == "function" ? D = L : V = L, D)
        this.getApplicationDefaultAsync(V).then(($) => D(null, $.credential, $.projectId), D);
      else
        return this.getApplicationDefaultAsync(V);
    }
    async getApplicationDefaultAsync(L = {}) {
      if (this.cachedCredential)
        return await e(this, n, "m", a).call(this, this.cachedCredential, null);
      let D;
      if (D = await this._tryGetApplicationCredentialsFromEnvironmentVariable(L), D)
        return D instanceof c.JWT ? D.scopes = this.scopes : D instanceof N.BaseExternalAccountClient && (D.scopes = this.getAnyScopes()), await e(this, n, "m", a).call(this, D);
      if (D = await this._tryGetApplicationCredentialsFromWellKnownFile(L), D)
        return D instanceof c.JWT ? D.scopes = this.scopes : D instanceof N.BaseExternalAccountClient && (D.scopes = this.getAnyScopes()), await e(this, n, "m", a).call(this, D);
      if (await this._checkIsGCE())
        return L.scopes = this.getAnyScopes(), await e(this, n, "m", a).call(this, new S.Compute(L));
      throw new Error(t.GoogleAuthExceptionMessages.NO_ADC_FOUND);
    }
    /**
     * Determines whether the auth layer is running on Google Compute Engine.
     * Checks for GCP Residency, then fallback to checking if metadata server
     * is available.
     *
     * @returns A promise that resolves with the boolean.
     * @api private
     */
    async _checkIsGCE() {
      return this.checkIsGCE === void 0 && (this.checkIsGCE = u.getGCPResidency() || await u.isAvailable()), this.checkIsGCE;
    }
    /**
     * Attempts to load default credentials from the environment variable path..
     * @returns Promise that resolves with the OAuth2Client or null.
     * @api private
     */
    async _tryGetApplicationCredentialsFromEnvironmentVariable(L) {
      const D = process.env.GOOGLE_APPLICATION_CREDENTIALS || process.env.google_application_credentials;
      if (!D || D.length === 0)
        return null;
      try {
        return this._getApplicationCredentialsFromFilePath(D, L);
      } catch (V) {
        throw V instanceof Error && (V.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${V.message}`), V;
      }
    }
    /**
     * Attempts to load default credentials from a well-known file location
     * @return Promise that resolves with the OAuth2Client or null.
     * @api private
     */
    async _tryGetApplicationCredentialsFromWellKnownFile(L) {
      let D = null;
      if (this._isWindows())
        D = process.env.APPDATA;
      else {
        const $ = process.env.HOME;
        $ && (D = y.join($, ".config"));
      }
      return D && (D = y.join(D, "gcloud", "application_default_credentials.json"), l.existsSync(D) || (D = null)), D ? await this._getApplicationCredentialsFromFilePath(D, L) : null;
    }
    /**
     * Attempts to load default credentials from a file at the given path..
     * @param filePath The path to the file to read.
     * @returns Promise that resolves with the OAuth2Client
     * @api private
     */
    async _getApplicationCredentialsFromFilePath(L, D = {}) {
      if (!L || L.length === 0)
        throw new Error("The file path is invalid.");
      try {
        if (L = l.realpathSync(L), !l.lstatSync(L).isFile())
          throw new Error();
      } catch ($) {
        throw $ instanceof Error && ($.message = `The file at ${L} does not exist, or it is not a file. ${$.message}`), $;
      }
      const V = l.createReadStream(L);
      return this.fromStream(V, D);
    }
    /**
     * Create a credentials instance using a given impersonated input options.
     * @param json The impersonated input object.
     * @returns JWT or UserRefresh Client with data
     */
    fromImpersonatedJSON(L) {
      var D, V, $, K;
      if (!L)
        throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
      if (L.type !== v.IMPERSONATED_ACCOUNT_TYPE)
        throw new Error(`The incoming JSON object does not have the "${v.IMPERSONATED_ACCOUNT_TYPE}" type`);
      if (!L.source_credentials)
        throw new Error("The incoming JSON object does not contain a source_credentials field");
      if (!L.service_account_impersonation_url)
        throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
      const Q = this.fromJSON(L.source_credentials);
      if (((D = L.service_account_impersonation_url) === null || D === void 0 ? void 0 : D.length) > 256)
        throw new RangeError(`Target principal is too long: ${L.service_account_impersonation_url}`);
      const ee = ($ = (V = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(L.service_account_impersonation_url)) === null || V === void 0 ? void 0 : V.groups) === null || $ === void 0 ? void 0 : $.target;
      if (!ee)
        throw new RangeError(`Cannot extract target principal from ${L.service_account_impersonation_url}`);
      const ne = (K = this.getAnyScopes()) !== null && K !== void 0 ? K : [];
      return new v.Impersonated({
        ...L,
        sourceClient: Q,
        targetPrincipal: ee,
        targetScopes: Array.isArray(ne) ? ne : [ne]
      });
    }
    /**
     * Create a credentials instance using the given input options.
     * This client is not cached.
     *
     * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
     *
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */
    fromJSON(L, D = {}) {
      let V;
      const $ = (0, d.originalOrCamelOptions)(D).get("universe_domain");
      return L.type === E.USER_REFRESH_ACCOUNT_TYPE ? (V = new E.UserRefreshClient(D), V.fromJSON(L)) : L.type === v.IMPERSONATED_ACCOUNT_TYPE ? V = this.fromImpersonatedJSON(L) : L.type === N.EXTERNAL_ACCOUNT_TYPE ? (V = R.ExternalAccountClient.fromJSON(L, D), V.scopes = this.getAnyScopes()) : L.type === h.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE ? V = new h.ExternalAccountAuthorizedUserClient(L, D) : (D.scopes = this.scopes, V = new c.JWT(D), this.setGapicJWTValues(V), V.fromJSON(L)), $ && (V.universeDomain = $), V;
    }
    /**
     * Return a JWT or UserRefreshClient from JavaScript object, caching both the
     * object used to instantiate and the client.
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */
    _cacheClientFromJSON(L, D) {
      const V = this.fromJSON(L, D);
      return this.jsonContent = L, this.cachedCredential = V, V;
    }
    fromStream(L, D = {}, V) {
      let $ = {};
      if (typeof D == "function" ? V = D : $ = D, V)
        this.fromStreamAsync(L, $).then((K) => V(null, K), V);
      else
        return this.fromStreamAsync(L, $);
    }
    fromStreamAsync(L, D) {
      return new Promise((V, $) => {
        if (!L)
          throw new Error("Must pass in a stream containing the Google auth settings.");
        const K = [];
        L.setEncoding("utf8").on("error", $).on("data", (Q) => K.push(Q)).on("end", () => {
          try {
            try {
              const Q = JSON.parse(K.join("")), ee = this._cacheClientFromJSON(Q, D);
              return V(ee);
            } catch (Q) {
              if (!this.keyFilename)
                throw Q;
              const ee = new c.JWT({
                ...this.clientOptions,
                keyFile: this.keyFilename
              });
              return this.cachedCredential = ee, this.setGapicJWTValues(ee), V(ee);
            }
          } catch (Q) {
            return $(Q);
          }
        });
      });
    }
    /**
     * Create a credentials instance using the given API key string.
     * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
     *
     * @param apiKey The API key string
     * @param options An optional options object.
     * @returns A JWT loaded from the key
     */
    fromAPIKey(L, D = {}) {
      return new c.JWT({ ...D, apiKey: L });
    }
    /**
     * Determines whether the current operating system is Windows.
     * @api private
     */
    _isWindows() {
      const L = f.platform();
      return !!(L && L.length >= 3 && L.substring(0, 3).toLowerCase() === "win");
    }
    /**
     * Run the Google Cloud SDK command that prints the default project ID
     */
    async getDefaultServiceProjectId() {
      return new Promise((L) => {
        (0, o.exec)("gcloud config config-helper --format json", (D, V) => {
          if (!D && V)
            try {
              const $ = JSON.parse(V).configuration.properties.core.project;
              L($);
              return;
            } catch {
            }
          L(null);
        });
      });
    }
    /**
     * Loads the project id from environment variables.
     * @api private
     */
    getProductionProjectId() {
      return process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT || process.env.gcloud_project || process.env.google_cloud_project;
    }
    /**
     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
     * @api private
     */
    async getFileProjectId() {
      if (this.cachedCredential)
        return this.cachedCredential.projectId;
      if (this.keyFilename) {
        const D = await this.getClient();
        if (D && D.projectId)
          return D.projectId;
      }
      const L = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
      return L ? L.projectId : null;
    }
    /**
     * Gets the project ID from external account client if available.
     */
    async getExternalAccountClientProjectId() {
      return !this.jsonContent || this.jsonContent.type !== N.EXTERNAL_ACCOUNT_TYPE ? null : await (await this.getClient()).getProjectId();
    }
    /**
     * Gets the Compute Engine project ID if it can be inferred.
     */
    async getGCEProjectId() {
      try {
        return await u.project("project-id");
      } catch {
        return null;
      }
    }
    getCredentials(L) {
      if (L)
        this.getCredentialsAsync().then((D) => L(null, D), L);
      else
        return this.getCredentialsAsync();
    }
    async getCredentialsAsync() {
      const L = await this.getClient();
      if (L instanceof v.Impersonated)
        return { client_email: L.getTargetPrincipal() };
      if (L instanceof N.BaseExternalAccountClient) {
        const D = L.getServiceAccountEmail();
        if (D)
          return {
            client_email: D,
            universe_domain: L.universeDomain
          };
      }
      if (this.jsonContent)
        return {
          client_email: this.jsonContent.client_email,
          private_key: this.jsonContent.private_key,
          universe_domain: this.jsonContent.universe_domain
        };
      if (await this._checkIsGCE()) {
        const [D, V] = await Promise.all([
          u.instance("service-accounts/default/email"),
          this.getUniverseDomain()
        ]);
        return { client_email: D, universe_domain: V };
      }
      throw new Error(t.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
    }
    /**
     * Automatically obtain an {@link AuthClient `AuthClient`} based on the
     * provided configuration. If no options were passed, use Application
     * Default Credentials.
     */
    async getClient() {
      if (this.cachedCredential)
        return this.cachedCredential;
      r(this, i, e(this, i, "f") || e(this, n, "m", s).call(this), "f");
      try {
        return await e(this, i, "f");
      } finally {
        r(this, i, null, "f");
      }
    }
    /**
     * Creates a client which will fetch an ID token for authorization.
     * @param targetAudience the audience for the fetched ID token.
     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
     */
    async getIdTokenClient(L) {
      const D = await this.getClient();
      if (!("fetchIdToken" in D))
        throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
      return new A.IdTokenClient({ targetAudience: L, idTokenProvider: D });
    }
    /**
     * Automatically obtain application default credentials, and return
     * an access token for making requests.
     */
    async getAccessToken() {
      return (await (await this.getClient()).getAccessToken()).token;
    }
    /**
     * Obtain the HTTP headers that will provide authorization for a given
     * request.
     */
    async getRequestHeaders(L) {
      return (await this.getClient()).getRequestHeaders(L);
    }
    /**
     * Obtain credentials for a request, then attach the appropriate headers to
     * the request options.
     * @param opts Axios or Request options on which to attach the headers
     */
    async authorizeRequest(L) {
      L = L || {};
      const D = L.url || L.uri, $ = await (await this.getClient()).getRequestHeaders(D);
      return L.headers = Object.assign(L.headers || {}, $), L;
    }
    /**
     * Automatically obtain application default credentials, and make an
     * HTTP request using the given options.
     * @param opts Axios request options for the HTTP request.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async request(L) {
      return (await this.getClient()).request(L);
    }
    /**
     * Determine the compute environment in which the code is running.
     */
    getEnv() {
      return (0, I.getEnv)();
    }
    /**
     * Sign the given data with the current private key, or go out
     * to the IAM API to sign it.
     * @param data The data to be signed.
     * @param endpoint A custom endpoint to use.
     *
     * @example
     * ```
     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
     * ```
     */
    async sign(L, D) {
      const V = await this.getClient(), $ = await this.getUniverseDomain();
      if (D = D || `https://iamcredentials.${$}/v1/projects/-/serviceAccounts/`, V instanceof v.Impersonated)
        return (await V.sign(L)).signedBlob;
      const K = (0, m.createCrypto)();
      if (V instanceof c.JWT && V.key)
        return await K.sign(V.key, L);
      const Q = await this.getCredentials();
      if (!Q.client_email)
        throw new Error("Cannot sign data without `client_email`.");
      return this.signBlob(K, Q.client_email, L, D);
    }
    async signBlob(L, D, V, $) {
      const K = new URL($ + `${D}:signBlob`);
      return (await this.request({
        method: "POST",
        url: K.href,
        data: {
          payload: L.encodeBase64StringUtf8(V)
        },
        retry: !0,
        retryConfig: {
          httpMethodsToRetry: ["POST"]
        }
      })).data.signedBlob;
    }
  }
  t.GoogleAuth = O, i = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakSet(), a = async function(L, D = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || null) {
    const V = await this.getProjectIdOptional();
    return D && (L.quotaProjectId = D), this.cachedCredential = L, { credential: L, projectId: V };
  }, s = async function() {
    if (this.jsonContent)
      return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
    if (this.keyFilename) {
      const L = y.resolve(this.keyFilename), D = l.createReadStream(L);
      return await this.fromStreamAsync(D, this.clientOptions);
    } else if (this.apiKey) {
      const L = await this.fromAPIKey(this.apiKey, this.clientOptions);
      L.scopes = this.scopes;
      const { credential: D } = await e(this, n, "m", a).call(this, L);
      return D;
    } else {
      const { credential: L } = await this.getApplicationDefaultAsync(this.clientOptions);
      return L;
    }
  }, O.DefaultTransporter = p.DefaultTransporter;
})(ng);
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.IAMAuth = void 0;
class AI {
  /**
   * IAM credentials.
   *
   * @param selector the iam authority selector
   * @param token the token
   * @constructor
   */
  constructor(e, r) {
    this.selector = e, this.token = r, this.selector = e, this.token = r;
  }
  /**
   * Acquire the HTTP headers required to make an authenticated request.
   */
  getRequestHeaders() {
    return {
      "x-goog-iam-authority-selector": this.selector,
      "x-goog-iam-authorization-token": this.token
    };
  }
}
Do.IAMAuth = AI;
var dy = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DownscopedClient = t.EXPIRATION_TIME_OFFSET = t.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
  const e = ge, r = qr, n = Ta, i = "urn:ietf:params:oauth:grant-type:token-exchange", a = "urn:ietf:params:oauth:token-type:access_token", s = "urn:ietf:params:oauth:token-type:access_token";
  t.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10, t.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
  class o extends r.AuthClient {
    /**
     * Instantiates a downscoped client object using the provided source
     * AuthClient and credential access boundary rules.
     * To downscope permissions of a source AuthClient, a Credential Access
     * Boundary that specifies which resources the new credential can access, as
     * well as an upper bound on the permissions that are available on each
     * resource, has to be defined. A downscoped client can then be instantiated
     * using the source AuthClient and the Credential Access Boundary.
     * @param authClient The source AuthClient to be downscoped based on the
     *   provided Credential Access Boundary rules.
     * @param credentialAccessBoundary The Credential Access Boundary which
     *   contains a list of access boundary rules. Each rule contains information
     *   on the resource that the rule applies to, the upper bound of the
     *   permissions that are available on that resource and an optional
     *   condition to further restrict permissions.
     * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**
     *   Optional additional behavior customization options.
     * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**
     *   Optional quota project id for setting up in the x-goog-user-project header.
     */
    constructor(u, f, y, m) {
      if (super({ ...y, quotaProjectId: m }), this.authClient = u, this.credentialAccessBoundary = f, f.accessBoundary.accessBoundaryRules.length === 0)
        throw new Error("At least one access boundary rule needs to be defined.");
      if (f.accessBoundary.accessBoundaryRules.length > t.MAX_ACCESS_BOUNDARY_RULES_COUNT)
        throw new Error(`The provided access boundary has more than ${t.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
      for (const p of f.accessBoundary.accessBoundaryRules)
        if (p.availablePermissions.length === 0)
          throw new Error("At least one permission should be defined in access boundary rules.");
      this.stsCredential = new n.StsCredentials(`https://sts.${this.universeDomain}/v1/token`), this.cachedDownscopedAccessToken = null;
    }
    /**
     * Provides a mechanism to inject Downscoped access tokens directly.
     * The expiry_date field is required to facilitate determination of the token
     * expiration which would make it easier for the token consumer to handle.
     * @param credentials The Credentials object to set on the current client.
     */
    setCredentials(u) {
      if (!u.expiry_date)
        throw new Error("The access token expiry_date field is missing in the provided credentials.");
      super.setCredentials(u), this.cachedDownscopedAccessToken = u;
    }
    async getAccessToken() {
      return (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) && await this.refreshAccessTokenAsync(), {
        token: this.cachedDownscopedAccessToken.access_token,
        expirationTime: this.cachedDownscopedAccessToken.expiry_date,
        res: this.cachedDownscopedAccessToken.res
      };
    }
    /**
     * The main authentication interface. It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * The result has the form:
     * { Authorization: 'Bearer <access_token_value>' }
     */
    async getRequestHeaders() {
      const f = {
        Authorization: `Bearer ${(await this.getAccessToken()).token}`
      };
      return this.addSharedMetadataHeaders(f);
    }
    request(u, f) {
      if (f)
        this.requestAsync(u).then((y) => f(null, y), (y) => f(y, y.response));
      else
        return this.requestAsync(u);
    }
    /**
     * Authenticates the provided HTTP request, processes it and resolves with the
     * returned response.
     * @param opts The HTTP request options.
     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
     * @return A promise that resolves with the successful response.
     */
    async requestAsync(u, f = !1) {
      let y;
      try {
        const m = await this.getRequestHeaders();
        u.headers = u.headers || {}, m && m["x-goog-user-project"] && (u.headers["x-goog-user-project"] = m["x-goog-user-project"]), m && m.Authorization && (u.headers.Authorization = m.Authorization), y = await this.transporter.request(u);
      } catch (m) {
        const p = m.response;
        if (p) {
          const S = p.status, A = p.config.data instanceof e.Readable;
          if (!f && (S === 401 || S === 403) && !A && this.forceRefreshOnFailure)
            return await this.refreshAccessTokenAsync(), await this.requestAsync(u, !0);
        }
        throw m;
      }
      return y;
    }
    /**
     * Forces token refresh, even if unexpired tokens are currently cached.
     * GCP access tokens are retrieved from authclient object/source credential.
     * Then GCP access tokens are exchanged for downscoped access tokens via the
     * token exchange endpoint.
     * @return A promise that resolves with the fresh downscoped access token.
     */
    async refreshAccessTokenAsync() {
      var u;
      const f = (await this.authClient.getAccessToken()).token, y = {
        grantType: i,
        requestedTokenType: a,
        subjectToken: f,
        subjectTokenType: s
      }, m = await this.stsCredential.exchangeToken(y, void 0, this.credentialAccessBoundary), p = ((u = this.authClient.credentials) === null || u === void 0 ? void 0 : u.expiry_date) || null, S = m.expires_in ? (/* @__PURE__ */ new Date()).getTime() + m.expires_in * 1e3 : p;
      return this.cachedDownscopedAccessToken = {
        access_token: m.access_token,
        expiry_date: S,
        res: m.res
      }, this.credentials = {}, Object.assign(this.credentials, this.cachedDownscopedAccessToken), delete this.credentials.res, this.emit("tokens", {
        refresh_token: null,
        expiry_date: this.cachedDownscopedAccessToken.expiry_date,
        access_token: this.cachedDownscopedAccessToken.access_token,
        token_type: "Bearer",
        id_token: null
      }), this.cachedDownscopedAccessToken;
    }
    /**
     * Returns whether the provided credentials are expired or not.
     * If there is no expiry time, assumes the token is not expired or expiring.
     * @param downscopedAccessToken The credentials to check for expiration.
     * @return Whether the credentials are expired or not.
     */
    isExpired(u) {
      const f = (/* @__PURE__ */ new Date()).getTime();
      return u.expiry_date ? f >= u.expiry_date - this.eagerRefreshThresholdMillis : !1;
    }
  }
  t.DownscopedClient = o;
})(dy);
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.PassThroughClient = void 0;
const CI = qr;
class hy extends CI.AuthClient {
  /**
   * Creates a request without any authentication headers or checks.
   *
   * @remarks
   *
   * In testing environments it may be useful to change the provided
   * {@link AuthClient.transporter} for any desired request overrides/handling.
   *
   * @param opts
   * @returns The response of the request.
   */
  async request(e) {
    return this.transporter.request(e);
  }
  /**
   * A required method of the base class.
   * Always will return an empty object.
   *
   * @returns {}
   */
  async getAccessToken() {
    return {};
  }
  /**
   * A required method of the base class.
   * Always will return an empty object.
   *
   * @returns {}
   */
  async getRequestHeaders() {
    return {};
  }
}
Lo.PassThroughClient = hy;
const _I = new hy();
_I.getAccessToken();
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.GoogleAuth = t.auth = t.DefaultTransporter = t.PassThroughClient = t.ExecutableError = t.PluggableAuthClient = t.DownscopedClient = t.BaseExternalAccountClient = t.ExternalAccountClient = t.IdentityPoolClient = t.AwsRequestSigner = t.AwsClient = t.UserRefreshClient = t.LoginTicket = t.ClientAuthentication = t.OAuth2Client = t.CodeChallengeMethod = t.Impersonated = t.JWT = t.JWTAccess = t.IdTokenClient = t.IAMAuth = t.GCPEnv = t.Compute = t.DEFAULT_UNIVERSE = t.AuthClient = t.gaxios = t.gcpMetadata = void 0;
  const e = ng;
  Object.defineProperty(t, "GoogleAuth", { enumerable: !0, get: function() {
    return e.GoogleAuth;
  } }), t.gcpMetadata = ya, t.gaxios = Lr;
  var r = qr;
  Object.defineProperty(t, "AuthClient", { enumerable: !0, get: function() {
    return r.AuthClient;
  } }), Object.defineProperty(t, "DEFAULT_UNIVERSE", { enumerable: !0, get: function() {
    return r.DEFAULT_UNIVERSE;
  } });
  var n = Aa;
  Object.defineProperty(t, "Compute", { enumerable: !0, get: function() {
    return n.Compute;
  } });
  var i = ti;
  Object.defineProperty(t, "GCPEnv", { enumerable: !0, get: function() {
    return i.GCPEnv;
  } });
  var a = Do;
  Object.defineProperty(t, "IAMAuth", { enumerable: !0, get: function() {
    return a.IAMAuth;
  } });
  var s = _a;
  Object.defineProperty(t, "IdTokenClient", { enumerable: !0, get: function() {
    return s.IdTokenClient;
  } });
  var o = ba;
  Object.defineProperty(t, "JWTAccess", { enumerable: !0, get: function() {
    return o.JWTAccess;
  } });
  var l = Sa;
  Object.defineProperty(t, "JWT", { enumerable: !0, get: function() {
    return l.JWT;
  } });
  var u = jn;
  Object.defineProperty(t, "Impersonated", { enumerable: !0, get: function() {
    return u.Impersonated;
  } });
  var f = qt;
  Object.defineProperty(t, "CodeChallengeMethod", { enumerable: !0, get: function() {
    return f.CodeChallengeMethod;
  } }), Object.defineProperty(t, "OAuth2Client", { enumerable: !0, get: function() {
    return f.OAuth2Client;
  } }), Object.defineProperty(t, "ClientAuthentication", { enumerable: !0, get: function() {
    return f.ClientAuthentication;
  } });
  var y = Ca;
  Object.defineProperty(t, "LoginTicket", { enumerable: !0, get: function() {
    return y.LoginTicket;
  } });
  var m = Gn;
  Object.defineProperty(t, "UserRefreshClient", { enumerable: !0, get: function() {
    return m.UserRefreshClient;
  } });
  var p = Na;
  Object.defineProperty(t, "AwsClient", { enumerable: !0, get: function() {
    return p.AwsClient;
  } });
  var S = xa;
  Object.defineProperty(t, "AwsRequestSigner", { enumerable: !0, get: function() {
    return S.AwsRequestSigner;
  } });
  var A = Ra;
  Object.defineProperty(t, "IdentityPoolClient", { enumerable: !0, get: function() {
    return A.IdentityPoolClient;
  } });
  var I = wa;
  Object.defineProperty(t, "ExternalAccountClient", { enumerable: !0, get: function() {
    return I.ExternalAccountClient;
  } });
  var c = Rn;
  Object.defineProperty(t, "BaseExternalAccountClient", { enumerable: !0, get: function() {
    return c.BaseExternalAccountClient;
  } });
  var E = dy;
  Object.defineProperty(t, "DownscopedClient", { enumerable: !0, get: function() {
    return E.DownscopedClient;
  } });
  var v = pf();
  Object.defineProperty(t, "PluggableAuthClient", { enumerable: !0, get: function() {
    return v.PluggableAuthClient;
  } }), Object.defineProperty(t, "ExecutableError", { enumerable: !0, get: function() {
    return v.ExecutableError;
  } });
  var R = Lo;
  Object.defineProperty(t, "PassThroughClient", { enumerable: !0, get: function() {
    return R.PassThroughClient;
  } });
  var N = ei;
  Object.defineProperty(t, "DefaultTransporter", { enumerable: !0, get: function() {
    return N.DefaultTransporter;
  } });
  const C = new e.GoogleAuth();
  t.auth = C;
})(rg);
var Te = {}, vr = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.deepCopy = SI;
vr.deepExtend = yf;
function SI(t) {
  return yf(void 0, t);
}
function yf(t, e) {
  if (!(e instanceof Object))
    return e;
  switch (e.constructor) {
    case Date: {
      const r = e;
      return new Date(r.getTime());
    }
    case Object:
      t === void 0 && (t = {});
      break;
    case Array:
      t = [];
      break;
    default:
      return e;
  }
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = yf(t[r], e[r]));
  return t;
}
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Te, "__esModule", { value: !0 });
Te.InstanceIdClientErrorCode = Te.InstallationsClientErrorCode = Te.MessagingClientErrorCode = Te.AuthClientErrorCode = Te.AppErrorCodes = Te.FirebaseProjectManagementError = Te.FirebaseMessagingSessionError = Te.FirebaseMessagingError = Te.FirebaseInstallationsError = Te.FirebaseInstanceIdError = Te.FirebaseFirestoreError = Te.FirebaseDatabaseError = Te.FirebaseAuthError = Te.FirebaseAppError = Te.PrefixedFirebaseError = Te.FirebaseError = void 0;
const Ol = vr;
let Fi = class py extends Error {
  /**
   * @param errorInfo - The error information (code and message).
   * @constructor
   * @internal
   */
  constructor(e) {
    super(e.message), this.errorInfo = e, this.__proto__ = py.prototype;
  }
  /** @returns The error code. */
  get code() {
    var e;
    return (e = this.errorInfo) == null ? void 0 : e.code;
  }
  /** @returns The error message. */
  get message() {
    var e;
    return (e = this.errorInfo) == null ? void 0 : e.message;
  }
  /** @returns The object representation of the error. */
  toJSON() {
    return {
      code: this.code,
      message: this.message
    };
  }
};
Te.FirebaseError = Fi;
class ri extends Fi {
  /**
   * @param codePrefix - The prefix to apply to the error code.
   * @param code - The error code.
   * @param message - The error message.
   * @constructor
   * @internal
   */
  constructor(e, r, n) {
    super({
      code: `${e}/${r}`,
      message: n
    }), this.codePrefix = e, this.__proto__ = ri.prototype;
  }
  /**
   * Allows the error type to be checked without needing to know implementation details
   * of the code prefixing.
   *
   * @param code - The non-prefixed error code to test against.
   * @returns True if the code matches, false otherwise.
   */
  hasCode(e) {
    return `${this.codePrefix}/${e}` === this.code;
  }
}
Te.PrefixedFirebaseError = ri;
class mf extends ri {
  /**
   * @param code - The error code.
   * @param message - The error message.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super("app", e, r), this.__proto__ = mf.prototype;
  }
}
Te.FirebaseAppError = mf;
class xs extends ri {
  /**
   * Creates the developer-facing error corresponding to the backend error code.
   *
   * @param serverErrorCode - The server error code.
   * @param [message] The error message. The default message is used
   *     if not provided.
   * @param [rawServerResponse] The error's raw server response.
   * @returns The corresponding developer-facing error.
   * @internal
   */
  static fromServerError(e, r, n) {
    const i = (e || "").indexOf(":");
    let a = null;
    i !== -1 && (a = e.substring(i + 1).trim(), e = e.substring(0, i).trim());
    const s = wI[e] || "INTERNAL_ERROR", o = (0, Ol.deepCopy)(de[s]);
    if (o.message = a || r || o.message, s === "INTERNAL_ERROR" && typeof n < "u")
      try {
        o.message += ` Raw server response: "${JSON.stringify(n)}"`;
      } catch {
      }
    return new xs(o);
  }
  /**
   * @param info - The error code info.
   * @param message - The error message. This will override the default message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super("auth", e.code, r || e.message), this.__proto__ = xs.prototype;
  }
}
Te.FirebaseAuthError = xs;
class II extends Fi {
  /**
   * @param info - The error code info.
   * @param message - The error message. This will override the default
   *     message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super({ code: "database/" + e.code, message: r || e.message });
  }
}
Te.FirebaseDatabaseError = II;
class bI extends Fi {
  /**
   * @param info - The error code info.
   * @param message - The error message. This will override the default
   *     message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super({ code: "firestore/" + e.code, message: r || e.message });
  }
}
Te.FirebaseFirestoreError = bI;
class Ef extends Fi {
  /**
   *
   * @param info - The error code info.
   * @param message - The error message. This will override the default
   *     message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super({ code: "instance-id/" + e.code, message: r || e.message }), this.__proto__ = Ef.prototype;
  }
}
Te.FirebaseInstanceIdError = Ef;
class vf extends Fi {
  /**
   *
   * @param info - The error code info.
   * @param message - The error message. This will override the default
   *     message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super({ code: "installations/" + e.code, message: r || e.message }), this.__proto__ = vf.prototype;
  }
}
Te.FirebaseInstallationsError = vf;
class bi extends ri {
  /**
   * Creates the developer-facing error corresponding to the backend error code.
   *
   * @param serverErrorCode - The server error code.
   * @param [message] The error message. The default message is used
   *     if not provided.
   * @param [rawServerResponse] The error's raw server response.
   * @returns The corresponding developer-facing error.
   * @internal
   */
  static fromServerError(e, r, n) {
    let i = "UNKNOWN_ERROR";
    e && e in Ph && (i = Ph[e]);
    const a = (0, Ol.deepCopy)(ot[i]);
    if (a.message = r || a.message, i === "UNKNOWN_ERROR" && typeof n < "u")
      try {
        a.message += ` Raw server response: "${JSON.stringify(n)}"`;
      } catch {
      }
    return new bi(a);
  }
  /**
   * @internal
   */
  static fromTopicManagementServerError(e, r, n) {
    const i = TI[e] || "UNKNOWN_ERROR", a = (0, Ol.deepCopy)(ot[i]);
    if (a.message = r || a.message, i === "UNKNOWN_ERROR" && typeof n < "u")
      try {
        a.message += ` Raw server response: "${JSON.stringify(n)}"`;
      } catch {
      }
    return new bi(a);
  }
  /**
   *
   * @param info - The error code info.
   * @param message - The error message. This will override the default message if provided.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super("messaging", e.code, r || e.message), this.__proto__ = bi.prototype;
  }
}
Te.FirebaseMessagingError = bi;
class Af extends bi {
  /**
     *
     * @param info - The error code info.
     * @param message - The error message. This will override the default message if provided.
     * @param pendingBatchResponse - BatchResponse for pending messages when session error occured.
     * @constructor
     * @internal
     */
  constructor(e, r, n) {
    super(e, r || e.message), this.pendingBatchResponse = n, this.__proto__ = Af.prototype;
  }
  /** @returns The object representation of the error. */
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      pendingBatchResponse: this.pendingBatchResponse
    };
  }
}
Te.FirebaseMessagingSessionError = Af;
class Cf extends ri {
  /**
   * @param code - The error code.
   * @param message - The error message.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super("project-management", e, r), this.__proto__ = Cf.prototype;
  }
}
Te.FirebaseProjectManagementError = Cf;
class Ar {
}
Te.AppErrorCodes = Ar;
Ar.APP_DELETED = "app-deleted";
Ar.DUPLICATE_APP = "duplicate-app";
Ar.INVALID_ARGUMENT = "invalid-argument";
Ar.INTERNAL_ERROR = "internal-error";
Ar.INVALID_APP_NAME = "invalid-app-name";
Ar.INVALID_APP_OPTIONS = "invalid-app-options";
Ar.INVALID_CREDENTIAL = "invalid-credential";
Ar.NETWORK_ERROR = "network-error";
Ar.NETWORK_TIMEOUT = "network-timeout";
Ar.NO_APP = "no-app";
Ar.UNABLE_TO_PARSE_RESPONSE = "unable-to-parse-response";
class de {
}
Te.AuthClientErrorCode = de;
de.AUTH_BLOCKING_TOKEN_EXPIRED = {
  code: "auth-blocking-token-expired",
  message: "The provided Firebase Auth Blocking token is expired."
};
de.BILLING_NOT_ENABLED = {
  code: "billing-not-enabled",
  message: "Feature requires billing to be enabled."
};
de.CLAIMS_TOO_LARGE = {
  code: "claims-too-large",
  message: "Developer claims maximum payload size exceeded."
};
de.CONFIGURATION_EXISTS = {
  code: "configuration-exists",
  message: "A configuration already exists with the provided identifier."
};
de.CONFIGURATION_NOT_FOUND = {
  code: "configuration-not-found",
  message: "There is no configuration corresponding to the provided identifier."
};
de.ID_TOKEN_EXPIRED = {
  code: "id-token-expired",
  message: "The provided Firebase ID token is expired."
};
de.INVALID_ARGUMENT = {
  code: "argument-error",
  message: "Invalid argument provided."
};
de.INVALID_CONFIG = {
  code: "invalid-config",
  message: "The provided configuration is invalid."
};
de.EMAIL_ALREADY_EXISTS = {
  code: "email-already-exists",
  message: "The email address is already in use by another account."
};
de.EMAIL_NOT_FOUND = {
  code: "email-not-found",
  message: "There is no user record corresponding to the provided email."
};
de.FORBIDDEN_CLAIM = {
  code: "reserved-claim",
  message: "The specified developer claim is reserved and cannot be specified."
};
de.INVALID_ID_TOKEN = {
  code: "invalid-id-token",
  message: "The provided ID token is not a valid Firebase ID token."
};
de.ID_TOKEN_REVOKED = {
  code: "id-token-revoked",
  message: "The Firebase ID token has been revoked."
};
de.INTERNAL_ERROR = {
  code: "internal-error",
  message: "An internal error has occurred."
};
de.INVALID_CLAIMS = {
  code: "invalid-claims",
  message: "The provided custom claim attributes are invalid."
};
de.INVALID_CONTINUE_URI = {
  code: "invalid-continue-uri",
  message: "The continue URL must be a valid URL string."
};
de.INVALID_CREATION_TIME = {
  code: "invalid-creation-time",
  message: "The creation time must be a valid UTC date string."
};
de.INVALID_CREDENTIAL = {
  code: "invalid-credential",
  message: "Invalid credential object provided."
};
de.INVALID_DISABLED_FIELD = {
  code: "invalid-disabled-field",
  message: "The disabled field must be a boolean."
};
de.INVALID_DISPLAY_NAME = {
  code: "invalid-display-name",
  message: "The displayName field must be a valid string."
};
de.INVALID_DYNAMIC_LINK_DOMAIN = {
  code: "invalid-dynamic-link-domain",
  message: "The provided dynamic link domain is not configured or authorized for the current project."
};
de.INVALID_HOSTING_LINK_DOMAIN = {
  code: "invalid-hosting-link-domain",
  message: "The provided hosting link domain is not configured in Firebase Hosting or is not owned by the current project."
};
de.INVALID_EMAIL_VERIFIED = {
  code: "invalid-email-verified",
  message: "The emailVerified field must be a boolean."
};
de.INVALID_EMAIL = {
  code: "invalid-email",
  message: "The email address is improperly formatted."
};
de.INVALID_NEW_EMAIL = {
  code: "invalid-new-email",
  message: "The new email address is improperly formatted."
};
de.INVALID_ENROLLED_FACTORS = {
  code: "invalid-enrolled-factors",
  message: "The enrolled factors must be a valid array of MultiFactorInfo objects."
};
de.INVALID_ENROLLMENT_TIME = {
  code: "invalid-enrollment-time",
  message: "The second factor enrollment time must be a valid UTC date string."
};
de.INVALID_HASH_ALGORITHM = {
  code: "invalid-hash-algorithm",
  message: "The hash algorithm must match one of the strings in the list of supported algorithms."
};
de.INVALID_HASH_BLOCK_SIZE = {
  code: "invalid-hash-block-size",
  message: "The hash block size must be a valid number."
};
de.INVALID_HASH_DERIVED_KEY_LENGTH = {
  code: "invalid-hash-derived-key-length",
  message: "The hash derived key length must be a valid number."
};
de.INVALID_HASH_KEY = {
  code: "invalid-hash-key",
  message: "The hash key must a valid byte buffer."
};
de.INVALID_HASH_MEMORY_COST = {
  code: "invalid-hash-memory-cost",
  message: "The hash memory cost must be a valid number."
};
de.INVALID_HASH_PARALLELIZATION = {
  code: "invalid-hash-parallelization",
  message: "The hash parallelization must be a valid number."
};
de.INVALID_HASH_ROUNDS = {
  code: "invalid-hash-rounds",
  message: "The hash rounds must be a valid number."
};
de.INVALID_HASH_SALT_SEPARATOR = {
  code: "invalid-hash-salt-separator",
  message: "The hashing algorithm salt separator field must be a valid byte buffer."
};
de.INVALID_LAST_SIGN_IN_TIME = {
  code: "invalid-last-sign-in-time",
  message: "The last sign-in time must be a valid UTC date string."
};
de.INVALID_NAME = {
  code: "invalid-name",
  message: "The resource name provided is invalid."
};
de.INVALID_OAUTH_CLIENT_ID = {
  code: "invalid-oauth-client-id",
  message: "The provided OAuth client ID is invalid."
};
de.INVALID_PAGE_TOKEN = {
  code: "invalid-page-token",
  message: "The page token must be a valid non-empty string."
};
de.INVALID_PASSWORD = {
  code: "invalid-password",
  message: "The password must be a string with at least 6 characters."
};
de.INVALID_PASSWORD_HASH = {
  code: "invalid-password-hash",
  message: "The password hash must be a valid byte buffer."
};
de.INVALID_PASSWORD_SALT = {
  code: "invalid-password-salt",
  message: "The password salt must be a valid byte buffer."
};
de.INVALID_PHONE_NUMBER = {
  code: "invalid-phone-number",
  message: "The phone number must be a non-empty E.164 standard compliant identifier string."
};
de.INVALID_PHOTO_URL = {
  code: "invalid-photo-url",
  message: "The photoURL field must be a valid URL."
};
de.INVALID_PROJECT_ID = {
  code: "invalid-project-id",
  message: "Invalid parent project. Either parent project doesn't exist or didn't enable multi-tenancy."
};
de.INVALID_PROVIDER_DATA = {
  code: "invalid-provider-data",
  message: "The providerData must be a valid array of UserInfo objects."
};
de.INVALID_PROVIDER_ID = {
  code: "invalid-provider-id",
  message: "The providerId must be a valid supported provider identifier string."
};
de.INVALID_PROVIDER_UID = {
  code: "invalid-provider-uid",
  message: "The providerUid must be a valid provider uid string."
};
de.INVALID_OAUTH_RESPONSETYPE = {
  code: "invalid-oauth-responsetype",
  message: "Only exactly one OAuth responseType should be set to true."
};
de.INVALID_SESSION_COOKIE_DURATION = {
  code: "invalid-session-cookie-duration",
  message: "The session cookie duration must be a valid number in milliseconds between 5 minutes and 2 weeks."
};
de.INVALID_TENANT_ID = {
  code: "invalid-tenant-id",
  message: "The tenant ID must be a valid non-empty string."
};
de.INVALID_TENANT_TYPE = {
  code: "invalid-tenant-type",
  message: 'Tenant type must be either "full_service" or "lightweight".'
};
de.INVALID_TESTING_PHONE_NUMBER = {
  code: "invalid-testing-phone-number",
  message: "Invalid testing phone number or invalid test code provided."
};
de.INVALID_UID = {
  code: "invalid-uid",
  message: "The uid must be a non-empty string with at most 128 characters."
};
de.INVALID_USER_IMPORT = {
  code: "invalid-user-import",
  message: "The user record to import is invalid."
};
de.INVALID_TOKENS_VALID_AFTER_TIME = {
  code: "invalid-tokens-valid-after-time",
  message: "The tokensValidAfterTime must be a valid UTC number in seconds."
};
de.MISMATCHING_TENANT_ID = {
  code: "mismatching-tenant-id",
  message: "User tenant ID does not match with the current TenantAwareAuth tenant ID."
};
de.MISSING_ANDROID_PACKAGE_NAME = {
  code: "missing-android-pkg-name",
  message: "An Android Package Name must be provided if the Android App is required to be installed."
};
de.MISSING_CONFIG = {
  code: "missing-config",
  message: "The provided configuration is missing required attributes."
};
de.MISSING_CONTINUE_URI = {
  code: "missing-continue-uri",
  message: "A valid continue URL must be provided in the request."
};
de.MISSING_DISPLAY_NAME = {
  code: "missing-display-name",
  message: "The resource being created or edited is missing a valid display name."
};
de.MISSING_EMAIL = {
  code: "missing-email",
  message: "The email is required for the specified action. For example, a multi-factor user requires a verified email."
};
de.MISSING_IOS_BUNDLE_ID = {
  code: "missing-ios-bundle-id",
  message: "The request is missing an iOS Bundle ID."
};
de.MISSING_ISSUER = {
  code: "missing-issuer",
  message: "The OAuth/OIDC configuration issuer must not be empty."
};
de.MISSING_HASH_ALGORITHM = {
  code: "missing-hash-algorithm",
  message: "Importing users with password hashes requires that the hashing algorithm and its parameters be provided."
};
de.MISSING_OAUTH_CLIENT_ID = {
  code: "missing-oauth-client-id",
  message: "The OAuth/OIDC configuration client ID must not be empty."
};
de.MISSING_OAUTH_CLIENT_SECRET = {
  code: "missing-oauth-client-secret",
  message: "The OAuth configuration client secret is required to enable OIDC code flow."
};
de.MISSING_PROVIDER_ID = {
  code: "missing-provider-id",
  message: "A valid provider ID must be provided in the request."
};
de.MISSING_SAML_RELYING_PARTY_CONFIG = {
  code: "missing-saml-relying-party-config",
  message: "The SAML configuration provided is missing a relying party configuration."
};
de.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED = {
  code: "test-phone-number-limit-exceeded",
  message: "The maximum allowed number of test phone number / code pairs has been exceeded."
};
de.MAXIMUM_USER_COUNT_EXCEEDED = {
  code: "maximum-user-count-exceeded",
  message: "The maximum allowed number of users to import has been exceeded."
};
de.MISSING_UID = {
  code: "missing-uid",
  message: "A uid identifier is required for the current operation."
};
de.OPERATION_NOT_ALLOWED = {
  code: "operation-not-allowed",
  message: "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section."
};
de.PHONE_NUMBER_ALREADY_EXISTS = {
  code: "phone-number-already-exists",
  message: "The user with the provided phone number already exists."
};
de.PROJECT_NOT_FOUND = {
  code: "project-not-found",
  message: "No Firebase project was found for the provided credential."
};
de.INSUFFICIENT_PERMISSION = {
  code: "insufficient-permission",
  message: 'Credential implementation provided to initializeApp() via the "credential" property has insufficient permission to access the requested resource. See https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK with appropriate permissions.'
};
de.QUOTA_EXCEEDED = {
  code: "quota-exceeded",
  message: "The project quota for the specified operation has been exceeded."
};
de.SECOND_FACTOR_LIMIT_EXCEEDED = {
  code: "second-factor-limit-exceeded",
  message: "The maximum number of allowed second factors on a user has been exceeded."
};
de.SECOND_FACTOR_UID_ALREADY_EXISTS = {
  code: "second-factor-uid-already-exists",
  message: 'The specified second factor "uid" already exists.'
};
de.SESSION_COOKIE_EXPIRED = {
  code: "session-cookie-expired",
  message: "The Firebase session cookie is expired."
};
de.SESSION_COOKIE_REVOKED = {
  code: "session-cookie-revoked",
  message: "The Firebase session cookie has been revoked."
};
de.TENANT_NOT_FOUND = {
  code: "tenant-not-found",
  message: "There is no tenant corresponding to the provided identifier."
};
de.UID_ALREADY_EXISTS = {
  code: "uid-already-exists",
  message: "The user with the provided uid already exists."
};
de.UNAUTHORIZED_DOMAIN = {
  code: "unauthorized-continue-uri",
  message: "The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console."
};
de.UNSUPPORTED_FIRST_FACTOR = {
  code: "unsupported-first-factor",
  message: "A multi-factor user requires a supported first factor."
};
de.UNSUPPORTED_SECOND_FACTOR = {
  code: "unsupported-second-factor",
  message: "The request specified an unsupported type of second factor."
};
de.UNSUPPORTED_TENANT_OPERATION = {
  code: "unsupported-tenant-operation",
  message: "This operation is not supported in a multi-tenant context."
};
de.UNVERIFIED_EMAIL = {
  code: "unverified-email",
  message: "A verified email is required for the specified action. For example, a multi-factor user requires a verified email."
};
de.USER_NOT_FOUND = {
  code: "user-not-found",
  message: "There is no user record corresponding to the provided identifier."
};
de.NOT_FOUND = {
  code: "not-found",
  message: "The requested resource was not found."
};
de.USER_DISABLED = {
  code: "user-disabled",
  message: "The user record is disabled."
};
de.USER_NOT_DISABLED = {
  code: "user-not-disabled",
  message: "The user must be disabled in order to bulk delete it (or you must pass force=true)."
};
de.INVALID_RECAPTCHA_ACTION = {
  code: "invalid-recaptcha-action",
  message: 'reCAPTCHA action must be "BLOCK".'
};
de.INVALID_RECAPTCHA_ENFORCEMENT_STATE = {
  code: "invalid-recaptcha-enforcement-state",
  message: 'reCAPTCHA enforcement state must be either "OFF", "AUDIT" or "ENFORCE".'
};
de.RECAPTCHA_NOT_ENABLED = {
  code: "racaptcha-not-enabled",
  message: "reCAPTCHA enterprise is not enabled."
};
class ot {
}
Te.MessagingClientErrorCode = ot;
ot.INVALID_ARGUMENT = {
  code: "invalid-argument",
  message: "Invalid argument provided."
};
ot.INVALID_RECIPIENT = {
  code: "invalid-recipient",
  message: "Invalid message recipient provided."
};
ot.INVALID_PAYLOAD = {
  code: "invalid-payload",
  message: "Invalid message payload provided."
};
ot.INVALID_DATA_PAYLOAD_KEY = {
  code: "invalid-data-payload-key",
  message: "The data message payload contains an invalid key. See the reference documentation for the DataMessagePayload type for restricted keys."
};
ot.PAYLOAD_SIZE_LIMIT_EXCEEDED = {
  code: "payload-size-limit-exceeded",
  message: "The provided message payload exceeds the FCM size limits. See the error documentation for more details."
};
ot.INVALID_OPTIONS = {
  code: "invalid-options",
  message: "Invalid message options provided."
};
ot.INVALID_REGISTRATION_TOKEN = {
  code: "invalid-registration-token",
  message: "Invalid registration token provided. Make sure it matches the registration token the client app receives from registering with FCM."
};
ot.REGISTRATION_TOKEN_NOT_REGISTERED = {
  code: "registration-token-not-registered",
  message: "The provided registration token is not registered. A previously valid registration token can be unregistered for a variety of reasons. See the error documentation for more details. Remove this registration token and stop using it to send messages."
};
ot.MISMATCHED_CREDENTIAL = {
  code: "mismatched-credential",
  message: "The credential used to authenticate this SDK does not have permission to send messages to the device corresponding to the provided registration token. Make sure the credential and registration token both belong to the same Firebase project."
};
ot.INVALID_PACKAGE_NAME = {
  code: "invalid-package-name",
  message: 'The message was addressed to a registration token whose package name does not match the provided "restrictedPackageName" option.'
};
ot.DEVICE_MESSAGE_RATE_EXCEEDED = {
  code: "device-message-rate-exceeded",
  message: "The rate of messages to a particular device is too high. Reduce the number of messages sent to this device and do not immediately retry sending to this device."
};
ot.TOPICS_MESSAGE_RATE_EXCEEDED = {
  code: "topics-message-rate-exceeded",
  message: "The rate of messages to subscribers to a particular topic is too high. Reduce the number of messages sent for this topic, and do not immediately retry sending to this topic."
};
ot.MESSAGE_RATE_EXCEEDED = {
  code: "message-rate-exceeded",
  message: "Sending limit exceeded for the message target."
};
ot.THIRD_PARTY_AUTH_ERROR = {
  code: "third-party-auth-error",
  message: "A message targeted to an iOS device could not be sent because the required APNs SSL certificate was not uploaded or has expired. Check the validity of your development and production certificates."
};
ot.TOO_MANY_TOPICS = {
  code: "too-many-topics",
  message: "The maximum number of topics the provided registration token can be subscribed to has been exceeded."
};
ot.AUTHENTICATION_ERROR = {
  code: "authentication-error",
  message: "An error occurred when trying to authenticate to the FCM servers. Make sure the credential used to authenticate this SDK has the proper permissions. See https://firebase.google.com/docs/admin/setup for setup instructions."
};
ot.SERVER_UNAVAILABLE = {
  code: "server-unavailable",
  message: "The FCM server could not process the request in time. See the error documentation for more details."
};
ot.INTERNAL_ERROR = {
  code: "internal-error",
  message: "An internal error has occurred. Please retry the request."
};
ot.UNKNOWN_ERROR = {
  code: "unknown-error",
  message: "An unknown server error was returned."
};
class Mi {
}
Te.InstallationsClientErrorCode = Mi;
Mi.INVALID_ARGUMENT = {
  code: "invalid-argument",
  message: "Invalid argument provided."
};
Mi.INVALID_PROJECT_ID = {
  code: "invalid-project-id",
  message: "Invalid project ID provided."
};
Mi.INVALID_INSTALLATION_ID = {
  code: "invalid-installation-id",
  message: "Invalid installation ID provided."
};
Mi.API_ERROR = {
  code: "api-error",
  message: "Installation ID API call failed."
};
class gy extends Mi {
}
Te.InstanceIdClientErrorCode = gy;
gy.INVALID_INSTANCE_ID = {
  code: "invalid-instance-id",
  message: "Invalid instance ID provided."
};
const wI = {
  // Feature being configured or used requires a billing account.
  BILLING_NOT_ENABLED: "BILLING_NOT_ENABLED",
  // Claims payload is too large.
  CLAIMS_TOO_LARGE: "CLAIMS_TOO_LARGE",
  // Configuration being added already exists.
  CONFIGURATION_EXISTS: "CONFIGURATION_EXISTS",
  // Configuration not found.
  CONFIGURATION_NOT_FOUND: "CONFIGURATION_NOT_FOUND",
  // Provided credential has insufficient permissions.
  INSUFFICIENT_PERMISSION: "INSUFFICIENT_PERMISSION",
  // Provided configuration has invalid fields.
  INVALID_CONFIG: "INVALID_CONFIG",
  // Provided configuration identifier is invalid.
  INVALID_CONFIG_ID: "INVALID_PROVIDER_ID",
  // ActionCodeSettings missing continue URL.
  INVALID_CONTINUE_URI: "INVALID_CONTINUE_URI",
  // Dynamic link domain in provided ActionCodeSettings is not authorized.
  INVALID_DYNAMIC_LINK_DOMAIN: "INVALID_DYNAMIC_LINK_DOMAIN",
  // Hosting link domain in provided ActionCodeSettings is not owned by the current project.
  INVALID_HOSTING_LINK_DOMAIN: "INVALID_HOSTING_LINK_DOMAIN",
  // uploadAccount provides an email that already exists.
  DUPLICATE_EMAIL: "EMAIL_ALREADY_EXISTS",
  // uploadAccount provides a localId that already exists.
  DUPLICATE_LOCAL_ID: "UID_ALREADY_EXISTS",
  // Request specified a multi-factor enrollment ID that already exists.
  DUPLICATE_MFA_ENROLLMENT_ID: "SECOND_FACTOR_UID_ALREADY_EXISTS",
  // setAccountInfo email already exists.
  EMAIL_EXISTS: "EMAIL_ALREADY_EXISTS",
  // /accounts:sendOobCode for password reset when user is not found.
  EMAIL_NOT_FOUND: "EMAIL_NOT_FOUND",
  // Reserved claim name.
  FORBIDDEN_CLAIM: "FORBIDDEN_CLAIM",
  // Invalid claims provided.
  INVALID_CLAIMS: "INVALID_CLAIMS",
  // Invalid session cookie duration.
  INVALID_DURATION: "INVALID_SESSION_COOKIE_DURATION",
  // Invalid email provided.
  INVALID_EMAIL: "INVALID_EMAIL",
  // Invalid new email provided.
  INVALID_NEW_EMAIL: "INVALID_NEW_EMAIL",
  // Invalid tenant display name. This can be thrown on CreateTenant and UpdateTenant.
  INVALID_DISPLAY_NAME: "INVALID_DISPLAY_NAME",
  // Invalid ID token provided.
  INVALID_ID_TOKEN: "INVALID_ID_TOKEN",
  // Invalid tenant/parent resource name.
  INVALID_NAME: "INVALID_NAME",
  // OIDC configuration has an invalid OAuth client ID.
  INVALID_OAUTH_CLIENT_ID: "INVALID_OAUTH_CLIENT_ID",
  // Invalid page token.
  INVALID_PAGE_SELECTION: "INVALID_PAGE_TOKEN",
  // Invalid phone number.
  INVALID_PHONE_NUMBER: "INVALID_PHONE_NUMBER",
  // Invalid agent project. Either agent project doesn't exist or didn't enable multi-tenancy.
  INVALID_PROJECT_ID: "INVALID_PROJECT_ID",
  // Invalid provider ID.
  INVALID_PROVIDER_ID: "INVALID_PROVIDER_ID",
  // Invalid service account.
  INVALID_SERVICE_ACCOUNT: "INVALID_SERVICE_ACCOUNT",
  // Invalid testing phone number.
  INVALID_TESTING_PHONE_NUMBER: "INVALID_TESTING_PHONE_NUMBER",
  // Invalid tenant type.
  INVALID_TENANT_TYPE: "INVALID_TENANT_TYPE",
  // Missing Android package name.
  MISSING_ANDROID_PACKAGE_NAME: "MISSING_ANDROID_PACKAGE_NAME",
  // Missing configuration.
  MISSING_CONFIG: "MISSING_CONFIG",
  // Missing configuration identifier.
  MISSING_CONFIG_ID: "MISSING_PROVIDER_ID",
  // Missing tenant display name: This can be thrown on CreateTenant and UpdateTenant.
  MISSING_DISPLAY_NAME: "MISSING_DISPLAY_NAME",
  // Email is required for the specified action. For example a multi-factor user requires
  // a verified email.
  MISSING_EMAIL: "MISSING_EMAIL",
  // Missing iOS bundle ID.
  MISSING_IOS_BUNDLE_ID: "MISSING_IOS_BUNDLE_ID",
  // Missing OIDC issuer.
  MISSING_ISSUER: "MISSING_ISSUER",
  // No localId provided (deleteAccount missing localId).
  MISSING_LOCAL_ID: "MISSING_UID",
  // OIDC configuration is missing an OAuth client ID.
  MISSING_OAUTH_CLIENT_ID: "MISSING_OAUTH_CLIENT_ID",
  // Missing provider ID.
  MISSING_PROVIDER_ID: "MISSING_PROVIDER_ID",
  // Missing SAML RP config.
  MISSING_SAML_RELYING_PARTY_CONFIG: "MISSING_SAML_RELYING_PARTY_CONFIG",
  // Empty user list in uploadAccount.
  MISSING_USER_ACCOUNT: "MISSING_UID",
  // Password auth disabled in console.
  OPERATION_NOT_ALLOWED: "OPERATION_NOT_ALLOWED",
  // Provided credential has insufficient permissions.
  PERMISSION_DENIED: "INSUFFICIENT_PERMISSION",
  // Phone number already exists.
  PHONE_NUMBER_EXISTS: "PHONE_NUMBER_ALREADY_EXISTS",
  // Project not found.
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  // In multi-tenancy context: project creation quota exceeded.
  QUOTA_EXCEEDED: "QUOTA_EXCEEDED",
  // Currently only 5 second factors can be set on the same user.
  SECOND_FACTOR_LIMIT_EXCEEDED: "SECOND_FACTOR_LIMIT_EXCEEDED",
  // Tenant not found.
  TENANT_NOT_FOUND: "TENANT_NOT_FOUND",
  // Tenant ID mismatch.
  TENANT_ID_MISMATCH: "MISMATCHING_TENANT_ID",
  // Token expired error.
  TOKEN_EXPIRED: "ID_TOKEN_EXPIRED",
  // Continue URL provided in ActionCodeSettings has a domain that is not whitelisted.
  UNAUTHORIZED_DOMAIN: "UNAUTHORIZED_DOMAIN",
  // A multi-factor user requires a supported first factor.
  UNSUPPORTED_FIRST_FACTOR: "UNSUPPORTED_FIRST_FACTOR",
  // The request specified an unsupported type of second factor.
  UNSUPPORTED_SECOND_FACTOR: "UNSUPPORTED_SECOND_FACTOR",
  // Operation is not supported in a multi-tenant context.
  UNSUPPORTED_TENANT_OPERATION: "UNSUPPORTED_TENANT_OPERATION",
  // A verified email is required for the specified action. For example a multi-factor user
  // requires a verified email.
  UNVERIFIED_EMAIL: "UNVERIFIED_EMAIL",
  // User on which action is to be performed is not found.
  USER_NOT_FOUND: "USER_NOT_FOUND",
  // User record is disabled.
  USER_DISABLED: "USER_DISABLED",
  // Password provided is too weak.
  WEAK_PASSWORD: "INVALID_PASSWORD",
  // Unrecognized reCAPTCHA action.
  INVALID_RECAPTCHA_ACTION: "INVALID_RECAPTCHA_ACTION",
  // Unrecognized reCAPTCHA enforcement state.
  INVALID_RECAPTCHA_ENFORCEMENT_STATE: "INVALID_RECAPTCHA_ENFORCEMENT_STATE",
  // reCAPTCHA is not enabled for account defender.
  RECAPTCHA_NOT_ENABLED: "RECAPTCHA_NOT_ENABLED"
}, Ph = {
  /* GENERIC ERRORS */
  // Generic invalid message parameter provided.
  InvalidParameters: "INVALID_ARGUMENT",
  // Mismatched sender ID.
  MismatchSenderId: "MISMATCHED_CREDENTIAL",
  // FCM server unavailable.
  Unavailable: "SERVER_UNAVAILABLE",
  // FCM server internal error.
  InternalServerError: "INTERNAL_ERROR",
  /* SEND ERRORS */
  // Invalid registration token format.
  InvalidRegistration: "INVALID_REGISTRATION_TOKEN",
  // Registration token is not registered.
  NotRegistered: "REGISTRATION_TOKEN_NOT_REGISTERED",
  // Registration token does not match restricted package name.
  InvalidPackageName: "INVALID_PACKAGE_NAME",
  // Message payload size limit exceeded.
  MessageTooBig: "PAYLOAD_SIZE_LIMIT_EXCEEDED",
  // Invalid key in the data message payload.
  InvalidDataKey: "INVALID_DATA_PAYLOAD_KEY",
  // Invalid time to live option.
  InvalidTtl: "INVALID_OPTIONS",
  // Device message rate exceeded.
  DeviceMessageRateExceeded: "DEVICE_MESSAGE_RATE_EXCEEDED",
  // Topics message rate exceeded.
  TopicsMessageRateExceeded: "TOPICS_MESSAGE_RATE_EXCEEDED",
  // Invalid APNs credentials.
  InvalidApnsCredential: "THIRD_PARTY_AUTH_ERROR",
  /* FCM v1 canonical error codes */
  NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
  PERMISSION_DENIED: "MISMATCHED_CREDENTIAL",
  RESOURCE_EXHAUSTED: "MESSAGE_RATE_EXCEEDED",
  UNAUTHENTICATED: "THIRD_PARTY_AUTH_ERROR",
  /* FCM v1 new error codes */
  APNS_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
  INTERNAL: "INTERNAL_ERROR",
  INVALID_ARGUMENT: "INVALID_ARGUMENT",
  QUOTA_EXCEEDED: "MESSAGE_RATE_EXCEEDED",
  SENDER_ID_MISMATCH: "MISMATCHED_CREDENTIAL",
  THIRD_PARTY_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
  UNAVAILABLE: "SERVER_UNAVAILABLE",
  UNREGISTERED: "REGISTRATION_TOKEN_NOT_REGISTERED",
  UNSPECIFIED_ERROR: "UNKNOWN_ERROR"
}, TI = {
  /* TOPIC SUBSCRIPTION MANAGEMENT ERRORS */
  NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
  INVALID_ARGUMENT: "INVALID_REGISTRATION_TOKEN",
  TOO_MANY_TOPICS: "TOO_MANY_TOPICS",
  RESOURCE_EXHAUSTED: "TOO_MANY_TOPICS",
  PERMISSION_DENIED: "AUTHENTICATION_ERROR",
  DEADLINE_EXCEEDED: "SERVER_UNAVAILABLE",
  INTERNAL: "INTERNAL_ERROR",
  UNKNOWN: "UNKNOWN_ERROR"
};
var Ue = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.isBuffer = NI;
Ue.isArray = _f;
Ue.isNonEmptyArray = xI;
Ue.isBoolean = OI;
Ue.isNumber = DI;
Ue.isString = Sf;
Ue.isBase64String = LI;
Ue.isNonEmptyString = If;
Ue.isObject = yy;
Ue.isNonNullObject = PI;
Ue.isUid = kI;
Ue.isPassword = BI;
Ue.isEmail = UI;
Ue.isPhoneNumber = FI;
Ue.isISODateString = MI;
Ue.isUTCDateString = VI;
Ue.isURL = $I;
Ue.isTopic = HI;
Ue.isTaskId = KI;
const RI = ge;
function NI(t) {
  return t instanceof Buffer;
}
function _f(t) {
  return Array.isArray(t);
}
function xI(t) {
  return _f(t) && t.length !== 0;
}
function OI(t) {
  return typeof t == "boolean";
}
function DI(t) {
  return typeof t == "number" && !isNaN(t);
}
function Sf(t) {
  return typeof t == "string";
}
function LI(t) {
  return Sf(t) ? /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t) : !1;
}
function If(t) {
  return Sf(t) && t !== "";
}
function yy(t) {
  return typeof t == "object" && !_f(t);
}
function PI(t) {
  return yy(t) && t !== null;
}
function kI(t) {
  return typeof t == "string" && t.length > 0 && t.length <= 128;
}
function BI(t) {
  return typeof t == "string" && t.length >= 6;
}
function UI(t) {
  return typeof t != "string" ? !1 : /^[^@]+@[^@]+$/.test(t);
}
function FI(t) {
  if (typeof t != "string")
    return !1;
  const e = /^\+/, r = /[\da-zA-Z]+/;
  return e.test(t) && r.test(t);
}
function MI(t) {
  try {
    return If(t) && new Date(t).toISOString() === t;
  } catch {
    return !1;
  }
}
function VI(t) {
  try {
    return If(t) && new Date(t).toUTCString() === t;
  } catch {
    return !1;
  }
}
function $I(t) {
  if (typeof t != "string" || /[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i.test(t))
    return !1;
  try {
    const r = RI.parse(t), n = r.protocol, i = r.slashes, a = r.hostname, s = r.pathname;
    if (n !== "http:" && n !== "https:" || !i || !a || !/^[a-zA-Z0-9]+[\w-]*([.]?[a-zA-Z0-9]+[\w-]*)*$/.test(a) || s && s !== "/" && !/^(\/[\w\-.~!$'()*+,;=:@%]+)*\/?$/.test(s))
      return !1;
  } catch {
    return !1;
  }
  return !0;
}
function HI(t) {
  return typeof t != "string" ? !1 : /^(\/topics\/)?(private\/)?[a-zA-Z0-9-_.~%]+$/.test(t);
}
function KI(t) {
  return typeof t != "string" ? !1 : /^[A-Za-z0-9_-]+$/.test(t);
}
var jc, kh;
function Pe() {
  return kh || (kh = 1, jc = {
    // default options
    options: {
      usePureJavaScript: !1
    }
  }), jc;
}
var qc = { exports: {} }, Wc, Bh;
function GI() {
  if (Bh) return Wc;
  Bh = 1;
  var t = {};
  Wc = t;
  var e = {};
  t.encode = function(n, i, a) {
    if (typeof i != "string")
      throw new TypeError('"alphabet" must be a string.');
    if (a !== void 0 && typeof a != "number")
      throw new TypeError('"maxline" must be a number.');
    var s = "";
    if (!(n instanceof Uint8Array))
      s = r(n, i);
    else {
      var o = 0, l = i.length, u = i.charAt(0), f = [0];
      for (o = 0; o < n.length; ++o) {
        for (var y = 0, m = n[o]; y < f.length; ++y)
          m += f[y] << 8, f[y] = m % l, m = m / l | 0;
        for (; m > 0; )
          f.push(m % l), m = m / l | 0;
      }
      for (o = 0; n[o] === 0 && o < n.length - 1; ++o)
        s += u;
      for (o = f.length - 1; o >= 0; --o)
        s += i[f[o]];
    }
    if (a) {
      var p = new RegExp(".{1," + a + "}", "g");
      s = s.match(p).join(`\r
`);
    }
    return s;
  }, t.decode = function(n, i) {
    if (typeof n != "string")
      throw new TypeError('"input" must be a string.');
    if (typeof i != "string")
      throw new TypeError('"alphabet" must be a string.');
    var a = e[i];
    if (!a) {
      a = e[i] = [];
      for (var s = 0; s < i.length; ++s)
        a[i.charCodeAt(s)] = s;
    }
    n = n.replace(/\s/g, "");
    for (var o = i.length, l = i.charAt(0), u = [0], s = 0; s < n.length; s++) {
      var f = a[n.charCodeAt(s)];
      if (f === void 0)
        return;
      for (var y = 0, m = f; y < u.length; ++y)
        m += u[y] * o, u[y] = m & 255, m >>= 8;
      for (; m > 0; )
        u.push(m & 255), m >>= 8;
    }
    for (var p = 0; n[p] === l && p < n.length - 1; ++p)
      u.push(0);
    return typeof Buffer < "u" ? Buffer.from(u.reverse()) : new Uint8Array(u.reverse());
  };
  function r(n, i) {
    var a = 0, s = i.length, o = i.charAt(0), l = [0];
    for (a = 0; a < n.length(); ++a) {
      for (var u = 0, f = n.at(a); u < l.length; ++u)
        f += l[u] << 8, l[u] = f % s, f = f / s | 0;
      for (; f > 0; )
        l.push(f % s), f = f / s | 0;
    }
    var y = "";
    for (a = 0; n.at(a) === 0 && a < n.length() - 1; ++a)
      y += o;
    for (a = l.length - 1; a >= 0; --a)
      y += i[l[a]];
    return y;
  }
  return Wc;
}
var Uh;
function $e() {
  if (Uh) return qc.exports;
  Uh = 1;
  var t = Pe(), e = GI(), r = qc.exports = t.util = t.util || {};
  (function() {
    if (typeof process < "u" && process.nextTick && !process.browser) {
      r.nextTick = process.nextTick, typeof setImmediate == "function" ? r.setImmediate = setImmediate : r.setImmediate = r.nextTick;
      return;
    }
    if (typeof setImmediate == "function") {
      r.setImmediate = function() {
        return setImmediate.apply(void 0, arguments);
      }, r.nextTick = function(d) {
        return setImmediate(d);
      };
      return;
    }
    if (r.setImmediate = function(d) {
      setTimeout(d, 0);
    }, typeof window < "u" && typeof window.postMessage == "function") {
      let d = function(O) {
        if (O.source === window && O.data === c) {
          O.stopPropagation();
          var P = E.slice();
          E.length = 0, P.forEach(function(L) {
            L();
          });
        }
      };
      var h = d, c = "forge.setImmediate", E = [];
      r.setImmediate = function(O) {
        E.push(O), E.length === 1 && window.postMessage(c, "*");
      }, window.addEventListener("message", d, !0);
    }
    if (typeof MutationObserver < "u") {
      var v = Date.now(), R = !0, N = document.createElement("div"), E = [];
      new MutationObserver(function() {
        var O = E.slice();
        E.length = 0, O.forEach(function(P) {
          P();
        });
      }).observe(N, { attributes: !0 });
      var C = r.setImmediate;
      r.setImmediate = function(O) {
        Date.now() - v > 15 ? (v = Date.now(), C(O)) : (E.push(O), E.length === 1 && N.setAttribute("a", R = !R));
      };
    }
    r.nextTick = r.setImmediate;
  })(), r.isNodejs = typeof process < "u" && process.versions && process.versions.node, r.globalScope = function() {
    return r.isNodejs ? pe : typeof self > "u" ? window : self;
  }(), r.isArray = Array.isArray || function(c) {
    return Object.prototype.toString.call(c) === "[object Array]";
  }, r.isArrayBuffer = function(c) {
    return typeof ArrayBuffer < "u" && c instanceof ArrayBuffer;
  }, r.isArrayBufferView = function(c) {
    return c && r.isArrayBuffer(c.buffer) && c.byteLength !== void 0;
  };
  function n(c) {
    if (!(c === 8 || c === 16 || c === 24 || c === 32))
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + c);
  }
  r.ByteBuffer = i;
  function i(c) {
    if (this.data = "", this.read = 0, typeof c == "string")
      this.data = c;
    else if (r.isArrayBuffer(c) || r.isArrayBufferView(c))
      if (typeof Buffer < "u" && c instanceof Buffer)
        this.data = c.toString("binary");
      else {
        var E = new Uint8Array(c);
        try {
          this.data = String.fromCharCode.apply(null, E);
        } catch {
          for (var v = 0; v < E.length; ++v)
            this.putByte(E[v]);
        }
      }
    else (c instanceof i || typeof c == "object" && typeof c.data == "string" && typeof c.read == "number") && (this.data = c.data, this.read = c.read);
    this._constructedStringLength = 0;
  }
  r.ByteStringBuffer = i;
  var a = 4096;
  r.ByteStringBuffer.prototype._optimizeConstructedString = function(c) {
    this._constructedStringLength += c, this._constructedStringLength > a && (this.data.substr(0, 1), this._constructedStringLength = 0);
  }, r.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
  }, r.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  }, r.ByteStringBuffer.prototype.putByte = function(c) {
    return this.putBytes(String.fromCharCode(c));
  }, r.ByteStringBuffer.prototype.fillWithByte = function(c, E) {
    c = String.fromCharCode(c);
    for (var v = this.data; E > 0; )
      E & 1 && (v += c), E >>>= 1, E > 0 && (c += c);
    return this.data = v, this._optimizeConstructedString(E), this;
  }, r.ByteStringBuffer.prototype.putBytes = function(c) {
    return this.data += c, this._optimizeConstructedString(c.length), this;
  }, r.ByteStringBuffer.prototype.putString = function(c) {
    return this.putBytes(r.encodeUtf8(c));
  }, r.ByteStringBuffer.prototype.putInt16 = function(c) {
    return this.putBytes(
      String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt24 = function(c) {
    return this.putBytes(
      String.fromCharCode(c >> 16 & 255) + String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt32 = function(c) {
    return this.putBytes(
      String.fromCharCode(c >> 24 & 255) + String.fromCharCode(c >> 16 & 255) + String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt16Le = function(c) {
    return this.putBytes(
      String.fromCharCode(c & 255) + String.fromCharCode(c >> 8 & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt24Le = function(c) {
    return this.putBytes(
      String.fromCharCode(c & 255) + String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c >> 16 & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt32Le = function(c) {
    return this.putBytes(
      String.fromCharCode(c & 255) + String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c >> 16 & 255) + String.fromCharCode(c >> 24 & 255)
    );
  }, r.ByteStringBuffer.prototype.putInt = function(c, E) {
    n(E);
    var v = "";
    do
      E -= 8, v += String.fromCharCode(c >> E & 255);
    while (E > 0);
    return this.putBytes(v);
  }, r.ByteStringBuffer.prototype.putSignedInt = function(c, E) {
    return c < 0 && (c += 2 << E - 1), this.putInt(c, E);
  }, r.ByteStringBuffer.prototype.putBuffer = function(c) {
    return this.putBytes(c.getBytes());
  }, r.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
  }, r.ByteStringBuffer.prototype.getInt16 = function() {
    var c = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    return this.read += 2, c;
  }, r.ByteStringBuffer.prototype.getInt24 = function() {
    var c = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    return this.read += 3, c;
  }, r.ByteStringBuffer.prototype.getInt32 = function() {
    var c = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    return this.read += 4, c;
  }, r.ByteStringBuffer.prototype.getInt16Le = function() {
    var c = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    return this.read += 2, c;
  }, r.ByteStringBuffer.prototype.getInt24Le = function() {
    var c = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    return this.read += 3, c;
  }, r.ByteStringBuffer.prototype.getInt32Le = function() {
    var c = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    return this.read += 4, c;
  }, r.ByteStringBuffer.prototype.getInt = function(c) {
    n(c);
    var E = 0;
    do
      E = (E << 8) + this.data.charCodeAt(this.read++), c -= 8;
    while (c > 0);
    return E;
  }, r.ByteStringBuffer.prototype.getSignedInt = function(c) {
    var E = this.getInt(c), v = 2 << c - 2;
    return E >= v && (E -= v << 1), E;
  }, r.ByteStringBuffer.prototype.getBytes = function(c) {
    var E;
    return c ? (c = Math.min(this.length(), c), E = this.data.slice(this.read, this.read + c), this.read += c) : c === 0 ? E = "" : (E = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), E;
  }, r.ByteStringBuffer.prototype.bytes = function(c) {
    return typeof c > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + c);
  }, r.ByteStringBuffer.prototype.at = function(c) {
    return this.data.charCodeAt(this.read + c);
  }, r.ByteStringBuffer.prototype.setAt = function(c, E) {
    return this.data = this.data.substr(0, this.read + c) + String.fromCharCode(E) + this.data.substr(this.read + c + 1), this;
  }, r.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
  }, r.ByteStringBuffer.prototype.copy = function() {
    var c = r.createBuffer(this.data);
    return c.read = this.read, c;
  }, r.ByteStringBuffer.prototype.compact = function() {
    return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
  }, r.ByteStringBuffer.prototype.clear = function() {
    return this.data = "", this.read = 0, this;
  }, r.ByteStringBuffer.prototype.truncate = function(c) {
    var E = Math.max(0, this.length() - c);
    return this.data = this.data.substr(this.read, E), this.read = 0, this;
  }, r.ByteStringBuffer.prototype.toHex = function() {
    for (var c = "", E = this.read; E < this.data.length; ++E) {
      var v = this.data.charCodeAt(E);
      v < 16 && (c += "0"), c += v.toString(16);
    }
    return c;
  }, r.ByteStringBuffer.prototype.toString = function() {
    return r.decodeUtf8(this.bytes());
  };
  function s(c, E) {
    E = E || {}, this.read = E.readOffset || 0, this.growSize = E.growSize || 1024;
    var v = r.isArrayBuffer(c), R = r.isArrayBufferView(c);
    if (v || R) {
      v ? this.data = new DataView(c) : this.data = new DataView(c.buffer, c.byteOffset, c.byteLength), this.write = "writeOffset" in E ? E.writeOffset : this.data.byteLength;
      return;
    }
    this.data = new DataView(new ArrayBuffer(0)), this.write = 0, c != null && this.putBytes(c), "writeOffset" in E && (this.write = E.writeOffset);
  }
  r.DataBuffer = s, r.DataBuffer.prototype.length = function() {
    return this.write - this.read;
  }, r.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  }, r.DataBuffer.prototype.accommodate = function(c, E) {
    if (this.length() >= c)
      return this;
    E = Math.max(E || this.growSize, c);
    var v = new Uint8Array(
      this.data.buffer,
      this.data.byteOffset,
      this.data.byteLength
    ), R = new Uint8Array(this.length() + E);
    return R.set(v), this.data = new DataView(R.buffer), this;
  }, r.DataBuffer.prototype.putByte = function(c) {
    return this.accommodate(1), this.data.setUint8(this.write++, c), this;
  }, r.DataBuffer.prototype.fillWithByte = function(c, E) {
    this.accommodate(E);
    for (var v = 0; v < E; ++v)
      this.data.setUint8(c);
    return this;
  }, r.DataBuffer.prototype.putBytes = function(c, E) {
    if (r.isArrayBufferView(c)) {
      var v = new Uint8Array(c.buffer, c.byteOffset, c.byteLength), R = v.byteLength - v.byteOffset;
      this.accommodate(R);
      var N = new Uint8Array(this.data.buffer, this.write);
      return N.set(v), this.write += R, this;
    }
    if (r.isArrayBuffer(c)) {
      var v = new Uint8Array(c);
      this.accommodate(v.byteLength);
      var N = new Uint8Array(this.data.buffer);
      return N.set(v, this.write), this.write += v.byteLength, this;
    }
    if (c instanceof r.DataBuffer || typeof c == "object" && typeof c.read == "number" && typeof c.write == "number" && r.isArrayBufferView(c.data)) {
      var v = new Uint8Array(c.data.byteLength, c.read, c.length());
      this.accommodate(v.byteLength);
      var N = new Uint8Array(c.data.byteLength, this.write);
      return N.set(v), this.write += v.byteLength, this;
    }
    if (c instanceof r.ByteStringBuffer && (c = c.data, E = "binary"), E = E || "binary", typeof c == "string") {
      var C;
      if (E === "hex")
        return this.accommodate(Math.ceil(c.length / 2)), C = new Uint8Array(this.data.buffer, this.write), this.write += r.binary.hex.decode(c, C, this.write), this;
      if (E === "base64")
        return this.accommodate(Math.ceil(c.length / 4) * 3), C = new Uint8Array(this.data.buffer, this.write), this.write += r.binary.base64.decode(c, C, this.write), this;
      if (E === "utf8" && (c = r.encodeUtf8(c), E = "binary"), E === "binary" || E === "raw")
        return this.accommodate(c.length), C = new Uint8Array(this.data.buffer, this.write), this.write += r.binary.raw.decode(C), this;
      if (E === "utf16")
        return this.accommodate(c.length * 2), C = new Uint16Array(this.data.buffer, this.write), this.write += r.text.utf16.encode(C), this;
      throw new Error("Invalid encoding: " + E);
    }
    throw Error("Invalid parameter: " + c);
  }, r.DataBuffer.prototype.putBuffer = function(c) {
    return this.putBytes(c), c.clear(), this;
  }, r.DataBuffer.prototype.putString = function(c) {
    return this.putBytes(c, "utf16");
  }, r.DataBuffer.prototype.putInt16 = function(c) {
    return this.accommodate(2), this.data.setInt16(this.write, c), this.write += 2, this;
  }, r.DataBuffer.prototype.putInt24 = function(c) {
    return this.accommodate(3), this.data.setInt16(this.write, c >> 8 & 65535), this.data.setInt8(this.write, c >> 16 & 255), this.write += 3, this;
  }, r.DataBuffer.prototype.putInt32 = function(c) {
    return this.accommodate(4), this.data.setInt32(this.write, c), this.write += 4, this;
  }, r.DataBuffer.prototype.putInt16Le = function(c) {
    return this.accommodate(2), this.data.setInt16(this.write, c, !0), this.write += 2, this;
  }, r.DataBuffer.prototype.putInt24Le = function(c) {
    return this.accommodate(3), this.data.setInt8(this.write, c >> 16 & 255), this.data.setInt16(this.write, c >> 8 & 65535, !0), this.write += 3, this;
  }, r.DataBuffer.prototype.putInt32Le = function(c) {
    return this.accommodate(4), this.data.setInt32(this.write, c, !0), this.write += 4, this;
  }, r.DataBuffer.prototype.putInt = function(c, E) {
    n(E), this.accommodate(E / 8);
    do
      E -= 8, this.data.setInt8(this.write++, c >> E & 255);
    while (E > 0);
    return this;
  }, r.DataBuffer.prototype.putSignedInt = function(c, E) {
    return n(E), this.accommodate(E / 8), c < 0 && (c += 2 << E - 1), this.putInt(c, E);
  }, r.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
  }, r.DataBuffer.prototype.getInt16 = function() {
    var c = this.data.getInt16(this.read);
    return this.read += 2, c;
  }, r.DataBuffer.prototype.getInt24 = function() {
    var c = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    return this.read += 3, c;
  }, r.DataBuffer.prototype.getInt32 = function() {
    var c = this.data.getInt32(this.read);
    return this.read += 4, c;
  }, r.DataBuffer.prototype.getInt16Le = function() {
    var c = this.data.getInt16(this.read, !0);
    return this.read += 2, c;
  }, r.DataBuffer.prototype.getInt24Le = function() {
    var c = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
    return this.read += 3, c;
  }, r.DataBuffer.prototype.getInt32Le = function() {
    var c = this.data.getInt32(this.read, !0);
    return this.read += 4, c;
  }, r.DataBuffer.prototype.getInt = function(c) {
    n(c);
    var E = 0;
    do
      E = (E << 8) + this.data.getInt8(this.read++), c -= 8;
    while (c > 0);
    return E;
  }, r.DataBuffer.prototype.getSignedInt = function(c) {
    var E = this.getInt(c), v = 2 << c - 2;
    return E >= v && (E -= v << 1), E;
  }, r.DataBuffer.prototype.getBytes = function(c) {
    var E;
    return c ? (c = Math.min(this.length(), c), E = this.data.slice(this.read, this.read + c), this.read += c) : c === 0 ? E = "" : (E = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), E;
  }, r.DataBuffer.prototype.bytes = function(c) {
    return typeof c > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + c);
  }, r.DataBuffer.prototype.at = function(c) {
    return this.data.getUint8(this.read + c);
  }, r.DataBuffer.prototype.setAt = function(c, E) {
    return this.data.setUint8(c, E), this;
  }, r.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
  }, r.DataBuffer.prototype.copy = function() {
    return new r.DataBuffer(this);
  }, r.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
      var c = new Uint8Array(this.data.buffer, this.read), E = new Uint8Array(c.byteLength);
      E.set(c), this.data = new DataView(E), this.write -= this.read, this.read = 0;
    }
    return this;
  }, r.DataBuffer.prototype.clear = function() {
    return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
  }, r.DataBuffer.prototype.truncate = function(c) {
    return this.write = Math.max(0, this.length() - c), this.read = Math.min(this.read, this.write), this;
  }, r.DataBuffer.prototype.toHex = function() {
    for (var c = "", E = this.read; E < this.data.byteLength; ++E) {
      var v = this.data.getUint8(E);
      v < 16 && (c += "0"), c += v.toString(16);
    }
    return c;
  }, r.DataBuffer.prototype.toString = function(c) {
    var E = new Uint8Array(this.data, this.read, this.length());
    if (c = c || "utf8", c === "binary" || c === "raw")
      return r.binary.raw.encode(E);
    if (c === "hex")
      return r.binary.hex.encode(E);
    if (c === "base64")
      return r.binary.base64.encode(E);
    if (c === "utf8")
      return r.text.utf8.decode(E);
    if (c === "utf16")
      return r.text.utf16.decode(E);
    throw new Error("Invalid encoding: " + c);
  }, r.createBuffer = function(c, E) {
    return E = E || "raw", c !== void 0 && E === "utf8" && (c = r.encodeUtf8(c)), new r.ByteBuffer(c);
  }, r.fillString = function(c, E) {
    for (var v = ""; E > 0; )
      E & 1 && (v += c), E >>>= 1, E > 0 && (c += c);
    return v;
  }, r.xorBytes = function(c, E, v) {
    for (var R = "", N = "", C = "", h = 0, d = 0; v > 0; --v, ++h)
      N = c.charCodeAt(h) ^ E.charCodeAt(h), d >= 10 && (R += C, C = "", d = 0), C += String.fromCharCode(N), ++d;
    return R += C, R;
  }, r.hexToBytes = function(c) {
    var E = "", v = 0;
    for (c.length & !0 && (v = 1, E += String.fromCharCode(parseInt(c[0], 16))); v < c.length; v += 2)
      E += String.fromCharCode(parseInt(c.substr(v, 2), 16));
    return E;
  }, r.bytesToHex = function(c) {
    return r.createBuffer(c).toHex();
  }, r.int32ToBytes = function(c) {
    return String.fromCharCode(c >> 24 & 255) + String.fromCharCode(c >> 16 & 255) + String.fromCharCode(c >> 8 & 255) + String.fromCharCode(c & 255);
  };
  var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", l = [
    /*43 -43 = 0*/
    /*'+',  1,  2,  3,'/' */
    62,
    -1,
    -1,
    -1,
    63,
    /*'0','1','2','3','4','5','6','7','8','9' */
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    /*15, 16, 17,'=', 19, 20, 21 */
    -1,
    -1,
    -1,
    64,
    -1,
    -1,
    -1,
    /*65 - 43 = 22*/
    /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    /*91 - 43 = 48 */
    /*48, 49, 50, 51, 52, 53 */
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    /*97 - 43 = 54*/
    /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ], u = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  r.encode64 = function(c, E) {
    for (var v = "", R = "", N, C, h, d = 0; d < c.length; )
      N = c.charCodeAt(d++), C = c.charCodeAt(d++), h = c.charCodeAt(d++), v += o.charAt(N >> 2), v += o.charAt((N & 3) << 4 | C >> 4), isNaN(C) ? v += "==" : (v += o.charAt((C & 15) << 2 | h >> 6), v += isNaN(h) ? "=" : o.charAt(h & 63)), E && v.length > E && (R += v.substr(0, E) + `\r
`, v = v.substr(E));
    return R += v, R;
  }, r.decode64 = function(c) {
    c = c.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    for (var E = "", v, R, N, C, h = 0; h < c.length; )
      v = l[c.charCodeAt(h++) - 43], R = l[c.charCodeAt(h++) - 43], N = l[c.charCodeAt(h++) - 43], C = l[c.charCodeAt(h++) - 43], E += String.fromCharCode(v << 2 | R >> 4), N !== 64 && (E += String.fromCharCode((R & 15) << 4 | N >> 2), C !== 64 && (E += String.fromCharCode((N & 3) << 6 | C)));
    return E;
  }, r.encodeUtf8 = function(c) {
    return unescape(encodeURIComponent(c));
  }, r.decodeUtf8 = function(c) {
    return decodeURIComponent(escape(c));
  }, r.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: {
      encode: e.encode,
      decode: e.decode
    }
  }, r.binary.raw.encode = function(c) {
    return String.fromCharCode.apply(null, c);
  }, r.binary.raw.decode = function(c, E, v) {
    var R = E;
    R || (R = new Uint8Array(c.length)), v = v || 0;
    for (var N = v, C = 0; C < c.length; ++C)
      R[N++] = c.charCodeAt(C);
    return E ? N - v : R;
  }, r.binary.hex.encode = r.bytesToHex, r.binary.hex.decode = function(c, E, v) {
    var R = E;
    R || (R = new Uint8Array(Math.ceil(c.length / 2))), v = v || 0;
    var N = 0, C = v;
    for (c.length & 1 && (N = 1, R[C++] = parseInt(c[0], 16)); N < c.length; N += 2)
      R[C++] = parseInt(c.substr(N, 2), 16);
    return E ? C - v : R;
  }, r.binary.base64.encode = function(c, E) {
    for (var v = "", R = "", N, C, h, d = 0; d < c.byteLength; )
      N = c[d++], C = c[d++], h = c[d++], v += o.charAt(N >> 2), v += o.charAt((N & 3) << 4 | C >> 4), isNaN(C) ? v += "==" : (v += o.charAt((C & 15) << 2 | h >> 6), v += isNaN(h) ? "=" : o.charAt(h & 63)), E && v.length > E && (R += v.substr(0, E) + `\r
`, v = v.substr(E));
    return R += v, R;
  }, r.binary.base64.decode = function(c, E, v) {
    var R = E;
    R || (R = new Uint8Array(Math.ceil(c.length / 4) * 3)), c = c.replace(/[^A-Za-z0-9\+\/\=]/g, ""), v = v || 0;
    for (var N, C, h, d, O = 0, P = v; O < c.length; )
      N = l[c.charCodeAt(O++) - 43], C = l[c.charCodeAt(O++) - 43], h = l[c.charCodeAt(O++) - 43], d = l[c.charCodeAt(O++) - 43], R[P++] = N << 2 | C >> 4, h !== 64 && (R[P++] = (C & 15) << 4 | h >> 2, d !== 64 && (R[P++] = (h & 3) << 6 | d));
    return E ? P - v : R.subarray(0, P);
  }, r.binary.base58.encode = function(c, E) {
    return r.binary.baseN.encode(c, u, E);
  }, r.binary.base58.decode = function(c, E) {
    return r.binary.baseN.decode(c, u, E);
  }, r.text = {
    utf8: {},
    utf16: {}
  }, r.text.utf8.encode = function(c, E, v) {
    c = r.encodeUtf8(c);
    var R = E;
    R || (R = new Uint8Array(c.length)), v = v || 0;
    for (var N = v, C = 0; C < c.length; ++C)
      R[N++] = c.charCodeAt(C);
    return E ? N - v : R;
  }, r.text.utf8.decode = function(c) {
    return r.decodeUtf8(String.fromCharCode.apply(null, c));
  }, r.text.utf16.encode = function(c, E, v) {
    var R = E;
    R || (R = new Uint8Array(c.length * 2));
    var N = new Uint16Array(R.buffer);
    v = v || 0;
    for (var C = v, h = v, d = 0; d < c.length; ++d)
      N[h++] = c.charCodeAt(d), C += 2;
    return E ? C - v : R;
  }, r.text.utf16.decode = function(c) {
    return String.fromCharCode.apply(null, new Uint16Array(c.buffer));
  }, r.deflate = function(c, E, v) {
    if (E = r.decode64(c.deflate(r.encode64(E)).rval), v) {
      var R = 2, N = E.charCodeAt(1);
      N & 32 && (R = 6), E = E.substring(R, E.length - 4);
    }
    return E;
  }, r.inflate = function(c, E, v) {
    var R = c.inflate(r.encode64(E)).rval;
    return R === null ? null : r.decode64(R);
  };
  var f = function(c, E, v) {
    if (!c)
      throw new Error("WebStorage not available.");
    var R;
    if (v === null ? R = c.removeItem(E) : (v = r.encode64(JSON.stringify(v)), R = c.setItem(E, v)), typeof R < "u" && R.rval !== !0) {
      var N = new Error(R.error.message);
      throw N.id = R.error.id, N.name = R.error.name, N;
    }
  }, y = function(c, E) {
    if (!c)
      throw new Error("WebStorage not available.");
    var v = c.getItem(E);
    if (c.init)
      if (v.rval === null) {
        if (v.error) {
          var R = new Error(v.error.message);
          throw R.id = v.error.id, R.name = v.error.name, R;
        }
        v = null;
      } else
        v = v.rval;
    return v !== null && (v = JSON.parse(r.decode64(v))), v;
  }, m = function(c, E, v, R) {
    var N = y(c, E);
    N === null && (N = {}), N[v] = R, f(c, E, N);
  }, p = function(c, E, v) {
    var R = y(c, E);
    return R !== null && (R = v in R ? R[v] : null), R;
  }, S = function(c, E, v) {
    var R = y(c, E);
    if (R !== null && v in R) {
      delete R[v];
      var N = !0;
      for (var C in R) {
        N = !1;
        break;
      }
      N && (R = null), f(c, E, R);
    }
  }, A = function(c, E) {
    f(c, E, null);
  }, I = function(c, E, v) {
    var R = null;
    typeof v > "u" && (v = ["web", "flash"]);
    var N, C = !1, h = null;
    for (var d in v) {
      N = v[d];
      try {
        if (N === "flash" || N === "both") {
          if (E[0] === null)
            throw new Error("Flash local storage not available.");
          R = c.apply(this, E), C = N === "flash";
        }
        (N === "web" || N === "both") && (E[0] = localStorage, R = c.apply(this, E), C = !0);
      } catch (O) {
        h = O;
      }
      if (C)
        break;
    }
    if (!C)
      throw h;
    return R;
  };
  return r.setItem = function(c, E, v, R, N) {
    I(m, arguments, N);
  }, r.getItem = function(c, E, v, R) {
    return I(p, arguments, R);
  }, r.removeItem = function(c, E, v, R) {
    I(S, arguments, R);
  }, r.clearItems = function(c, E, v) {
    I(A, arguments, v);
  }, r.isEmpty = function(c) {
    for (var E in c)
      if (c.hasOwnProperty(E))
        return !1;
    return !0;
  }, r.format = function(c) {
    for (var E = /%./g, v, R, N = 0, C = [], h = 0; v = E.exec(c); ) {
      R = c.substring(h, E.lastIndex - 2), R.length > 0 && C.push(R), h = E.lastIndex;
      var d = v[0][1];
      switch (d) {
        case "s":
        case "o":
          N < arguments.length ? C.push(arguments[N++ + 1]) : C.push("<?>");
          break;
        case "%":
          C.push("%");
          break;
        default:
          C.push("<%" + d + "?>");
      }
    }
    return C.push(c.substring(h)), C.join("");
  }, r.formatNumber = function(c, E, v, R) {
    var N = c, C = isNaN(E = Math.abs(E)) ? 2 : E, h = v === void 0 ? "," : v, d = R === void 0 ? "." : R, O = N < 0 ? "-" : "", P = parseInt(N = Math.abs(+N || 0).toFixed(C), 10) + "", L = P.length > 3 ? P.length % 3 : 0;
    return O + (L ? P.substr(0, L) + d : "") + P.substr(L).replace(/(\d{3})(?=\d)/g, "$1" + d) + (C ? h + Math.abs(N - P).toFixed(C).slice(2) : "");
  }, r.formatSize = function(c) {
    return c >= 1073741824 ? c = r.formatNumber(c / 1073741824, 2, ".", "") + " GiB" : c >= 1048576 ? c = r.formatNumber(c / 1048576, 2, ".", "") + " MiB" : c >= 1024 ? c = r.formatNumber(c / 1024, 0) + " KiB" : c = r.formatNumber(c, 0) + " bytes", c;
  }, r.bytesFromIP = function(c) {
    return c.indexOf(".") !== -1 ? r.bytesFromIPv4(c) : c.indexOf(":") !== -1 ? r.bytesFromIPv6(c) : null;
  }, r.bytesFromIPv4 = function(c) {
    if (c = c.split("."), c.length !== 4)
      return null;
    for (var E = r.createBuffer(), v = 0; v < c.length; ++v) {
      var R = parseInt(c[v], 10);
      if (isNaN(R))
        return null;
      E.putByte(R);
    }
    return E.getBytes();
  }, r.bytesFromIPv6 = function(c) {
    var E = 0;
    c = c.split(":").filter(function(h) {
      return h.length === 0 && ++E, !0;
    });
    for (var v = (8 - c.length + E) * 2, R = r.createBuffer(), N = 0; N < 8; ++N) {
      if (!c[N] || c[N].length === 0) {
        R.fillWithByte(0, v), v = 0;
        continue;
      }
      var C = r.hexToBytes(c[N]);
      C.length < 2 && R.putByte(0), R.putBytes(C);
    }
    return R.getBytes();
  }, r.bytesToIP = function(c) {
    return c.length === 4 ? r.bytesToIPv4(c) : c.length === 16 ? r.bytesToIPv6(c) : null;
  }, r.bytesToIPv4 = function(c) {
    if (c.length !== 4)
      return null;
    for (var E = [], v = 0; v < c.length; ++v)
      E.push(c.charCodeAt(v));
    return E.join(".");
  }, r.bytesToIPv6 = function(c) {
    if (c.length !== 16)
      return null;
    for (var E = [], v = [], R = 0, N = 0; N < c.length; N += 2) {
      for (var C = r.bytesToHex(c[N] + c[N + 1]); C[0] === "0" && C !== "0"; )
        C = C.substr(1);
      if (C === "0") {
        var h = v[v.length - 1], d = E.length;
        !h || d !== h.end + 1 ? v.push({ start: d, end: d }) : (h.end = d, h.end - h.start > v[R].end - v[R].start && (R = v.length - 1));
      }
      E.push(C);
    }
    if (v.length > 0) {
      var O = v[R];
      O.end - O.start > 0 && (E.splice(O.start, O.end - O.start + 1, ""), O.start === 0 && E.unshift(""), O.end === 7 && E.push(""));
    }
    return E.join(":");
  }, r.estimateCores = function(c, E) {
    if (typeof c == "function" && (E = c, c = {}), c = c || {}, "cores" in r && !c.update)
      return E(null, r.cores);
    if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
      return r.cores = navigator.hardwareConcurrency, E(null, r.cores);
    if (typeof Worker > "u")
      return r.cores = 1, E(null, r.cores);
    if (typeof Blob > "u")
      return r.cores = 2, E(null, r.cores);
    var v = URL.createObjectURL(new Blob([
      "(",
      (function() {
        self.addEventListener("message", function(h) {
          var d = Date.now(), O = d + 4;
          self.postMessage({ st: d, et: O });
        });
      }).toString(),
      ")()"
    ], { type: "application/javascript" }));
    R([], 5, 16);
    function R(h, d, O) {
      if (d === 0) {
        var P = Math.floor(h.reduce(function(L, D) {
          return L + D;
        }, 0) / h.length);
        return r.cores = Math.max(1, P), URL.revokeObjectURL(v), E(null, r.cores);
      }
      N(O, function(L, D) {
        h.push(C(O, D)), R(h, d - 1, O);
      });
    }
    function N(h, d) {
      for (var O = [], P = [], L = 0; L < h; ++L) {
        var D = new Worker(v);
        D.addEventListener("message", function(V) {
          if (P.push(V.data), P.length === h) {
            for (var $ = 0; $ < h; ++$)
              O[$].terminate();
            d(null, P);
          }
        }), O.push(D);
      }
      for (var L = 0; L < h; ++L)
        O[L].postMessage(L);
    }
    function C(h, d) {
      for (var O = [], P = 0; P < h; ++P)
        for (var L = d[P], D = O[P] = [], V = 0; V < h; ++V)
          if (P !== V) {
            var $ = d[V];
            (L.st > $.st && L.st < $.et || $.st > L.st && $.st < L.et) && D.push(V);
          }
      return O.reduce(function(K, Q) {
        return Math.max(K, Q.length);
      }, 0);
    }
  }, qc.exports;
}
var Jc, Fh;
function bf() {
  if (Fh) return Jc;
  Fh = 1;
  var t = Pe();
  $e(), Jc = t.cipher = t.cipher || {}, t.cipher.algorithms = t.cipher.algorithms || {}, t.cipher.createCipher = function(r, n) {
    var i = r;
    if (typeof i == "string" && (i = t.cipher.getAlgorithm(i), i && (i = i())), !i)
      throw new Error("Unsupported algorithm: " + r);
    return new t.cipher.BlockCipher({
      algorithm: i,
      key: n,
      decrypt: !1
    });
  }, t.cipher.createDecipher = function(r, n) {
    var i = r;
    if (typeof i == "string" && (i = t.cipher.getAlgorithm(i), i && (i = i())), !i)
      throw new Error("Unsupported algorithm: " + r);
    return new t.cipher.BlockCipher({
      algorithm: i,
      key: n,
      decrypt: !0
    });
  }, t.cipher.registerAlgorithm = function(r, n) {
    r = r.toUpperCase(), t.cipher.algorithms[r] = n;
  }, t.cipher.getAlgorithm = function(r) {
    return r = r.toUpperCase(), r in t.cipher.algorithms ? t.cipher.algorithms[r] : null;
  };
  var e = t.cipher.BlockCipher = function(r) {
    this.algorithm = r.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = r.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = r.decrypt, this.algorithm.initialize(r);
  };
  return e.prototype.start = function(r) {
    r = r || {};
    var n = {};
    for (var i in r)
      n[i] = r[i];
    n.decrypt = this._decrypt, this._finish = !1, this._input = t.util.createBuffer(), this.output = r.output || t.util.createBuffer(), this.mode.start(n);
  }, e.prototype.update = function(r) {
    for (r && this._input.putBuffer(r); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
      ;
    this._input.compact();
  }, e.prototype.finish = function(r) {
    r && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(i) {
      return r(this.blockSize, i, !1);
    }, this.mode.unpad = function(i) {
      return r(this.blockSize, i, !0);
    });
    var n = {};
    return n.decrypt = this._decrypt, n.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, n) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, n)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, n));
  }, Jc;
}
var zc = { exports: {} }, Mh;
function my() {
  if (Mh) return zc.exports;
  Mh = 1;
  var t = Pe();
  $e(), t.cipher = t.cipher || {};
  var e = zc.exports = t.cipher.modes = t.cipher.modes || {};
  e.ecb = function(a) {
    a = a || {}, this.name = "ECB", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  }, e.ecb.prototype.start = function(a) {
  }, e.ecb.prototype.encrypt = function(a, s, o) {
    if (a.length() < this.blockSize && !(o && a.length() > 0))
      return !0;
    for (var l = 0; l < this._ints; ++l)
      this._inBlock[l] = a.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var l = 0; l < this._ints; ++l)
      s.putInt32(this._outBlock[l]);
  }, e.ecb.prototype.decrypt = function(a, s, o) {
    if (a.length() < this.blockSize && !(o && a.length() > 0))
      return !0;
    for (var l = 0; l < this._ints; ++l)
      this._inBlock[l] = a.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var l = 0; l < this._ints; ++l)
      s.putInt32(this._outBlock[l]);
  }, e.ecb.prototype.pad = function(a, s) {
    var o = a.length() === this.blockSize ? this.blockSize : this.blockSize - a.length();
    return a.fillWithByte(o, o), !0;
  }, e.ecb.prototype.unpad = function(a, s) {
    if (s.overflow > 0)
      return !1;
    var o = a.length(), l = a.at(o - 1);
    return l > this.blockSize << 2 ? !1 : (a.truncate(l), !0);
  }, e.cbc = function(a) {
    a = a || {}, this.name = "CBC", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  }, e.cbc.prototype.start = function(a) {
    if (a.iv === null) {
      if (!this._prev)
        throw new Error("Invalid IV parameter.");
      this._iv = this._prev.slice(0);
    } else if ("iv" in a)
      this._iv = r(a.iv, this.blockSize), this._prev = this._iv.slice(0);
    else
      throw new Error("Invalid IV parameter.");
  }, e.cbc.prototype.encrypt = function(a, s, o) {
    if (a.length() < this.blockSize && !(o && a.length() > 0))
      return !0;
    for (var l = 0; l < this._ints; ++l)
      this._inBlock[l] = this._prev[l] ^ a.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var l = 0; l < this._ints; ++l)
      s.putInt32(this._outBlock[l]);
    this._prev = this._outBlock;
  }, e.cbc.prototype.decrypt = function(a, s, o) {
    if (a.length() < this.blockSize && !(o && a.length() > 0))
      return !0;
    for (var l = 0; l < this._ints; ++l)
      this._inBlock[l] = a.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var l = 0; l < this._ints; ++l)
      s.putInt32(this._prev[l] ^ this._outBlock[l]);
    this._prev = this._inBlock.slice(0);
  }, e.cbc.prototype.pad = function(a, s) {
    var o = a.length() === this.blockSize ? this.blockSize : this.blockSize - a.length();
    return a.fillWithByte(o, o), !0;
  }, e.cbc.prototype.unpad = function(a, s) {
    if (s.overflow > 0)
      return !1;
    var o = a.length(), l = a.at(o - 1);
    return l > this.blockSize << 2 ? !1 : (a.truncate(l), !0);
  }, e.cfb = function(a) {
    a = a || {}, this.name = "CFB", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = t.util.createBuffer(), this._partialBytes = 0;
  }, e.cfb.prototype.start = function(a) {
    if (!("iv" in a))
      throw new Error("Invalid IV parameter.");
    this._iv = r(a.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e.cfb.prototype.encrypt = function(a, s, o) {
    var l = a.length();
    if (l === 0)
      return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && l >= this.blockSize) {
      for (var u = 0; u < this._ints; ++u)
        this._inBlock[u] = a.getInt32() ^ this._outBlock[u], s.putInt32(this._inBlock[u]);
      return;
    }
    var f = (this.blockSize - l) % this.blockSize;
    f > 0 && (f = this.blockSize - f), this._partialOutput.clear();
    for (var u = 0; u < this._ints; ++u)
      this._partialBlock[u] = a.getInt32() ^ this._outBlock[u], this._partialOutput.putInt32(this._partialBlock[u]);
    if (f > 0)
      a.read -= this.blockSize;
    else
      for (var u = 0; u < this._ints; ++u)
        this._inBlock[u] = this._partialBlock[u];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), f > 0 && !o)
      return s.putBytes(this._partialOutput.getBytes(
        f - this._partialBytes
      )), this._partialBytes = f, !0;
    s.putBytes(this._partialOutput.getBytes(
      l - this._partialBytes
    )), this._partialBytes = 0;
  }, e.cfb.prototype.decrypt = function(a, s, o) {
    var l = a.length();
    if (l === 0)
      return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && l >= this.blockSize) {
      for (var u = 0; u < this._ints; ++u)
        this._inBlock[u] = a.getInt32(), s.putInt32(this._inBlock[u] ^ this._outBlock[u]);
      return;
    }
    var f = (this.blockSize - l) % this.blockSize;
    f > 0 && (f = this.blockSize - f), this._partialOutput.clear();
    for (var u = 0; u < this._ints; ++u)
      this._partialBlock[u] = a.getInt32(), this._partialOutput.putInt32(this._partialBlock[u] ^ this._outBlock[u]);
    if (f > 0)
      a.read -= this.blockSize;
    else
      for (var u = 0; u < this._ints; ++u)
        this._inBlock[u] = this._partialBlock[u];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), f > 0 && !o)
      return s.putBytes(this._partialOutput.getBytes(
        f - this._partialBytes
      )), this._partialBytes = f, !0;
    s.putBytes(this._partialOutput.getBytes(
      l - this._partialBytes
    )), this._partialBytes = 0;
  }, e.ofb = function(a) {
    a = a || {}, this.name = "OFB", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = t.util.createBuffer(), this._partialBytes = 0;
  }, e.ofb.prototype.start = function(a) {
    if (!("iv" in a))
      throw new Error("Invalid IV parameter.");
    this._iv = r(a.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e.ofb.prototype.encrypt = function(a, s, o) {
    var l = a.length();
    if (a.length() === 0)
      return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && l >= this.blockSize) {
      for (var u = 0; u < this._ints; ++u)
        s.putInt32(a.getInt32() ^ this._outBlock[u]), this._inBlock[u] = this._outBlock[u];
      return;
    }
    var f = (this.blockSize - l) % this.blockSize;
    f > 0 && (f = this.blockSize - f), this._partialOutput.clear();
    for (var u = 0; u < this._ints; ++u)
      this._partialOutput.putInt32(a.getInt32() ^ this._outBlock[u]);
    if (f > 0)
      a.read -= this.blockSize;
    else
      for (var u = 0; u < this._ints; ++u)
        this._inBlock[u] = this._outBlock[u];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), f > 0 && !o)
      return s.putBytes(this._partialOutput.getBytes(
        f - this._partialBytes
      )), this._partialBytes = f, !0;
    s.putBytes(this._partialOutput.getBytes(
      l - this._partialBytes
    )), this._partialBytes = 0;
  }, e.ofb.prototype.decrypt = e.ofb.prototype.encrypt, e.ctr = function(a) {
    a = a || {}, this.name = "CTR", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = t.util.createBuffer(), this._partialBytes = 0;
  }, e.ctr.prototype.start = function(a) {
    if (!("iv" in a))
      throw new Error("Invalid IV parameter.");
    this._iv = r(a.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  }, e.ctr.prototype.encrypt = function(a, s, o) {
    var l = a.length();
    if (l === 0)
      return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && l >= this.blockSize)
      for (var u = 0; u < this._ints; ++u)
        s.putInt32(a.getInt32() ^ this._outBlock[u]);
    else {
      var f = (this.blockSize - l) % this.blockSize;
      f > 0 && (f = this.blockSize - f), this._partialOutput.clear();
      for (var u = 0; u < this._ints; ++u)
        this._partialOutput.putInt32(a.getInt32() ^ this._outBlock[u]);
      if (f > 0 && (a.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), f > 0 && !o)
        return s.putBytes(this._partialOutput.getBytes(
          f - this._partialBytes
        )), this._partialBytes = f, !0;
      s.putBytes(this._partialOutput.getBytes(
        l - this._partialBytes
      )), this._partialBytes = 0;
    }
    n(this._inBlock);
  }, e.ctr.prototype.decrypt = e.ctr.prototype.encrypt, e.gcm = function(a) {
    a = a || {}, this.name = "GCM", this.cipher = a.cipher, this.blockSize = a.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = t.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
  }, e.gcm.prototype.start = function(a) {
    if (!("iv" in a))
      throw new Error("Invalid IV parameter.");
    var s = t.util.createBuffer(a.iv);
    this._cipherLength = 0;
    var o;
    if ("additionalData" in a ? o = t.util.createBuffer(a.additionalData) : o = t.util.createBuffer(), "tagLength" in a ? this._tagLength = a.tagLength : this._tagLength = 128, this._tag = null, a.decrypt && (this._tag = t.util.createBuffer(a.tag).getBytes(), this._tag.length !== this._tagLength / 8))
      throw new Error("Authentication tag does not match tag length.");
    this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var l = s.length();
    if (l === 12)
      this._j0 = [s.getInt32(), s.getInt32(), s.getInt32(), 1];
    else {
      for (this._j0 = [0, 0, 0, 0]; s.length() > 0; )
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [s.getInt32(), s.getInt32(), s.getInt32(), s.getInt32()]
        );
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [0, 0].concat(i(l * 8))
      );
    }
    this._inBlock = this._j0.slice(0), n(this._inBlock), this._partialBytes = 0, o = t.util.createBuffer(o), this._aDataLength = i(o.length() * 8);
    var u = o.length() % this.blockSize;
    for (u && o.fillWithByte(0, this.blockSize - u), this._s = [0, 0, 0, 0]; o.length() > 0; )
      this._s = this.ghash(this._hashSubkey, this._s, [
        o.getInt32(),
        o.getInt32(),
        o.getInt32(),
        o.getInt32()
      ]);
  }, e.gcm.prototype.encrypt = function(a, s, o) {
    var l = a.length();
    if (l === 0)
      return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && l >= this.blockSize) {
      for (var u = 0; u < this._ints; ++u)
        s.putInt32(this._outBlock[u] ^= a.getInt32());
      this._cipherLength += this.blockSize;
    } else {
      var f = (this.blockSize - l) % this.blockSize;
      f > 0 && (f = this.blockSize - f), this._partialOutput.clear();
      for (var u = 0; u < this._ints; ++u)
        this._partialOutput.putInt32(a.getInt32() ^ this._outBlock[u]);
      if (f <= 0 || o) {
        if (o) {
          var y = l % this.blockSize;
          this._cipherLength += y, this._partialOutput.truncate(this.blockSize - y);
        } else
          this._cipherLength += this.blockSize;
        for (var u = 0; u < this._ints; ++u)
          this._outBlock[u] = this._partialOutput.getInt32();
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), f > 0 && !o)
        return a.read -= this.blockSize, s.putBytes(this._partialOutput.getBytes(
          f - this._partialBytes
        )), this._partialBytes = f, !0;
      s.putBytes(this._partialOutput.getBytes(
        l - this._partialBytes
      )), this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), n(this._inBlock);
  }, e.gcm.prototype.decrypt = function(a, s, o) {
    var l = a.length();
    if (l < this.blockSize && !(o && l > 0))
      return !0;
    this.cipher.encrypt(this._inBlock, this._outBlock), n(this._inBlock), this._hashBlock[0] = a.getInt32(), this._hashBlock[1] = a.getInt32(), this._hashBlock[2] = a.getInt32(), this._hashBlock[3] = a.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var u = 0; u < this._ints; ++u)
      s.putInt32(this._outBlock[u] ^ this._hashBlock[u]);
    l < this.blockSize ? this._cipherLength += l % this.blockSize : this._cipherLength += this.blockSize;
  }, e.gcm.prototype.afterFinish = function(a, s) {
    var o = !0;
    s.decrypt && s.overflow && a.truncate(this.blockSize - s.overflow), this.tag = t.util.createBuffer();
    var l = this._aDataLength.concat(i(this._cipherLength * 8));
    this._s = this.ghash(this._hashSubkey, this._s, l);
    var u = [];
    this.cipher.encrypt(this._j0, u);
    for (var f = 0; f < this._ints; ++f)
      this.tag.putInt32(this._s[f] ^ u[f]);
    return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), s.decrypt && this.tag.bytes() !== this._tag && (o = !1), o;
  }, e.gcm.prototype.multiply = function(a, s) {
    for (var o = [0, 0, 0, 0], l = s.slice(0), u = 0; u < 128; ++u) {
      var f = a[u / 32 | 0] & 1 << 31 - u % 32;
      f && (o[0] ^= l[0], o[1] ^= l[1], o[2] ^= l[2], o[3] ^= l[3]), this.pow(l, l);
    }
    return o;
  }, e.gcm.prototype.pow = function(a, s) {
    for (var o = a[3] & 1, l = 3; l > 0; --l)
      s[l] = a[l] >>> 1 | (a[l - 1] & 1) << 31;
    s[0] = a[0] >>> 1, o && (s[0] ^= this._R);
  }, e.gcm.prototype.tableMultiply = function(a) {
    for (var s = [0, 0, 0, 0], o = 0; o < 32; ++o) {
      var l = o / 8 | 0, u = a[l] >>> (7 - o % 8) * 4 & 15, f = this._m[o][u];
      s[0] ^= f[0], s[1] ^= f[1], s[2] ^= f[2], s[3] ^= f[3];
    }
    return s;
  }, e.gcm.prototype.ghash = function(a, s, o) {
    return s[0] ^= o[0], s[1] ^= o[1], s[2] ^= o[2], s[3] ^= o[3], this.tableMultiply(s);
  }, e.gcm.prototype.generateHashTable = function(a, s) {
    for (var o = 8 / s, l = 4 * o, u = 16 * o, f = new Array(u), y = 0; y < u; ++y) {
      var m = [0, 0, 0, 0], p = y / l | 0, S = (l - 1 - y % l) * s;
      m[p] = 1 << s - 1 << S, f[y] = this.generateSubHashTable(this.multiply(m, a), s);
    }
    return f;
  }, e.gcm.prototype.generateSubHashTable = function(a, s) {
    var o = 1 << s, l = o >>> 1, u = new Array(o);
    u[l] = a.slice(0);
    for (var f = l >>> 1; f > 0; )
      this.pow(u[2 * f], u[f] = []), f >>= 1;
    for (f = 2; f < l; ) {
      for (var y = 1; y < f; ++y) {
        var m = u[f], p = u[y];
        u[f + y] = [
          m[0] ^ p[0],
          m[1] ^ p[1],
          m[2] ^ p[2],
          m[3] ^ p[3]
        ];
      }
      f *= 2;
    }
    for (u[0] = [0, 0, 0, 0], f = l + 1; f < o; ++f) {
      var S = u[f ^ l];
      u[f] = [a[0] ^ S[0], a[1] ^ S[1], a[2] ^ S[2], a[3] ^ S[3]];
    }
    return u;
  };
  function r(a, s) {
    if (typeof a == "string" && (a = t.util.createBuffer(a)), t.util.isArray(a) && a.length > 4) {
      var o = a;
      a = t.util.createBuffer();
      for (var l = 0; l < o.length; ++l)
        a.putByte(o[l]);
    }
    if (a.length() < s)
      throw new Error(
        "Invalid IV length; got " + a.length() + " bytes and expected " + s + " bytes."
      );
    if (!t.util.isArray(a)) {
      for (var u = [], f = s / 4, l = 0; l < f; ++l)
        u.push(a.getInt32());
      a = u;
    }
    return a;
  }
  function n(a) {
    a[a.length - 1] = a[a.length - 1] + 1 & 4294967295;
  }
  function i(a) {
    return [a / 4294967296 | 0, a & 4294967295];
  }
  return zc.exports;
}
var Xc, Vh;
function ni() {
  if (Vh) return Xc;
  Vh = 1;
  var t = Pe();
  bf(), my(), $e(), Xc = t.aes = t.aes || {}, t.aes.startEncrypting = function(p, S, A, I) {
    var c = m({
      key: p,
      output: A,
      decrypt: !1,
      mode: I
    });
    return c.start(S), c;
  }, t.aes.createEncryptionCipher = function(p, S) {
    return m({
      key: p,
      output: null,
      decrypt: !1,
      mode: S
    });
  }, t.aes.startDecrypting = function(p, S, A, I) {
    var c = m({
      key: p,
      output: A,
      decrypt: !0,
      mode: I
    });
    return c.start(S), c;
  }, t.aes.createDecryptionCipher = function(p, S) {
    return m({
      key: p,
      output: null,
      decrypt: !0,
      mode: S
    });
  }, t.aes.Algorithm = function(p, S) {
    r || u();
    var A = this;
    A.name = p, A.mode = new S({
      blockSize: 16,
      cipher: {
        encrypt: function(I, c) {
          return y(A._w, I, c, !1);
        },
        decrypt: function(I, c) {
          return y(A._w, I, c, !0);
        }
      }
    }), A._init = !1;
  }, t.aes.Algorithm.prototype.initialize = function(p) {
    if (!this._init) {
      var S = p.key, A;
      if (typeof S == "string" && (S.length === 16 || S.length === 24 || S.length === 32))
        S = t.util.createBuffer(S);
      else if (t.util.isArray(S) && (S.length === 16 || S.length === 24 || S.length === 32)) {
        A = S, S = t.util.createBuffer();
        for (var I = 0; I < A.length; ++I)
          S.putByte(A[I]);
      }
      if (!t.util.isArray(S)) {
        A = S, S = [];
        var c = A.length();
        if (c === 16 || c === 24 || c === 32) {
          c = c >>> 2;
          for (var I = 0; I < c; ++I)
            S.push(A.getInt32());
        }
      }
      if (!t.util.isArray(S) || !(S.length === 4 || S.length === 6 || S.length === 8))
        throw new Error("Invalid key parameter.");
      var E = this.mode.name, v = ["CFB", "OFB", "CTR", "GCM"].indexOf(E) !== -1;
      this._w = f(S, p.decrypt && !v), this._init = !0;
    }
  }, t.aes._expandKey = function(p, S) {
    return r || u(), f(p, S);
  }, t.aes._updateBlock = y, e("AES-ECB", t.cipher.modes.ecb), e("AES-CBC", t.cipher.modes.cbc), e("AES-CFB", t.cipher.modes.cfb), e("AES-OFB", t.cipher.modes.ofb), e("AES-CTR", t.cipher.modes.ctr), e("AES-GCM", t.cipher.modes.gcm);
  function e(p, S) {
    var A = function() {
      return new t.aes.Algorithm(p, S);
    };
    t.cipher.registerAlgorithm(p, A);
  }
  var r = !1, n = 4, i, a, s, o, l;
  function u() {
    r = !0, s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    for (var p = new Array(256), S = 0; S < 128; ++S)
      p[S] = S << 1, p[S + 128] = S + 128 << 1 ^ 283;
    i = new Array(256), a = new Array(256), o = new Array(4), l = new Array(4);
    for (var S = 0; S < 4; ++S)
      o[S] = new Array(256), l[S] = new Array(256);
    for (var A = 0, I = 0, c, E, v, R, N, C, h, S = 0; S < 256; ++S) {
      R = I ^ I << 1 ^ I << 2 ^ I << 3 ^ I << 4, R = R >> 8 ^ R & 255 ^ 99, i[A] = R, a[R] = A, N = p[R], c = p[A], E = p[c], v = p[E], C = N << 24 ^ // 2
      R << 16 ^ // 1
      R << 8 ^ // 1
      (R ^ N), h = (c ^ E ^ v) << 24 ^ // E (14)
      (A ^ v) << 16 ^ // 9
      (A ^ E ^ v) << 8 ^ // D (13)
      (A ^ c ^ v);
      for (var d = 0; d < 4; ++d)
        o[d][A] = C, l[d][R] = h, C = C << 24 | C >>> 8, h = h << 24 | h >>> 8;
      A === 0 ? A = I = 1 : (A = c ^ p[p[p[c ^ v]]], I ^= p[p[I]]);
    }
  }
  function f(p, S) {
    for (var A = p.slice(0), I, c = 1, E = A.length, v = E + 6 + 1, R = n * v, N = E; N < R; ++N)
      I = A[N - 1], N % E === 0 ? (I = i[I >>> 16 & 255] << 24 ^ i[I >>> 8 & 255] << 16 ^ i[I & 255] << 8 ^ i[I >>> 24] ^ s[c] << 24, c++) : E > 6 && N % E === 4 && (I = i[I >>> 24] << 24 ^ i[I >>> 16 & 255] << 16 ^ i[I >>> 8 & 255] << 8 ^ i[I & 255]), A[N] = A[N - E] ^ I;
    if (S) {
      var C, h = l[0], d = l[1], O = l[2], P = l[3], L = A.slice(0);
      R = A.length;
      for (var N = 0, D = R - n; N < R; N += n, D -= n)
        if (N === 0 || N === R - n)
          L[N] = A[D], L[N + 1] = A[D + 3], L[N + 2] = A[D + 2], L[N + 3] = A[D + 1];
        else
          for (var V = 0; V < n; ++V)
            C = A[D + V], L[N + (3 & -V)] = h[i[C >>> 24]] ^ d[i[C >>> 16 & 255]] ^ O[i[C >>> 8 & 255]] ^ P[i[C & 255]];
      A = L;
    }
    return A;
  }
  function y(p, S, A, I) {
    var c = p.length / 4 - 1, E, v, R, N, C;
    I ? (E = l[0], v = l[1], R = l[2], N = l[3], C = a) : (E = o[0], v = o[1], R = o[2], N = o[3], C = i);
    var h, d, O, P, L, D, V;
    h = S[0] ^ p[0], d = S[I ? 3 : 1] ^ p[1], O = S[2] ^ p[2], P = S[I ? 1 : 3] ^ p[3];
    for (var $ = 3, K = 1; K < c; ++K)
      L = E[h >>> 24] ^ v[d >>> 16 & 255] ^ R[O >>> 8 & 255] ^ N[P & 255] ^ p[++$], D = E[d >>> 24] ^ v[O >>> 16 & 255] ^ R[P >>> 8 & 255] ^ N[h & 255] ^ p[++$], V = E[O >>> 24] ^ v[P >>> 16 & 255] ^ R[h >>> 8 & 255] ^ N[d & 255] ^ p[++$], P = E[P >>> 24] ^ v[h >>> 16 & 255] ^ R[d >>> 8 & 255] ^ N[O & 255] ^ p[++$], h = L, d = D, O = V;
    A[0] = C[h >>> 24] << 24 ^ C[d >>> 16 & 255] << 16 ^ C[O >>> 8 & 255] << 8 ^ C[P & 255] ^ p[++$], A[I ? 3 : 1] = C[d >>> 24] << 24 ^ C[O >>> 16 & 255] << 16 ^ C[P >>> 8 & 255] << 8 ^ C[h & 255] ^ p[++$], A[2] = C[O >>> 24] << 24 ^ C[P >>> 16 & 255] << 16 ^ C[h >>> 8 & 255] << 8 ^ C[d & 255] ^ p[++$], A[I ? 1 : 3] = C[P >>> 24] << 24 ^ C[h >>> 16 & 255] << 16 ^ C[d >>> 8 & 255] << 8 ^ C[O & 255] ^ p[++$];
  }
  function m(p) {
    p = p || {};
    var S = (p.mode || "CBC").toUpperCase(), A = "AES-" + S, I;
    p.decrypt ? I = t.cipher.createDecipher(A, p.key) : I = t.cipher.createCipher(A, p.key);
    var c = I.start;
    return I.start = function(E, v) {
      var R = null;
      v instanceof t.util.ByteBuffer && (R = v, v = {}), v = v || {}, v.output = R, v.iv = E, c.call(I, v);
    }, I;
  }
  return Xc;
}
var Yc = { exports: {} }, Qc = { exports: {} }, Zc = { exports: {} }, $h;
function ii() {
  if ($h) return Zc.exports;
  $h = 1;
  var t = Pe();
  t.pki = t.pki || {};
  var e = Zc.exports = t.pki.oids = t.oids = t.oids || {};
  function r(i, a) {
    e[i] = a, e[a] = i;
  }
  function n(i, a) {
    e[i] = a;
  }
  return r("1.2.840.113549.1.1.1", "rsaEncryption"), r("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), r("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), r("1.2.840.113549.1.1.7", "RSAES-OAEP"), r("1.2.840.113549.1.1.8", "mgf1"), r("1.2.840.113549.1.1.9", "pSpecified"), r("1.2.840.113549.1.1.10", "RSASSA-PSS"), r("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), r("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), r("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), r("1.3.101.112", "EdDSA25519"), r("1.2.840.10040.4.3", "dsa-with-sha1"), r("1.3.14.3.2.7", "desCBC"), r("1.3.14.3.2.26", "sha1"), r("1.3.14.3.2.29", "sha1WithRSASignature"), r("2.16.840.1.101.3.4.2.1", "sha256"), r("2.16.840.1.101.3.4.2.2", "sha384"), r("2.16.840.1.101.3.4.2.3", "sha512"), r("2.16.840.1.101.3.4.2.4", "sha224"), r("2.16.840.1.101.3.4.2.5", "sha512-224"), r("2.16.840.1.101.3.4.2.6", "sha512-256"), r("1.2.840.113549.2.2", "md2"), r("1.2.840.113549.2.5", "md5"), r("1.2.840.113549.1.7.1", "data"), r("1.2.840.113549.1.7.2", "signedData"), r("1.2.840.113549.1.7.3", "envelopedData"), r("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), r("1.2.840.113549.1.7.5", "digestedData"), r("1.2.840.113549.1.7.6", "encryptedData"), r("1.2.840.113549.1.9.1", "emailAddress"), r("1.2.840.113549.1.9.2", "unstructuredName"), r("1.2.840.113549.1.9.3", "contentType"), r("1.2.840.113549.1.9.4", "messageDigest"), r("1.2.840.113549.1.9.5", "signingTime"), r("1.2.840.113549.1.9.6", "counterSignature"), r("1.2.840.113549.1.9.7", "challengePassword"), r("1.2.840.113549.1.9.8", "unstructuredAddress"), r("1.2.840.113549.1.9.14", "extensionRequest"), r("1.2.840.113549.1.9.20", "friendlyName"), r("1.2.840.113549.1.9.21", "localKeyId"), r("1.2.840.113549.1.9.22.1", "x509Certificate"), r("1.2.840.113549.1.12.10.1.1", "keyBag"), r("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), r("1.2.840.113549.1.12.10.1.3", "certBag"), r("1.2.840.113549.1.12.10.1.4", "crlBag"), r("1.2.840.113549.1.12.10.1.5", "secretBag"), r("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), r("1.2.840.113549.1.5.13", "pkcs5PBES2"), r("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), r("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), r("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), r("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), r("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), r("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), r("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), r("1.2.840.113549.2.7", "hmacWithSHA1"), r("1.2.840.113549.2.8", "hmacWithSHA224"), r("1.2.840.113549.2.9", "hmacWithSHA256"), r("1.2.840.113549.2.10", "hmacWithSHA384"), r("1.2.840.113549.2.11", "hmacWithSHA512"), r("1.2.840.113549.3.7", "des-EDE3-CBC"), r("2.16.840.1.101.3.4.1.2", "aes128-CBC"), r("2.16.840.1.101.3.4.1.22", "aes192-CBC"), r("2.16.840.1.101.3.4.1.42", "aes256-CBC"), r("2.5.4.3", "commonName"), r("2.5.4.4", "surname"), r("2.5.4.5", "serialNumber"), r("2.5.4.6", "countryName"), r("2.5.4.7", "localityName"), r("2.5.4.8", "stateOrProvinceName"), r("2.5.4.9", "streetAddress"), r("2.5.4.10", "organizationName"), r("2.5.4.11", "organizationalUnitName"), r("2.5.4.12", "title"), r("2.5.4.13", "description"), r("2.5.4.15", "businessCategory"), r("2.5.4.17", "postalCode"), r("2.5.4.42", "givenName"), r("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName"), r("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName"), r("2.16.840.1.113730.1.1", "nsCertType"), r("2.16.840.1.113730.1.13", "nsComment"), n("2.5.29.1", "authorityKeyIdentifier"), n("2.5.29.2", "keyAttributes"), n("2.5.29.3", "certificatePolicies"), n("2.5.29.4", "keyUsageRestriction"), n("2.5.29.5", "policyMapping"), n("2.5.29.6", "subtreesConstraint"), n("2.5.29.7", "subjectAltName"), n("2.5.29.8", "issuerAltName"), n("2.5.29.9", "subjectDirectoryAttributes"), n("2.5.29.10", "basicConstraints"), n("2.5.29.11", "nameConstraints"), n("2.5.29.12", "policyConstraints"), n("2.5.29.13", "basicConstraints"), r("2.5.29.14", "subjectKeyIdentifier"), r("2.5.29.15", "keyUsage"), n("2.5.29.16", "privateKeyUsagePeriod"), r("2.5.29.17", "subjectAltName"), r("2.5.29.18", "issuerAltName"), r("2.5.29.19", "basicConstraints"), n("2.5.29.20", "cRLNumber"), n("2.5.29.21", "cRLReason"), n("2.5.29.22", "expirationDate"), n("2.5.29.23", "instructionCode"), n("2.5.29.24", "invalidityDate"), n("2.5.29.25", "cRLDistributionPoints"), n("2.5.29.26", "issuingDistributionPoint"), n("2.5.29.27", "deltaCRLIndicator"), n("2.5.29.28", "issuingDistributionPoint"), n("2.5.29.29", "certificateIssuer"), n("2.5.29.30", "nameConstraints"), r("2.5.29.31", "cRLDistributionPoints"), r("2.5.29.32", "certificatePolicies"), n("2.5.29.33", "policyMappings"), n("2.5.29.34", "policyConstraints"), r("2.5.29.35", "authorityKeyIdentifier"), n("2.5.29.36", "policyConstraints"), r("2.5.29.37", "extKeyUsage"), n("2.5.29.46", "freshestCRL"), n("2.5.29.54", "inhibitAnyPolicy"), r("1.3.6.1.4.1.11129.2.4.2", "timestampList"), r("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), r("1.3.6.1.5.5.7.3.1", "serverAuth"), r("1.3.6.1.5.5.7.3.2", "clientAuth"), r("1.3.6.1.5.5.7.3.3", "codeSigning"), r("1.3.6.1.5.5.7.3.4", "emailProtection"), r("1.3.6.1.5.5.7.3.8", "timeStamping"), Zc.exports;
}
var Hh;
function Wr() {
  if (Hh) return Qc.exports;
  Hh = 1;
  var t = Pe();
  $e(), ii();
  var e = Qc.exports = t.asn1 = t.asn1 || {};
  e.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192
  }, e.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30
  }, e.create = function(s, o, l, u, f) {
    if (t.util.isArray(u)) {
      for (var y = [], m = 0; m < u.length; ++m)
        u[m] !== void 0 && y.push(u[m]);
      u = y;
    }
    var p = {
      tagClass: s,
      type: o,
      constructed: l,
      composed: l || t.util.isArray(u),
      value: u
    };
    return f && "bitStringContents" in f && (p.bitStringContents = f.bitStringContents, p.original = e.copy(p)), p;
  }, e.copy = function(s, o) {
    var l;
    if (t.util.isArray(s)) {
      l = [];
      for (var u = 0; u < s.length; ++u)
        l.push(e.copy(s[u], o));
      return l;
    }
    return typeof s == "string" ? s : (l = {
      tagClass: s.tagClass,
      type: s.type,
      constructed: s.constructed,
      composed: s.composed,
      value: e.copy(s.value, o)
    }, o && !o.excludeBitStringContents && (l.bitStringContents = s.bitStringContents), l);
  }, e.equals = function(s, o, l) {
    if (t.util.isArray(s)) {
      if (!t.util.isArray(o) || s.length !== o.length)
        return !1;
      for (var u = 0; u < s.length; ++u)
        if (!e.equals(s[u], o[u]))
          return !1;
      return !0;
    }
    if (typeof s != typeof o)
      return !1;
    if (typeof s == "string")
      return s === o;
    var f = s.tagClass === o.tagClass && s.type === o.type && s.constructed === o.constructed && s.composed === o.composed && e.equals(s.value, o.value);
    return l && l.includeBitStringContents && (f = f && s.bitStringContents === o.bitStringContents), f;
  }, e.getBerValueLength = function(s) {
    var o = s.getByte();
    if (o !== 128) {
      var l, u = o & 128;
      return u ? l = s.getInt((o & 127) << 3) : l = o, l;
    }
  };
  function r(s, o, l) {
    if (l > o) {
      var u = new Error("Too few bytes to parse DER.");
      throw u.available = s.length(), u.remaining = o, u.requested = l, u;
    }
  }
  var n = function(s, o) {
    var l = s.getByte();
    if (o--, l !== 128) {
      var u, f = l & 128;
      if (!f)
        u = l;
      else {
        var y = l & 127;
        r(s, o, y), u = s.getInt(y << 3);
      }
      if (u < 0)
        throw new Error("Negative length: " + u);
      return u;
    }
  };
  e.fromDer = function(s, o) {
    o === void 0 && (o = {
      strict: !0,
      parseAllBytes: !0,
      decodeBitStrings: !0
    }), typeof o == "boolean" && (o = {
      strict: o,
      parseAllBytes: !0,
      decodeBitStrings: !0
    }), "strict" in o || (o.strict = !0), "parseAllBytes" in o || (o.parseAllBytes = !0), "decodeBitStrings" in o || (o.decodeBitStrings = !0), typeof s == "string" && (s = t.util.createBuffer(s));
    var l = s.length(), u = i(s, s.length(), 0, o);
    if (o.parseAllBytes && s.length() !== 0) {
      var f = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
      throw f.byteCount = l, f.remaining = s.length(), f;
    }
    return u;
  };
  function i(s, o, l, u) {
    var f;
    r(s, o, 2);
    var y = s.getByte();
    o--;
    var m = y & 192, p = y & 31;
    f = s.length();
    var S = n(s, o);
    if (o -= f - s.length(), S !== void 0 && S > o) {
      if (u.strict) {
        var A = new Error("Too few bytes to read ASN.1 value.");
        throw A.available = s.length(), A.remaining = o, A.requested = S, A;
      }
      S = o;
    }
    var I, c, E = (y & 32) === 32;
    if (E)
      if (I = [], S === void 0)
        for (; ; ) {
          if (r(s, o, 2), s.bytes(2) === "\0\0") {
            s.getBytes(2), o -= 2;
            break;
          }
          f = s.length(), I.push(i(s, o, l + 1, u)), o -= f - s.length();
        }
      else
        for (; S > 0; )
          f = s.length(), I.push(i(s, S, l + 1, u)), o -= f - s.length(), S -= f - s.length();
    if (I === void 0 && m === e.Class.UNIVERSAL && p === e.Type.BITSTRING && (c = s.bytes(S)), I === void 0 && u.decodeBitStrings && m === e.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
    // .. other parts of forge expect to decode OCTET STRINGs manually
    p === e.Type.BITSTRING && S > 1) {
      var v = s.read, R = o, N = 0;
      if (p === e.Type.BITSTRING && (r(s, o, 1), N = s.getByte(), o--), N === 0)
        try {
          f = s.length();
          var C = {
            // enforce strict mode to avoid parsing ASN.1 from plain data
            strict: !0,
            decodeBitStrings: !0
          }, h = i(s, o, l + 1, C), d = f - s.length();
          o -= d, p == e.Type.BITSTRING && d++;
          var O = h.tagClass;
          d === S && (O === e.Class.UNIVERSAL || O === e.Class.CONTEXT_SPECIFIC) && (I = [h]);
        } catch {
        }
      I === void 0 && (s.read = v, o = R);
    }
    if (I === void 0) {
      if (S === void 0) {
        if (u.strict)
          throw new Error("Non-constructed ASN.1 object of indefinite length.");
        S = o;
      }
      if (p === e.Type.BMPSTRING)
        for (I = ""; S > 0; S -= 2)
          r(s, o, 2), I += String.fromCharCode(s.getInt16()), o -= 2;
      else
        I = s.getBytes(S), o -= S;
    }
    var P = c === void 0 ? null : {
      bitStringContents: c
    };
    return e.create(m, p, E, I, P);
  }
  e.toDer = function(s) {
    var o = t.util.createBuffer(), l = s.tagClass | s.type, u = t.util.createBuffer(), f = !1;
    if ("bitStringContents" in s && (f = !0, s.original && (f = e.equals(s, s.original))), f)
      u.putBytes(s.bitStringContents);
    else if (s.composed) {
      s.constructed ? l |= 32 : u.putByte(0);
      for (var y = 0; y < s.value.length; ++y)
        s.value[y] !== void 0 && u.putBuffer(e.toDer(s.value[y]));
    } else if (s.type === e.Type.BMPSTRING)
      for (var y = 0; y < s.value.length; ++y)
        u.putInt16(s.value.charCodeAt(y));
    else
      s.type === e.Type.INTEGER && s.value.length > 1 && // leading 0x00 for positive integer
      (s.value.charCodeAt(0) === 0 && !(s.value.charCodeAt(1) & 128) || // leading 0xFF for negative integer
      s.value.charCodeAt(0) === 255 && (s.value.charCodeAt(1) & 128) === 128) ? u.putBytes(s.value.substr(1)) : u.putBytes(s.value);
    if (o.putByte(l), u.length() <= 127)
      o.putByte(u.length() & 127);
    else {
      var m = u.length(), p = "";
      do
        p += String.fromCharCode(m & 255), m = m >>> 8;
      while (m > 0);
      o.putByte(p.length | 128);
      for (var y = p.length - 1; y >= 0; --y)
        o.putByte(p.charCodeAt(y));
    }
    return o.putBuffer(u), o;
  }, e.oidToDer = function(s) {
    var o = s.split("."), l = t.util.createBuffer();
    l.putByte(40 * parseInt(o[0], 10) + parseInt(o[1], 10));
    for (var u, f, y, m, p = 2; p < o.length; ++p) {
      u = !0, f = [], y = parseInt(o[p], 10);
      do
        m = y & 127, y = y >>> 7, u || (m |= 128), f.push(m), u = !1;
      while (y > 0);
      for (var S = f.length - 1; S >= 0; --S)
        l.putByte(f[S]);
    }
    return l;
  }, e.derToOid = function(s) {
    var o;
    typeof s == "string" && (s = t.util.createBuffer(s));
    var l = s.getByte();
    o = Math.floor(l / 40) + "." + l % 40;
    for (var u = 0; s.length() > 0; )
      l = s.getByte(), u = u << 7, l & 128 ? u += l & 127 : (o += "." + (u + l), u = 0);
    return o;
  }, e.utcTimeToDate = function(s) {
    var o = /* @__PURE__ */ new Date(), l = parseInt(s.substr(0, 2), 10);
    l = l >= 50 ? 1900 + l : 2e3 + l;
    var u = parseInt(s.substr(2, 2), 10) - 1, f = parseInt(s.substr(4, 2), 10), y = parseInt(s.substr(6, 2), 10), m = parseInt(s.substr(8, 2), 10), p = 0;
    if (s.length > 11) {
      var S = s.charAt(10), A = 10;
      S !== "+" && S !== "-" && (p = parseInt(s.substr(10, 2), 10), A += 2);
    }
    if (o.setUTCFullYear(l, u, f), o.setUTCHours(y, m, p, 0), A && (S = s.charAt(A), S === "+" || S === "-")) {
      var I = parseInt(s.substr(A + 1, 2), 10), c = parseInt(s.substr(A + 4, 2), 10), E = I * 60 + c;
      E *= 6e4, S === "+" ? o.setTime(+o - E) : o.setTime(+o + E);
    }
    return o;
  }, e.generalizedTimeToDate = function(s) {
    var o = /* @__PURE__ */ new Date(), l = parseInt(s.substr(0, 4), 10), u = parseInt(s.substr(4, 2), 10) - 1, f = parseInt(s.substr(6, 2), 10), y = parseInt(s.substr(8, 2), 10), m = parseInt(s.substr(10, 2), 10), p = parseInt(s.substr(12, 2), 10), S = 0, A = 0, I = !1;
    s.charAt(s.length - 1) === "Z" && (I = !0);
    var c = s.length - 5, E = s.charAt(c);
    if (E === "+" || E === "-") {
      var v = parseInt(s.substr(c + 1, 2), 10), R = parseInt(s.substr(c + 4, 2), 10);
      A = v * 60 + R, A *= 6e4, E === "+" && (A *= -1), I = !0;
    }
    return s.charAt(14) === "." && (S = parseFloat(s.substr(14), 10) * 1e3), I ? (o.setUTCFullYear(l, u, f), o.setUTCHours(y, m, p, S), o.setTime(+o + A)) : (o.setFullYear(l, u, f), o.setHours(y, m, p, S)), o;
  }, e.dateToUtcTime = function(s) {
    if (typeof s == "string")
      return s;
    var o = "", l = [];
    l.push(("" + s.getUTCFullYear()).substr(2)), l.push("" + (s.getUTCMonth() + 1)), l.push("" + s.getUTCDate()), l.push("" + s.getUTCHours()), l.push("" + s.getUTCMinutes()), l.push("" + s.getUTCSeconds());
    for (var u = 0; u < l.length; ++u)
      l[u].length < 2 && (o += "0"), o += l[u];
    return o += "Z", o;
  }, e.dateToGeneralizedTime = function(s) {
    if (typeof s == "string")
      return s;
    var o = "", l = [];
    l.push("" + s.getUTCFullYear()), l.push("" + (s.getUTCMonth() + 1)), l.push("" + s.getUTCDate()), l.push("" + s.getUTCHours()), l.push("" + s.getUTCMinutes()), l.push("" + s.getUTCSeconds());
    for (var u = 0; u < l.length; ++u)
      l[u].length < 2 && (o += "0"), o += l[u];
    return o += "Z", o;
  }, e.integerToDer = function(s) {
    var o = t.util.createBuffer();
    if (s >= -128 && s < 128)
      return o.putSignedInt(s, 8);
    if (s >= -32768 && s < 32768)
      return o.putSignedInt(s, 16);
    if (s >= -8388608 && s < 8388608)
      return o.putSignedInt(s, 24);
    if (s >= -2147483648 && s < 2147483648)
      return o.putSignedInt(s, 32);
    var l = new Error("Integer too large; max is 32-bits.");
    throw l.integer = s, l;
  }, e.derToInteger = function(s) {
    typeof s == "string" && (s = t.util.createBuffer(s));
    var o = s.length() * 8;
    if (o > 32)
      throw new Error("Integer too large; max is 32-bits.");
    return s.getSignedInt(o);
  }, e.validate = function(s, o, l, u) {
    var f = !1;
    if ((s.tagClass === o.tagClass || typeof o.tagClass > "u") && (s.type === o.type || typeof o.type > "u"))
      if (s.constructed === o.constructed || typeof o.constructed > "u") {
        if (f = !0, o.value && t.util.isArray(o.value))
          for (var y = 0, m = 0; f && m < o.value.length; ++m)
            f = o.value[m].optional || !1, s.value[y] && (f = e.validate(s.value[y], o.value[m], l, u), f ? ++y : o.value[m].optional && (f = !0)), !f && u && u.push(
              "[" + o.name + '] Tag class "' + o.tagClass + '", type "' + o.type + '" expected value length "' + o.value.length + '", got "' + s.value.length + '"'
            );
        if (f && l && (o.capture && (l[o.capture] = s.value), o.captureAsn1 && (l[o.captureAsn1] = s), o.captureBitStringContents && "bitStringContents" in s && (l[o.captureBitStringContents] = s.bitStringContents), o.captureBitStringValue && "bitStringContents" in s))
          if (s.bitStringContents.length < 2)
            l[o.captureBitStringValue] = "";
          else {
            var p = s.bitStringContents.charCodeAt(0);
            if (p !== 0)
              throw new Error(
                "captureBitStringValue only supported for zero unused bits"
              );
            l[o.captureBitStringValue] = s.bitStringContents.slice(1);
          }
      } else u && u.push(
        "[" + o.name + '] Expected constructed "' + o.constructed + '", got "' + s.constructed + '"'
      );
    else u && (s.tagClass !== o.tagClass && u.push(
      "[" + o.name + '] Expected tag class "' + o.tagClass + '", got "' + s.tagClass + '"'
    ), s.type !== o.type && u.push(
      "[" + o.name + '] Expected type "' + o.type + '", got "' + s.type + '"'
    ));
    return f;
  };
  var a = /[^\\u0000-\\u00ff]/;
  return e.prettyPrint = function(s, o, l) {
    var u = "";
    o = o || 0, l = l || 2, o > 0 && (u += `
`);
    for (var f = "", y = 0; y < o * l; ++y)
      f += " ";
    switch (u += f + "Tag: ", s.tagClass) {
      case e.Class.UNIVERSAL:
        u += "Universal:";
        break;
      case e.Class.APPLICATION:
        u += "Application:";
        break;
      case e.Class.CONTEXT_SPECIFIC:
        u += "Context-Specific:";
        break;
      case e.Class.PRIVATE:
        u += "Private:";
        break;
    }
    if (s.tagClass === e.Class.UNIVERSAL)
      switch (u += s.type, s.type) {
        case e.Type.NONE:
          u += " (None)";
          break;
        case e.Type.BOOLEAN:
          u += " (Boolean)";
          break;
        case e.Type.INTEGER:
          u += " (Integer)";
          break;
        case e.Type.BITSTRING:
          u += " (Bit string)";
          break;
        case e.Type.OCTETSTRING:
          u += " (Octet string)";
          break;
        case e.Type.NULL:
          u += " (Null)";
          break;
        case e.Type.OID:
          u += " (Object Identifier)";
          break;
        case e.Type.ODESC:
          u += " (Object Descriptor)";
          break;
        case e.Type.EXTERNAL:
          u += " (External or Instance of)";
          break;
        case e.Type.REAL:
          u += " (Real)";
          break;
        case e.Type.ENUMERATED:
          u += " (Enumerated)";
          break;
        case e.Type.EMBEDDED:
          u += " (Embedded PDV)";
          break;
        case e.Type.UTF8:
          u += " (UTF8)";
          break;
        case e.Type.ROID:
          u += " (Relative Object Identifier)";
          break;
        case e.Type.SEQUENCE:
          u += " (Sequence)";
          break;
        case e.Type.SET:
          u += " (Set)";
          break;
        case e.Type.PRINTABLESTRING:
          u += " (Printable String)";
          break;
        case e.Type.IA5String:
          u += " (IA5String (ASCII))";
          break;
        case e.Type.UTCTIME:
          u += " (UTC time)";
          break;
        case e.Type.GENERALIZEDTIME:
          u += " (Generalized time)";
          break;
        case e.Type.BMPSTRING:
          u += " (BMP String)";
          break;
      }
    else
      u += s.type;
    if (u += `
`, u += f + "Constructed: " + s.constructed + `
`, s.composed) {
      for (var m = 0, p = "", y = 0; y < s.value.length; ++y)
        s.value[y] !== void 0 && (m += 1, p += e.prettyPrint(s.value[y], o + 1, l), y + 1 < s.value.length && (p += ","));
      u += f + "Sub values: " + m + p;
    } else {
      if (u += f + "Value: ", s.type === e.Type.OID) {
        var S = e.derToOid(s.value);
        u += S, t.pki && t.pki.oids && S in t.pki.oids && (u += " (" + t.pki.oids[S] + ") ");
      }
      if (s.type === e.Type.INTEGER)
        try {
          u += e.derToInteger(s.value);
        } catch {
          u += "0x" + t.util.bytesToHex(s.value);
        }
      else if (s.type === e.Type.BITSTRING) {
        if (s.value.length > 1 ? u += "0x" + t.util.bytesToHex(s.value.slice(1)) : u += "(none)", s.value.length > 0) {
          var A = s.value.charCodeAt(0);
          A == 1 ? u += " (1 unused bit shown)" : A > 1 && (u += " (" + A + " unused bits shown)");
        }
      } else if (s.type === e.Type.OCTETSTRING)
        a.test(s.value) || (u += "(" + s.value + ") "), u += "0x" + t.util.bytesToHex(s.value);
      else if (s.type === e.Type.UTF8)
        try {
          u += t.util.decodeUtf8(s.value);
        } catch (I) {
          if (I.message === "URI malformed")
            u += "0x" + t.util.bytesToHex(s.value) + " (malformed UTF8)";
          else
            throw I;
        }
      else s.type === e.Type.PRINTABLESTRING || s.type === e.Type.IA5String ? u += s.value : a.test(s.value) ? u += "0x" + t.util.bytesToHex(s.value) : s.value.length === 0 ? u += "[null]" : u += s.value;
    }
    return u;
  }, Qc.exports;
}
var eu = { exports: {} }, tu, Kh;
function dn() {
  if (Kh) return tu;
  Kh = 1;
  var t = Pe();
  return tu = t.md = t.md || {}, t.md.algorithms = t.md.algorithms || {}, tu;
}
var Gh;
function Oa() {
  if (Gh) return eu.exports;
  Gh = 1;
  var t = Pe();
  dn(), $e();
  var e = eu.exports = t.hmac = t.hmac || {};
  return e.create = function() {
    var r = null, n = null, i = null, a = null, s = {};
    return s.start = function(o, l) {
      if (o !== null)
        if (typeof o == "string")
          if (o = o.toLowerCase(), o in t.md.algorithms)
            n = t.md.algorithms[o].create();
          else
            throw new Error('Unknown hash algorithm "' + o + '"');
        else
          n = o;
      if (l === null)
        l = r;
      else {
        if (typeof l == "string")
          l = t.util.createBuffer(l);
        else if (t.util.isArray(l)) {
          var u = l;
          l = t.util.createBuffer();
          for (var f = 0; f < u.length; ++f)
            l.putByte(u[f]);
        }
        var y = l.length();
        y > n.blockLength && (n.start(), n.update(l.bytes()), l = n.digest()), i = t.util.createBuffer(), a = t.util.createBuffer(), y = l.length();
        for (var f = 0; f < y; ++f) {
          var u = l.at(f);
          i.putByte(54 ^ u), a.putByte(92 ^ u);
        }
        if (y < n.blockLength)
          for (var u = n.blockLength - y, f = 0; f < u; ++f)
            i.putByte(54), a.putByte(92);
        r = l, i = i.bytes(), a = a.bytes();
      }
      n.start(), n.update(i);
    }, s.update = function(o) {
      n.update(o);
    }, s.getMac = function() {
      var o = n.digest().bytes();
      return n.start(), n.update(a), n.update(o), n.digest();
    }, s.digest = s.getMac, s;
  }, eu.exports;
}
var ru = { exports: {} }, jh;
function wf() {
  if (jh) return ru.exports;
  jh = 1;
  var t = Pe();
  dn(), $e();
  var e = ru.exports = t.md5 = t.md5 || {};
  t.md.md5 = t.md.algorithms.md5 = e, e.create = function() {
    s || o();
    var u = null, f = t.util.createBuffer(), y = new Array(16), m = {
      algorithm: "md5",
      blockLength: 64,
      digestLength: 16,
      // 56-bit length of message so far (does not including padding)
      messageLength: 0,
      // true message length
      fullMessageLength: null,
      // size of message length in bytes
      messageLengthSize: 8
    };
    return m.start = function() {
      m.messageLength = 0, m.fullMessageLength = m.messageLength64 = [];
      for (var p = m.messageLengthSize / 4, S = 0; S < p; ++S)
        m.fullMessageLength.push(0);
      return f = t.util.createBuffer(), u = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878
      }, m;
    }, m.start(), m.update = function(p, S) {
      S === "utf8" && (p = t.util.encodeUtf8(p));
      var A = p.length;
      m.messageLength += A, A = [A / 4294967296 >>> 0, A >>> 0];
      for (var I = m.fullMessageLength.length - 1; I >= 0; --I)
        m.fullMessageLength[I] += A[1], A[1] = A[0] + (m.fullMessageLength[I] / 4294967296 >>> 0), m.fullMessageLength[I] = m.fullMessageLength[I] >>> 0, A[0] = A[1] / 4294967296 >>> 0;
      return f.putBytes(p), l(u, y, f), (f.read > 2048 || f.length() === 0) && f.compact(), m;
    }, m.digest = function() {
      var p = t.util.createBuffer();
      p.putBytes(f.bytes());
      var S = m.fullMessageLength[m.fullMessageLength.length - 1] + m.messageLengthSize, A = S & m.blockLength - 1;
      p.putBytes(r.substr(0, m.blockLength - A));
      for (var I, c = 0, E = m.fullMessageLength.length - 1; E >= 0; --E)
        I = m.fullMessageLength[E] * 8 + c, c = I / 4294967296 >>> 0, p.putInt32Le(I >>> 0);
      var v = {
        h0: u.h0,
        h1: u.h1,
        h2: u.h2,
        h3: u.h3
      };
      l(v, y, p);
      var R = t.util.createBuffer();
      return R.putInt32Le(v.h0), R.putInt32Le(v.h1), R.putInt32Le(v.h2), R.putInt32Le(v.h3), R;
    }, m;
  };
  var r = null, n = null, i = null, a = null, s = !1;
  function o() {
    r = "", r += t.util.fillString("\0", 64), n = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      1,
      6,
      11,
      0,
      5,
      10,
      15,
      4,
      9,
      14,
      3,
      8,
      13,
      2,
      7,
      12,
      5,
      8,
      11,
      14,
      1,
      4,
      7,
      10,
      13,
      0,
      3,
      6,
      9,
      12,
      15,
      2,
      0,
      7,
      14,
      5,
      12,
      3,
      10,
      1,
      8,
      15,
      6,
      13,
      4,
      11,
      2,
      9
    ], i = [
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21
    ], a = new Array(64);
    for (var u = 0; u < 64; ++u)
      a[u] = Math.floor(Math.abs(Math.sin(u + 1)) * 4294967296);
    s = !0;
  }
  function l(u, f, y) {
    for (var m, p, S, A, I, c, E, v, R = y.length(); R >= 64; ) {
      for (p = u.h0, S = u.h1, A = u.h2, I = u.h3, v = 0; v < 16; ++v)
        f[v] = y.getInt32Le(), c = I ^ S & (A ^ I), m = p + c + a[v] + f[v], E = i[v], p = I, I = A, A = S, S += m << E | m >>> 32 - E;
      for (; v < 32; ++v)
        c = A ^ I & (S ^ A), m = p + c + a[v] + f[n[v]], E = i[v], p = I, I = A, A = S, S += m << E | m >>> 32 - E;
      for (; v < 48; ++v)
        c = S ^ A ^ I, m = p + c + a[v] + f[n[v]], E = i[v], p = I, I = A, A = S, S += m << E | m >>> 32 - E;
      for (; v < 64; ++v)
        c = A ^ (S | ~I), m = p + c + a[v] + f[n[v]], E = i[v], p = I, I = A, A = S, S += m << E | m >>> 32 - E;
      u.h0 = u.h0 + p | 0, u.h1 = u.h1 + S | 0, u.h2 = u.h2 + A | 0, u.h3 = u.h3 + I | 0, R -= 64;
    }
  }
  return ru.exports;
}
var nu = { exports: {} }, qh;
function Vi() {
  if (qh) return nu.exports;
  qh = 1;
  var t = Pe();
  $e();
  var e = nu.exports = t.pem = t.pem || {};
  e.encode = function(i, a) {
    a = a || {};
    var s = "-----BEGIN " + i.type + `-----\r
`, o;
    if (i.procType && (o = {
      name: "Proc-Type",
      values: [String(i.procType.version), i.procType.type]
    }, s += r(o)), i.contentDomain && (o = { name: "Content-Domain", values: [i.contentDomain] }, s += r(o)), i.dekInfo && (o = { name: "DEK-Info", values: [i.dekInfo.algorithm] }, i.dekInfo.parameters && o.values.push(i.dekInfo.parameters), s += r(o)), i.headers)
      for (var l = 0; l < i.headers.length; ++l)
        s += r(i.headers[l]);
    return i.procType && (s += `\r
`), s += t.util.encode64(i.body, a.maxline || 64) + `\r
`, s += "-----END " + i.type + `-----\r
`, s;
  }, e.decode = function(i) {
    for (var a = [], s = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, o = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, l = /\r?\n/, u; u = s.exec(i), !!u; ) {
      var f = u[1];
      f === "NEW CERTIFICATE REQUEST" && (f = "CERTIFICATE REQUEST");
      var y = {
        type: f,
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: t.util.decode64(u[3])
      };
      if (a.push(y), !!u[2]) {
        for (var m = u[2].split(l), p = 0; u && p < m.length; ) {
          for (var S = m[p].replace(/\s+$/, ""), A = p + 1; A < m.length; ++A) {
            var I = m[A];
            if (!/\s/.test(I[0]))
              break;
            S += I, p = A;
          }
          if (u = S.match(o), u) {
            for (var c = { name: u[1], values: [] }, E = u[2].split(","), v = 0; v < E.length; ++v)
              c.values.push(n(E[v]));
            if (y.procType)
              if (!y.contentDomain && c.name === "Content-Domain")
                y.contentDomain = E[0] || "";
              else if (!y.dekInfo && c.name === "DEK-Info") {
                if (c.values.length === 0)
                  throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                y.dekInfo = { algorithm: E[0], parameters: E[1] || null };
              } else
                y.headers.push(c);
            else {
              if (c.name !== "Proc-Type")
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              if (c.values.length !== 2)
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              y.procType = { version: E[0], type: E[1] };
            }
          }
          ++p;
        }
        if (y.procType === "ENCRYPTED" && !y.dekInfo)
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (a.length === 0)
      throw new Error("Invalid PEM formatted message.");
    return a;
  };
  function r(i) {
    for (var a = i.name + ": ", s = [], o = function(m, p) {
      return " " + p;
    }, l = 0; l < i.values.length; ++l)
      s.push(i.values[l].replace(/^(\S+\r\n)/, o));
    a += s.join(",") + `\r
`;
    for (var u = 0, f = -1, l = 0; l < a.length; ++l, ++u)
      if (u > 65 && f !== -1) {
        var y = a[f];
        y === "," ? (++f, a = a.substr(0, f) + `\r
 ` + a.substr(f)) : a = a.substr(0, f) + `\r
` + y + a.substr(f + 1), u = l - f - 1, f = -1, ++l;
      } else (a[l] === " " || a[l] === "	" || a[l] === ",") && (f = l);
    return a;
  }
  function n(i) {
    return i.replace(/^\s+/, "");
  }
  return nu.exports;
}
var iu = { exports: {} }, au, Wh;
function Po() {
  if (Wh) return au;
  Wh = 1;
  var t = Pe();
  bf(), my(), $e(), au = t.des = t.des || {}, t.des.startEncrypting = function(p, S, A, I) {
    var c = m({
      key: p,
      output: A,
      decrypt: !1,
      mode: I || (S === null ? "ECB" : "CBC")
    });
    return c.start(S), c;
  }, t.des.createEncryptionCipher = function(p, S) {
    return m({
      key: p,
      output: null,
      decrypt: !1,
      mode: S
    });
  }, t.des.startDecrypting = function(p, S, A, I) {
    var c = m({
      key: p,
      output: A,
      decrypt: !0,
      mode: I || (S === null ? "ECB" : "CBC")
    });
    return c.start(S), c;
  }, t.des.createDecryptionCipher = function(p, S) {
    return m({
      key: p,
      output: null,
      decrypt: !0,
      mode: S
    });
  }, t.des.Algorithm = function(p, S) {
    var A = this;
    A.name = p, A.mode = new S({
      blockSize: 8,
      cipher: {
        encrypt: function(I, c) {
          return y(A._keys, I, c, !1);
        },
        decrypt: function(I, c) {
          return y(A._keys, I, c, !0);
        }
      }
    }), A._init = !1;
  }, t.des.Algorithm.prototype.initialize = function(p) {
    if (!this._init) {
      var S = t.util.createBuffer(p.key);
      if (this.name.indexOf("3DES") === 0 && S.length() !== 24)
        throw new Error("Invalid Triple-DES key size: " + S.length() * 8);
      this._keys = f(S), this._init = !0;
    }
  }, e("DES-ECB", t.cipher.modes.ecb), e("DES-CBC", t.cipher.modes.cbc), e("DES-CFB", t.cipher.modes.cfb), e("DES-OFB", t.cipher.modes.ofb), e("DES-CTR", t.cipher.modes.ctr), e("3DES-ECB", t.cipher.modes.ecb), e("3DES-CBC", t.cipher.modes.cbc), e("3DES-CFB", t.cipher.modes.cfb), e("3DES-OFB", t.cipher.modes.ofb), e("3DES-CTR", t.cipher.modes.ctr);
  function e(p, S) {
    var A = function() {
      return new t.des.Algorithm(p, S);
    };
    t.cipher.registerAlgorithm(p, A);
  }
  var r = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], n = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], i = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], a = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], s = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], o = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], l = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], u = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  function f(p) {
    for (var S = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], A = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], I = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], c = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], E = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], v = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], R = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], N = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], C = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], h = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], d = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], O = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], P = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], L = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], D = p.length() > 8 ? 3 : 1, V = [], $ = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], K = 0, Q, ee = 0; ee < D; ee++) {
      var ne = p.getInt32(), ae = p.getInt32();
      Q = (ne >>> 4 ^ ae) & 252645135, ae ^= Q, ne ^= Q << 4, Q = (ae >>> -16 ^ ne) & 65535, ne ^= Q, ae ^= Q << -16, Q = (ne >>> 2 ^ ae) & 858993459, ae ^= Q, ne ^= Q << 2, Q = (ae >>> -16 ^ ne) & 65535, ne ^= Q, ae ^= Q << -16, Q = (ne >>> 1 ^ ae) & 1431655765, ae ^= Q, ne ^= Q << 1, Q = (ae >>> 8 ^ ne) & 16711935, ne ^= Q, ae ^= Q << 8, Q = (ne >>> 1 ^ ae) & 1431655765, ae ^= Q, ne ^= Q << 1, Q = ne << 8 | ae >>> 20 & 240, ne = ae << 24 | ae << 8 & 16711680 | ae >>> 8 & 65280 | ae >>> 24 & 240, ae = Q;
      for (var se = 0; se < $.length; ++se) {
        $[se] ? (ne = ne << 2 | ne >>> 26, ae = ae << 2 | ae >>> 26) : (ne = ne << 1 | ne >>> 27, ae = ae << 1 | ae >>> 27), ne &= -15, ae &= -15;
        var me = S[ne >>> 28] | A[ne >>> 24 & 15] | I[ne >>> 20 & 15] | c[ne >>> 16 & 15] | E[ne >>> 12 & 15] | v[ne >>> 8 & 15] | R[ne >>> 4 & 15], ye = N[ae >>> 28] | C[ae >>> 24 & 15] | h[ae >>> 20 & 15] | d[ae >>> 16 & 15] | O[ae >>> 12 & 15] | P[ae >>> 8 & 15] | L[ae >>> 4 & 15];
        Q = (ye >>> 16 ^ me) & 65535, V[K++] = me ^ Q, V[K++] = ye ^ Q << 16;
      }
    }
    return V;
  }
  function y(p, S, A, I) {
    var c = p.length === 32 ? 3 : 9, E;
    c === 3 ? E = I ? [30, -2, -2] : [0, 32, 2] : E = I ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
    var v, R = S[0], N = S[1];
    v = (R >>> 4 ^ N) & 252645135, N ^= v, R ^= v << 4, v = (R >>> 16 ^ N) & 65535, N ^= v, R ^= v << 16, v = (N >>> 2 ^ R) & 858993459, R ^= v, N ^= v << 2, v = (N >>> 8 ^ R) & 16711935, R ^= v, N ^= v << 8, v = (R >>> 1 ^ N) & 1431655765, N ^= v, R ^= v << 1, R = R << 1 | R >>> 31, N = N << 1 | N >>> 31;
    for (var C = 0; C < c; C += 3) {
      for (var h = E[C + 1], d = E[C + 2], O = E[C]; O != h; O += d) {
        var P = N ^ p[O], L = (N >>> 4 | N << 28) ^ p[O + 1];
        v = R, R = N, N = v ^ (n[P >>> 24 & 63] | a[P >>> 16 & 63] | o[P >>> 8 & 63] | u[P & 63] | r[L >>> 24 & 63] | i[L >>> 16 & 63] | s[L >>> 8 & 63] | l[L & 63]);
      }
      v = R, R = N, N = v;
    }
    R = R >>> 1 | R << 31, N = N >>> 1 | N << 31, v = (R >>> 1 ^ N) & 1431655765, N ^= v, R ^= v << 1, v = (N >>> 8 ^ R) & 16711935, R ^= v, N ^= v << 8, v = (N >>> 2 ^ R) & 858993459, R ^= v, N ^= v << 2, v = (R >>> 16 ^ N) & 65535, N ^= v, R ^= v << 16, v = (R >>> 4 ^ N) & 252645135, N ^= v, R ^= v << 4, A[0] = R, A[1] = N;
  }
  function m(p) {
    p = p || {};
    var S = (p.mode || "CBC").toUpperCase(), A = "DES-" + S, I;
    p.decrypt ? I = t.cipher.createDecipher(A, p.key) : I = t.cipher.createCipher(A, p.key);
    var c = I.start;
    return I.start = function(E, v) {
      var R = null;
      v instanceof t.util.ByteBuffer && (R = v, v = {}), v = v || {}, v.output = R, v.iv = E, c.call(I, v);
    }, I;
  }
  return au;
}
var su, Jh;
function Tf() {
  if (Jh) return su;
  Jh = 1;
  var t = Pe();
  Oa(), dn(), $e();
  var e = t.pkcs5 = t.pkcs5 || {}, r;
  return t.util.isNodejs && !t.options.usePureJavaScript && (r = ge), su = t.pbkdf2 = e.pbkdf2 = function(n, i, a, s, o, l) {
    if (typeof o == "function" && (l = o, o = null), t.util.isNodejs && !t.options.usePureJavaScript && r.pbkdf2 && (o === null || typeof o != "object") && (r.pbkdf2Sync.length > 4 || !o || o === "sha1"))
      return typeof o != "string" && (o = "sha1"), n = Buffer.from(n, "binary"), i = Buffer.from(i, "binary"), l ? r.pbkdf2Sync.length === 4 ? r.pbkdf2(n, i, a, s, function(C, h) {
        if (C)
          return l(C);
        l(null, h.toString("binary"));
      }) : r.pbkdf2(n, i, a, s, o, function(C, h) {
        if (C)
          return l(C);
        l(null, h.toString("binary"));
      }) : r.pbkdf2Sync.length === 4 ? r.pbkdf2Sync(n, i, a, s).toString("binary") : r.pbkdf2Sync(n, i, a, s, o).toString("binary");
    if ((typeof o > "u" || o === null) && (o = "sha1"), typeof o == "string") {
      if (!(o in t.md.algorithms))
        throw new Error("Unknown hash algorithm: " + o);
      o = t.md[o].create();
    }
    var u = o.digestLength;
    if (s > 4294967295 * u) {
      var f = new Error("Derived key is too long.");
      if (l)
        return l(f);
      throw f;
    }
    var y = Math.ceil(s / u), m = s - (y - 1) * u, p = t.hmac.create();
    p.start(o, n);
    var S = "", A, I, c;
    if (!l) {
      for (var E = 1; E <= y; ++E) {
        p.start(null, null), p.update(i), p.update(t.util.int32ToBytes(E)), A = c = p.digest().getBytes();
        for (var v = 2; v <= a; ++v)
          p.start(null, null), p.update(c), I = p.digest().getBytes(), A = t.util.xorBytes(A, I, u), c = I;
        S += E < y ? A : A.substr(0, m);
      }
      return S;
    }
    var E = 1, v;
    function R() {
      if (E > y)
        return l(null, S);
      p.start(null, null), p.update(i), p.update(t.util.int32ToBytes(E)), A = c = p.digest().getBytes(), v = 2, N();
    }
    function N() {
      if (v <= a)
        return p.start(null, null), p.update(c), I = p.digest().getBytes(), A = t.util.xorBytes(A, I, u), c = I, ++v, t.util.setImmediate(N);
      S += E < y ? A : A.substr(0, m), ++E, R();
    }
    R();
  }, su;
}
var Za = { exports: {} }, ou = { exports: {} }, zh;
function Ey() {
  if (zh) return ou.exports;
  zh = 1;
  var t = Pe();
  dn(), $e();
  var e = ou.exports = t.sha256 = t.sha256 || {};
  t.md.sha256 = t.md.algorithms.sha256 = e, e.create = function() {
    n || a();
    var o = null, l = t.util.createBuffer(), u = new Array(64), f = {
      algorithm: "sha256",
      blockLength: 64,
      digestLength: 32,
      // 56-bit length of message so far (does not including padding)
      messageLength: 0,
      // true message length
      fullMessageLength: null,
      // size of message length in bytes
      messageLengthSize: 8
    };
    return f.start = function() {
      f.messageLength = 0, f.fullMessageLength = f.messageLength64 = [];
      for (var y = f.messageLengthSize / 4, m = 0; m < y; ++m)
        f.fullMessageLength.push(0);
      return l = t.util.createBuffer(), o = {
        h0: 1779033703,
        h1: 3144134277,
        h2: 1013904242,
        h3: 2773480762,
        h4: 1359893119,
        h5: 2600822924,
        h6: 528734635,
        h7: 1541459225
      }, f;
    }, f.start(), f.update = function(y, m) {
      m === "utf8" && (y = t.util.encodeUtf8(y));
      var p = y.length;
      f.messageLength += p, p = [p / 4294967296 >>> 0, p >>> 0];
      for (var S = f.fullMessageLength.length - 1; S >= 0; --S)
        f.fullMessageLength[S] += p[1], p[1] = p[0] + (f.fullMessageLength[S] / 4294967296 >>> 0), f.fullMessageLength[S] = f.fullMessageLength[S] >>> 0, p[0] = p[1] / 4294967296 >>> 0;
      return l.putBytes(y), s(o, u, l), (l.read > 2048 || l.length() === 0) && l.compact(), f;
    }, f.digest = function() {
      var y = t.util.createBuffer();
      y.putBytes(l.bytes());
      var m = f.fullMessageLength[f.fullMessageLength.length - 1] + f.messageLengthSize, p = m & f.blockLength - 1;
      y.putBytes(r.substr(0, f.blockLength - p));
      for (var S, A, I = f.fullMessageLength[0] * 8, c = 0; c < f.fullMessageLength.length - 1; ++c)
        S = f.fullMessageLength[c + 1] * 8, A = S / 4294967296 >>> 0, I += A, y.putInt32(I >>> 0), I = S >>> 0;
      y.putInt32(I);
      var E = {
        h0: o.h0,
        h1: o.h1,
        h2: o.h2,
        h3: o.h3,
        h4: o.h4,
        h5: o.h5,
        h6: o.h6,
        h7: o.h7
      };
      s(E, u, y);
      var v = t.util.createBuffer();
      return v.putInt32(E.h0), v.putInt32(E.h1), v.putInt32(E.h2), v.putInt32(E.h3), v.putInt32(E.h4), v.putInt32(E.h5), v.putInt32(E.h6), v.putInt32(E.h7), v;
    }, f;
  };
  var r = null, n = !1, i = null;
  function a() {
    r = "", r += t.util.fillString("\0", 64), i = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], n = !0;
  }
  function s(o, l, u) {
    for (var f, y, m, p, S, A, I, c, E, v, R, N, C, h, d, O = u.length(); O >= 64; ) {
      for (I = 0; I < 16; ++I)
        l[I] = u.getInt32();
      for (; I < 64; ++I)
        f = l[I - 2], f = (f >>> 17 | f << 15) ^ (f >>> 19 | f << 13) ^ f >>> 10, y = l[I - 15], y = (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3, l[I] = f + l[I - 7] + y + l[I - 16] | 0;
      for (c = o.h0, E = o.h1, v = o.h2, R = o.h3, N = o.h4, C = o.h5, h = o.h6, d = o.h7, I = 0; I < 64; ++I)
        p = (N >>> 6 | N << 26) ^ (N >>> 11 | N << 21) ^ (N >>> 25 | N << 7), S = h ^ N & (C ^ h), m = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), A = c & E | v & (c ^ E), f = d + p + S + i[I] + l[I], y = m + A, d = h, h = C, C = N, N = R + f >>> 0, R = v, v = E, E = c, c = f + y >>> 0;
      o.h0 = o.h0 + c | 0, o.h1 = o.h1 + E | 0, o.h2 = o.h2 + v | 0, o.h3 = o.h3 + R | 0, o.h4 = o.h4 + N | 0, o.h5 = o.h5 + C | 0, o.h6 = o.h6 + h | 0, o.h7 = o.h7 + d | 0, O -= 64;
    }
  }
  return ou.exports;
}
var cu = { exports: {} }, Xh;
function vy() {
  if (Xh) return cu.exports;
  Xh = 1;
  var t = Pe();
  $e();
  var e = null;
  t.util.isNodejs && !t.options.usePureJavaScript && !process.versions["node-webkit"] && (e = ge);
  var r = cu.exports = t.prng = t.prng || {};
  return r.create = function(n) {
    for (var i = {
      plugin: n,
      key: null,
      seed: null,
      time: null,
      // number of reseeds so far
      reseeds: 0,
      // amount of data generated so far
      generated: 0,
      // no initial key bytes
      keyBytes: ""
    }, a = n.md, s = new Array(32), o = 0; o < 32; ++o)
      s[o] = a.create();
    i.pools = s, i.pool = 0, i.generate = function(m, p) {
      if (!p)
        return i.generateSync(m);
      var S = i.plugin.cipher, A = i.plugin.increment, I = i.plugin.formatKey, c = i.plugin.formatSeed, E = t.util.createBuffer();
      i.key = null, v();
      function v(R) {
        if (R)
          return p(R);
        if (E.length() >= m)
          return p(null, E.getBytes(m));
        if (i.generated > 1048575 && (i.key = null), i.key === null)
          return t.util.nextTick(function() {
            l(v);
          });
        var N = S(i.key, i.seed);
        i.generated += N.length, E.putBytes(N), i.key = I(S(i.key, A(i.seed))), i.seed = c(S(i.key, i.seed)), t.util.setImmediate(v);
      }
    }, i.generateSync = function(m) {
      var p = i.plugin.cipher, S = i.plugin.increment, A = i.plugin.formatKey, I = i.plugin.formatSeed;
      i.key = null;
      for (var c = t.util.createBuffer(); c.length() < m; ) {
        i.generated > 1048575 && (i.key = null), i.key === null && u();
        var E = p(i.key, i.seed);
        i.generated += E.length, c.putBytes(E), i.key = A(p(i.key, S(i.seed))), i.seed = I(p(i.key, i.seed));
      }
      return c.getBytes(m);
    };
    function l(m) {
      if (i.pools[0].messageLength >= 32)
        return f(), m();
      var p = 32 - i.pools[0].messageLength << 5;
      i.seedFile(p, function(S, A) {
        if (S)
          return m(S);
        i.collect(A), f(), m();
      });
    }
    function u() {
      if (i.pools[0].messageLength >= 32)
        return f();
      var m = 32 - i.pools[0].messageLength << 5;
      i.collect(i.seedFileSync(m)), f();
    }
    function f() {
      i.reseeds = i.reseeds === 4294967295 ? 0 : i.reseeds + 1;
      var m = i.plugin.md.create();
      m.update(i.keyBytes);
      for (var p = 1, S = 0; S < 32; ++S)
        i.reseeds % p === 0 && (m.update(i.pools[S].digest().getBytes()), i.pools[S].start()), p = p << 1;
      i.keyBytes = m.digest().getBytes(), m.start(), m.update(i.keyBytes);
      var A = m.digest().getBytes();
      i.key = i.plugin.formatKey(i.keyBytes), i.seed = i.plugin.formatSeed(A), i.generated = 0;
    }
    function y(m) {
      var p = null, S = t.util.globalScope, A = S.crypto || S.msCrypto;
      A && A.getRandomValues && (p = function(d) {
        return A.getRandomValues(d);
      });
      var I = t.util.createBuffer();
      if (p)
        for (; I.length() < m; ) {
          var c = Math.max(1, Math.min(m - I.length(), 65536) / 4), E = new Uint32Array(Math.floor(c));
          try {
            p(E);
            for (var v = 0; v < E.length; ++v)
              I.putInt32(E[v]);
          } catch (d) {
            if (!(typeof QuotaExceededError < "u" && d instanceof QuotaExceededError))
              throw d;
          }
        }
      if (I.length() < m)
        for (var R, N, C, h = Math.floor(Math.random() * 65536); I.length() < m; ) {
          N = 16807 * (h & 65535), R = 16807 * (h >> 16), N += (R & 32767) << 16, N += R >> 15, N = (N & 2147483647) + (N >> 31), h = N & 4294967295;
          for (var v = 0; v < 3; ++v)
            C = h >>> (v << 3), C ^= Math.floor(Math.random() * 256), I.putByte(C & 255);
        }
      return I.getBytes(m);
    }
    return e ? (i.seedFile = function(m, p) {
      e.randomBytes(m, function(S, A) {
        if (S)
          return p(S);
        p(null, A.toString());
      });
    }, i.seedFileSync = function(m) {
      return e.randomBytes(m).toString();
    }) : (i.seedFile = function(m, p) {
      try {
        p(null, y(m));
      } catch (S) {
        p(S);
      }
    }, i.seedFileSync = y), i.collect = function(m) {
      for (var p = m.length, S = 0; S < p; ++S)
        i.pools[i.pool].update(m.substr(S, 1)), i.pool = i.pool === 31 ? 0 : i.pool + 1;
    }, i.collectInt = function(m, p) {
      for (var S = "", A = 0; A < p; A += 8)
        S += String.fromCharCode(m >> A & 255);
      i.collect(S);
    }, i.registerWorker = function(m) {
      if (m === self)
        i.seedFile = function(S, A) {
          function I(c) {
            var E = c.data;
            E.forge && E.forge.prng && (self.removeEventListener("message", I), A(E.forge.prng.err, E.forge.prng.bytes));
          }
          self.addEventListener("message", I), self.postMessage({ forge: { prng: { needed: S } } });
        };
      else {
        var p = function(S) {
          var A = S.data;
          A.forge && A.forge.prng && i.seedFile(A.forge.prng.needed, function(I, c) {
            m.postMessage({ forge: { prng: { err: I, bytes: c } } });
          });
        };
        m.addEventListener("message", p);
      }
    }, i;
  }, cu.exports;
}
var Yh;
function Pr() {
  if (Yh) return Za.exports;
  Yh = 1;
  var t = Pe();
  return ni(), Ey(), vy(), $e(), function() {
    if (t.random && t.random.getBytes) {
      Za.exports = t.random;
      return;
    }
    (function(e) {
      var r = {}, n = new Array(4), i = t.util.createBuffer();
      r.formatKey = function(m) {
        var p = t.util.createBuffer(m);
        return m = new Array(4), m[0] = p.getInt32(), m[1] = p.getInt32(), m[2] = p.getInt32(), m[3] = p.getInt32(), t.aes._expandKey(m, !1);
      }, r.formatSeed = function(m) {
        var p = t.util.createBuffer(m);
        return m = new Array(4), m[0] = p.getInt32(), m[1] = p.getInt32(), m[2] = p.getInt32(), m[3] = p.getInt32(), m;
      }, r.cipher = function(m, p) {
        return t.aes._updateBlock(m, p, n, !1), i.putInt32(n[0]), i.putInt32(n[1]), i.putInt32(n[2]), i.putInt32(n[3]), i.getBytes();
      }, r.increment = function(m) {
        return ++m[3], m;
      }, r.md = t.md.sha256;
      function a() {
        var m = t.prng.create(r);
        return m.getBytes = function(p, S) {
          return m.generate(p, S);
        }, m.getBytesSync = function(p) {
          return m.generate(p);
        }, m;
      }
      var s = a(), o = null, l = t.util.globalScope, u = l.crypto || l.msCrypto;
      if (u && u.getRandomValues && (o = function(m) {
        return u.getRandomValues(m);
      }), t.options.usePureJavaScript || !t.util.isNodejs && !o) {
        if (s.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
          var f = "";
          for (var y in navigator)
            try {
              typeof navigator[y] == "string" && (f += navigator[y]);
            } catch {
            }
          s.collect(f), f = null;
        }
        e && (e().mousemove(function(m) {
          s.collectInt(m.clientX, 16), s.collectInt(m.clientY, 16);
        }), e().keypress(function(m) {
          s.collectInt(m.charCode, 8);
        }));
      }
      if (!t.random)
        t.random = s;
      else
        for (var y in s)
          t.random[y] = s[y];
      t.random.createInstance = a, Za.exports = t.random;
    })(typeof jQuery < "u" ? jQuery : null);
  }(), Za.exports;
}
var uu, Qh;
function Ay() {
  if (Qh) return uu;
  Qh = 1;
  var t = Pe();
  $e();
  var e = [
    217,
    120,
    249,
    196,
    25,
    221,
    181,
    237,
    40,
    233,
    253,
    121,
    74,
    160,
    216,
    157,
    198,
    126,
    55,
    131,
    43,
    118,
    83,
    142,
    98,
    76,
    100,
    136,
    68,
    139,
    251,
    162,
    23,
    154,
    89,
    245,
    135,
    179,
    79,
    19,
    97,
    69,
    109,
    141,
    9,
    129,
    125,
    50,
    189,
    143,
    64,
    235,
    134,
    183,
    123,
    11,
    240,
    149,
    33,
    34,
    92,
    107,
    78,
    130,
    84,
    214,
    101,
    147,
    206,
    96,
    178,
    28,
    115,
    86,
    192,
    20,
    167,
    140,
    241,
    220,
    18,
    117,
    202,
    31,
    59,
    190,
    228,
    209,
    66,
    61,
    212,
    48,
    163,
    60,
    182,
    38,
    111,
    191,
    14,
    218,
    70,
    105,
    7,
    87,
    39,
    242,
    29,
    155,
    188,
    148,
    67,
    3,
    248,
    17,
    199,
    246,
    144,
    239,
    62,
    231,
    6,
    195,
    213,
    47,
    200,
    102,
    30,
    215,
    8,
    232,
    234,
    222,
    128,
    82,
    238,
    247,
    132,
    170,
    114,
    172,
    53,
    77,
    106,
    42,
    150,
    26,
    210,
    113,
    90,
    21,
    73,
    116,
    75,
    159,
    208,
    94,
    4,
    24,
    164,
    236,
    194,
    224,
    65,
    110,
    15,
    81,
    203,
    204,
    36,
    145,
    175,
    80,
    161,
    244,
    112,
    57,
    153,
    124,
    58,
    133,
    35,
    184,
    180,
    122,
    252,
    2,
    54,
    91,
    37,
    85,
    151,
    49,
    45,
    93,
    250,
    152,
    227,
    138,
    146,
    174,
    5,
    223,
    41,
    16,
    103,
    108,
    186,
    201,
    211,
    0,
    230,
    207,
    225,
    158,
    168,
    44,
    99,
    22,
    1,
    63,
    88,
    226,
    137,
    169,
    13,
    56,
    52,
    27,
    171,
    51,
    255,
    176,
    187,
    72,
    12,
    95,
    185,
    177,
    205,
    46,
    197,
    243,
    219,
    71,
    229,
    165,
    156,
    119,
    10,
    166,
    32,
    104,
    254,
    127,
    193,
    173
  ], r = [1, 2, 3, 5], n = function(s, o) {
    return s << o & 65535 | (s & 65535) >> 16 - o;
  }, i = function(s, o) {
    return (s & 65535) >> o | s << 16 - o & 65535;
  };
  uu = t.rc2 = t.rc2 || {}, t.rc2.expandKey = function(s, o) {
    typeof s == "string" && (s = t.util.createBuffer(s)), o = o || 128;
    var l = s, u = s.length(), f = o, y = Math.ceil(f / 8), m = 255 >> (f & 7), p;
    for (p = u; p < 128; p++)
      l.putByte(e[l.at(p - 1) + l.at(p - u) & 255]);
    for (l.setAt(128 - y, e[l.at(128 - y) & m]), p = 127 - y; p >= 0; p--)
      l.setAt(p, e[l.at(p + 1) ^ l.at(p + y)]);
    return l;
  };
  var a = function(s, o, l) {
    var u = !1, f = null, y = null, m = null, p, S, A, I, c = [];
    for (s = t.rc2.expandKey(s, o), A = 0; A < 64; A++)
      c.push(s.getInt16Le());
    l ? (p = function(R) {
      for (A = 0; A < 4; A++)
        R[A] += c[I] + (R[(A + 3) % 4] & R[(A + 2) % 4]) + (~R[(A + 3) % 4] & R[(A + 1) % 4]), R[A] = n(R[A], r[A]), I++;
    }, S = function(R) {
      for (A = 0; A < 4; A++)
        R[A] += c[R[(A + 3) % 4] & 63];
    }) : (p = function(R) {
      for (A = 3; A >= 0; A--)
        R[A] = i(R[A], r[A]), R[A] -= c[I] + (R[(A + 3) % 4] & R[(A + 2) % 4]) + (~R[(A + 3) % 4] & R[(A + 1) % 4]), I--;
    }, S = function(R) {
      for (A = 3; A >= 0; A--)
        R[A] -= c[R[(A + 3) % 4] & 63];
    });
    var E = function(R) {
      var N = [];
      for (A = 0; A < 4; A++) {
        var C = f.getInt16Le();
        m !== null && (l ? C ^= m.getInt16Le() : m.putInt16Le(C)), N.push(C & 65535);
      }
      I = l ? 0 : 63;
      for (var h = 0; h < R.length; h++)
        for (var d = 0; d < R[h][0]; d++)
          R[h][1](N);
      for (A = 0; A < 4; A++)
        m !== null && (l ? m.putInt16Le(N[A]) : N[A] ^= m.getInt16Le()), y.putInt16Le(N[A]);
    }, v = null;
    return v = {
      /**
       * Starts or restarts the encryption or decryption process, whichever
       * was previously configured.
       *
       * To use the cipher in CBC mode, iv may be given either as a string
       * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
       *
       * @param iv the initialization vector to use, null for ECB mode.
       * @param output the output the buffer to write to, null to create one.
       */
      start: function(R, N) {
        R && typeof R == "string" && (R = t.util.createBuffer(R)), u = !1, f = t.util.createBuffer(), y = N || new t.util.createBuffer(), m = R, v.output = y;
      },
      /**
       * Updates the next block.
       *
       * @param input the buffer to read from.
       */
      update: function(R) {
        for (u || f.putBuffer(R); f.length() >= 8; )
          E([
            [5, p],
            [1, S],
            [6, p],
            [1, S],
            [5, p]
          ]);
      },
      /**
       * Finishes encrypting or decrypting.
       *
       * @param pad a padding function to use, null for PKCS#7 padding,
       *           signature(blockSize, buffer, decrypt).
       *
       * @return true if successful, false on error.
       */
      finish: function(R) {
        var N = !0;
        if (l)
          if (R)
            N = R(8, f, !l);
          else {
            var C = f.length() === 8 ? 8 : 8 - f.length();
            f.fillWithByte(C, C);
          }
        if (N && (u = !0, v.update()), !l && (N = f.length() === 0, N))
          if (R)
            N = R(8, y, !l);
          else {
            var h = y.length(), d = y.at(h - 1);
            d > h ? N = !1 : y.truncate(d);
          }
        return N;
      }
    }, v;
  };
  return t.rc2.startEncrypting = function(s, o, l) {
    var u = t.rc2.createEncryptionCipher(s, 128);
    return u.start(o, l), u;
  }, t.rc2.createEncryptionCipher = function(s, o) {
    return a(s, o, !0);
  }, t.rc2.startDecrypting = function(s, o, l) {
    var u = t.rc2.createDecryptionCipher(s, 128);
    return u.start(o, l), u;
  }, t.rc2.createDecryptionCipher = function(s, o) {
    return a(s, o, !1);
  }, uu;
}
var lu, Zh;
function ko() {
  if (Zh) return lu;
  Zh = 1;
  var t = Pe();
  lu = t.jsbn = t.jsbn || {};
  var e;
  function r(B, F, H) {
    this.data = [], B != null && (typeof B == "number" ? this.fromNumber(B, F, H) : F == null && typeof B != "string" ? this.fromString(B, 256) : this.fromString(B, F));
  }
  t.jsbn.BigInteger = r;
  function n() {
    return new r(null);
  }
  function i(B, F, H, re, ce, le) {
    for (; --le >= 0; ) {
      var Ae = F * this.data[B++] + H.data[re] + ce;
      ce = Math.floor(Ae / 67108864), H.data[re++] = Ae & 67108863;
    }
    return ce;
  }
  function a(B, F, H, re, ce, le) {
    for (var Ae = F & 32767, ve = F >> 15; --le >= 0; ) {
      var Ke = this.data[B] & 32767, St = this.data[B++] >> 15, Jt = ve * Ke + St * Ae;
      Ke = Ae * Ke + ((Jt & 32767) << 15) + H.data[re] + (ce & 1073741823), ce = (Ke >>> 30) + (Jt >>> 15) + ve * St + (ce >>> 30), H.data[re++] = Ke & 1073741823;
    }
    return ce;
  }
  function s(B, F, H, re, ce, le) {
    for (var Ae = F & 16383, ve = F >> 14; --le >= 0; ) {
      var Ke = this.data[B] & 16383, St = this.data[B++] >> 14, Jt = ve * Ke + St * Ae;
      Ke = Ae * Ke + ((Jt & 16383) << 14) + H.data[re] + ce, ce = (Ke >> 28) + (Jt >> 14) + ve * St, H.data[re++] = Ke & 268435455;
    }
    return ce;
  }
  typeof navigator > "u" ? (r.prototype.am = s, e = 28) : navigator.appName == "Microsoft Internet Explorer" ? (r.prototype.am = a, e = 30) : navigator.appName != "Netscape" ? (r.prototype.am = i, e = 26) : (r.prototype.am = s, e = 28), r.prototype.DB = e, r.prototype.DM = (1 << e) - 1, r.prototype.DV = 1 << e;
  var o = 52;
  r.prototype.FV = Math.pow(2, o), r.prototype.F1 = o - e, r.prototype.F2 = 2 * e - o;
  var l = "0123456789abcdefghijklmnopqrstuvwxyz", u = new Array(), f, y;
  for (f = 48, y = 0; y <= 9; ++y) u[f++] = y;
  for (f = 97, y = 10; y < 36; ++y) u[f++] = y;
  for (f = 65, y = 10; y < 36; ++y) u[f++] = y;
  function m(B) {
    return l.charAt(B);
  }
  function p(B, F) {
    var H = u[B.charCodeAt(F)];
    return H ?? -1;
  }
  function S(B) {
    for (var F = this.t - 1; F >= 0; --F) B.data[F] = this.data[F];
    B.t = this.t, B.s = this.s;
  }
  function A(B) {
    this.t = 1, this.s = B < 0 ? -1 : 0, B > 0 ? this.data[0] = B : B < -1 ? this.data[0] = B + this.DV : this.t = 0;
  }
  function I(B) {
    var F = n();
    return F.fromInt(B), F;
  }
  function c(B, F) {
    var H;
    if (F == 16) H = 4;
    else if (F == 8) H = 3;
    else if (F == 256) H = 8;
    else if (F == 2) H = 1;
    else if (F == 32) H = 5;
    else if (F == 4) H = 2;
    else {
      this.fromRadix(B, F);
      return;
    }
    this.t = 0, this.s = 0;
    for (var re = B.length, ce = !1, le = 0; --re >= 0; ) {
      var Ae = H == 8 ? B[re] & 255 : p(B, re);
      if (Ae < 0) {
        B.charAt(re) == "-" && (ce = !0);
        continue;
      }
      ce = !1, le == 0 ? this.data[this.t++] = Ae : le + H > this.DB ? (this.data[this.t - 1] |= (Ae & (1 << this.DB - le) - 1) << le, this.data[this.t++] = Ae >> this.DB - le) : this.data[this.t - 1] |= Ae << le, le += H, le >= this.DB && (le -= this.DB);
    }
    H == 8 && B[0] & 128 && (this.s = -1, le > 0 && (this.data[this.t - 1] |= (1 << this.DB - le) - 1 << le)), this.clamp(), ce && r.ZERO.subTo(this, this);
  }
  function E() {
    for (var B = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == B; ) --this.t;
  }
  function v(B) {
    if (this.s < 0) return "-" + this.negate().toString(B);
    var F;
    if (B == 16) F = 4;
    else if (B == 8) F = 3;
    else if (B == 2) F = 1;
    else if (B == 32) F = 5;
    else if (B == 4) F = 2;
    else return this.toRadix(B);
    var H = (1 << F) - 1, re, ce = !1, le = "", Ae = this.t, ve = this.DB - Ae * this.DB % F;
    if (Ae-- > 0)
      for (ve < this.DB && (re = this.data[Ae] >> ve) > 0 && (ce = !0, le = m(re)); Ae >= 0; )
        ve < F ? (re = (this.data[Ae] & (1 << ve) - 1) << F - ve, re |= this.data[--Ae] >> (ve += this.DB - F)) : (re = this.data[Ae] >> (ve -= F) & H, ve <= 0 && (ve += this.DB, --Ae)), re > 0 && (ce = !0), ce && (le += m(re));
    return ce ? le : "0";
  }
  function R() {
    var B = n();
    return r.ZERO.subTo(this, B), B;
  }
  function N() {
    return this.s < 0 ? this.negate() : this;
  }
  function C(B) {
    var F = this.s - B.s;
    if (F != 0) return F;
    var H = this.t;
    if (F = H - B.t, F != 0) return this.s < 0 ? -F : F;
    for (; --H >= 0; ) if ((F = this.data[H] - B.data[H]) != 0) return F;
    return 0;
  }
  function h(B) {
    var F = 1, H;
    return (H = B >>> 16) != 0 && (B = H, F += 16), (H = B >> 8) != 0 && (B = H, F += 8), (H = B >> 4) != 0 && (B = H, F += 4), (H = B >> 2) != 0 && (B = H, F += 2), (H = B >> 1) != 0 && (B = H, F += 1), F;
  }
  function d() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + h(this.data[this.t - 1] ^ this.s & this.DM);
  }
  function O(B, F) {
    var H;
    for (H = this.t - 1; H >= 0; --H) F.data[H + B] = this.data[H];
    for (H = B - 1; H >= 0; --H) F.data[H] = 0;
    F.t = this.t + B, F.s = this.s;
  }
  function P(B, F) {
    for (var H = B; H < this.t; ++H) F.data[H - B] = this.data[H];
    F.t = Math.max(this.t - B, 0), F.s = this.s;
  }
  function L(B, F) {
    var H = B % this.DB, re = this.DB - H, ce = (1 << re) - 1, le = Math.floor(B / this.DB), Ae = this.s << H & this.DM, ve;
    for (ve = this.t - 1; ve >= 0; --ve)
      F.data[ve + le + 1] = this.data[ve] >> re | Ae, Ae = (this.data[ve] & ce) << H;
    for (ve = le - 1; ve >= 0; --ve) F.data[ve] = 0;
    F.data[le] = Ae, F.t = this.t + le + 1, F.s = this.s, F.clamp();
  }
  function D(B, F) {
    F.s = this.s;
    var H = Math.floor(B / this.DB);
    if (H >= this.t) {
      F.t = 0;
      return;
    }
    var re = B % this.DB, ce = this.DB - re, le = (1 << re) - 1;
    F.data[0] = this.data[H] >> re;
    for (var Ae = H + 1; Ae < this.t; ++Ae)
      F.data[Ae - H - 1] |= (this.data[Ae] & le) << ce, F.data[Ae - H] = this.data[Ae] >> re;
    re > 0 && (F.data[this.t - H - 1] |= (this.s & le) << ce), F.t = this.t - H, F.clamp();
  }
  function V(B, F) {
    for (var H = 0, re = 0, ce = Math.min(B.t, this.t); H < ce; )
      re += this.data[H] - B.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
    if (B.t < this.t) {
      for (re -= B.s; H < this.t; )
        re += this.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
      re += this.s;
    } else {
      for (re += this.s; H < B.t; )
        re -= B.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
      re -= B.s;
    }
    F.s = re < 0 ? -1 : 0, re < -1 ? F.data[H++] = this.DV + re : re > 0 && (F.data[H++] = re), F.t = H, F.clamp();
  }
  function $(B, F) {
    var H = this.abs(), re = B.abs(), ce = H.t;
    for (F.t = ce + re.t; --ce >= 0; ) F.data[ce] = 0;
    for (ce = 0; ce < re.t; ++ce) F.data[ce + H.t] = H.am(0, re.data[ce], F, ce, 0, H.t);
    F.s = 0, F.clamp(), this.s != B.s && r.ZERO.subTo(F, F);
  }
  function K(B) {
    for (var F = this.abs(), H = B.t = 2 * F.t; --H >= 0; ) B.data[H] = 0;
    for (H = 0; H < F.t - 1; ++H) {
      var re = F.am(H, F.data[H], B, 2 * H, 0, 1);
      (B.data[H + F.t] += F.am(H + 1, 2 * F.data[H], B, 2 * H + 1, re, F.t - H - 1)) >= F.DV && (B.data[H + F.t] -= F.DV, B.data[H + F.t + 1] = 1);
    }
    B.t > 0 && (B.data[B.t - 1] += F.am(H, F.data[H], B, 2 * H, 0, 1)), B.s = 0, B.clamp();
  }
  function Q(B, F, H) {
    var re = B.abs();
    if (!(re.t <= 0)) {
      var ce = this.abs();
      if (ce.t < re.t) {
        F != null && F.fromInt(0), H != null && this.copyTo(H);
        return;
      }
      H == null && (H = n());
      var le = n(), Ae = this.s, ve = B.s, Ke = this.DB - h(re.data[re.t - 1]);
      Ke > 0 ? (re.lShiftTo(Ke, le), ce.lShiftTo(Ke, H)) : (re.copyTo(le), ce.copyTo(H));
      var St = le.t, Jt = le.data[St - 1];
      if (Jt != 0) {
        var Kt = Jt * (1 << this.F1) + (St > 1 ? le.data[St - 2] >> this.F2 : 0), Sr = this.FV / Kt, ui = (1 << this.F1) / Kt, zt = 1 << this.F2, ar = H.t, li = ar - St, sr = F ?? n();
        for (le.dlShiftTo(li, sr), H.compareTo(sr) >= 0 && (H.data[H.t++] = 1, H.subTo(sr, H)), r.ONE.dlShiftTo(St, sr), sr.subTo(le, le); le.t < St; ) le.data[le.t++] = 0;
        for (; --li >= 0; ) {
          var Ur = H.data[--ar] == Jt ? this.DM : Math.floor(H.data[ar] * Sr + (H.data[ar - 1] + zt) * ui);
          if ((H.data[ar] += le.am(0, Ur, H, li, 0, St)) < Ur)
            for (le.dlShiftTo(li, sr), H.subTo(sr, H); H.data[ar] < --Ur; ) H.subTo(sr, H);
        }
        F != null && (H.drShiftTo(St, F), Ae != ve && r.ZERO.subTo(F, F)), H.t = St, H.clamp(), Ke > 0 && H.rShiftTo(Ke, H), Ae < 0 && r.ZERO.subTo(H, H);
      }
    }
  }
  function ee(B) {
    var F = n();
    return this.abs().divRemTo(B, null, F), this.s < 0 && F.compareTo(r.ZERO) > 0 && B.subTo(F, F), F;
  }
  function ne(B) {
    this.m = B;
  }
  function ae(B) {
    return B.s < 0 || B.compareTo(this.m) >= 0 ? B.mod(this.m) : B;
  }
  function se(B) {
    return B;
  }
  function me(B) {
    B.divRemTo(this.m, null, B);
  }
  function ye(B, F, H) {
    B.multiplyTo(F, H), this.reduce(H);
  }
  function Se(B, F) {
    B.squareTo(F), this.reduce(F);
  }
  ne.prototype.convert = ae, ne.prototype.revert = se, ne.prototype.reduce = me, ne.prototype.mulTo = ye, ne.prototype.sqrTo = Se;
  function te() {
    if (this.t < 1) return 0;
    var B = this.data[0];
    if (!(B & 1)) return 0;
    var F = B & 3;
    return F = F * (2 - (B & 15) * F) & 15, F = F * (2 - (B & 255) * F) & 255, F = F * (2 - ((B & 65535) * F & 65535)) & 65535, F = F * (2 - B * F % this.DV) % this.DV, F > 0 ? this.DV - F : -F;
  }
  function Ce(B) {
    this.m = B, this.mp = B.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << B.DB - 15) - 1, this.mt2 = 2 * B.t;
  }
  function fe(B) {
    var F = n();
    return B.abs().dlShiftTo(this.m.t, F), F.divRemTo(this.m, null, F), B.s < 0 && F.compareTo(r.ZERO) > 0 && this.m.subTo(F, F), F;
  }
  function De(B) {
    var F = n();
    return B.copyTo(F), this.reduce(F), F;
  }
  function _e(B) {
    for (; B.t <= this.mt2; )
      B.data[B.t++] = 0;
    for (var F = 0; F < this.m.t; ++F) {
      var H = B.data[F] & 32767, re = H * this.mpl + ((H * this.mph + (B.data[F] >> 15) * this.mpl & this.um) << 15) & B.DM;
      for (H = F + this.m.t, B.data[H] += this.m.am(0, re, B, F, 0, this.m.t); B.data[H] >= B.DV; )
        B.data[H] -= B.DV, B.data[++H]++;
    }
    B.clamp(), B.drShiftTo(this.m.t, B), B.compareTo(this.m) >= 0 && B.subTo(this.m, B);
  }
  function w(B, F) {
    B.squareTo(F), this.reduce(F);
  }
  function b(B, F, H) {
    B.multiplyTo(F, H), this.reduce(H);
  }
  Ce.prototype.convert = fe, Ce.prototype.revert = De, Ce.prototype.reduce = _e, Ce.prototype.mulTo = b, Ce.prototype.sqrTo = w;
  function T() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
  }
  function g(B, F) {
    if (B > 4294967295 || B < 1) return r.ONE;
    var H = n(), re = n(), ce = F.convert(this), le = h(B) - 1;
    for (ce.copyTo(H); --le >= 0; )
      if (F.sqrTo(H, re), (B & 1 << le) > 0) F.mulTo(re, ce, H);
      else {
        var Ae = H;
        H = re, re = Ae;
      }
    return F.revert(H);
  }
  function x(B, F) {
    var H;
    return B < 256 || F.isEven() ? H = new ne(F) : H = new Ce(F), this.exp(B, H);
  }
  r.prototype.copyTo = S, r.prototype.fromInt = A, r.prototype.fromString = c, r.prototype.clamp = E, r.prototype.dlShiftTo = O, r.prototype.drShiftTo = P, r.prototype.lShiftTo = L, r.prototype.rShiftTo = D, r.prototype.subTo = V, r.prototype.multiplyTo = $, r.prototype.squareTo = K, r.prototype.divRemTo = Q, r.prototype.invDigit = te, r.prototype.isEven = T, r.prototype.exp = g, r.prototype.toString = v, r.prototype.negate = R, r.prototype.abs = N, r.prototype.compareTo = C, r.prototype.bitLength = d, r.prototype.mod = ee, r.prototype.modPowInt = x, r.ZERO = I(0), r.ONE = I(1);
  function U() {
    var B = n();
    return this.copyTo(B), B;
  }
  function k() {
    if (this.s < 0) {
      if (this.t == 1) return this.data[0] - this.DV;
      if (this.t == 0) return -1;
    } else {
      if (this.t == 1) return this.data[0];
      if (this.t == 0) return 0;
    }
    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
  }
  function W() {
    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
  }
  function q() {
    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
  }
  function z(B) {
    return Math.floor(Math.LN2 * this.DB / Math.log(B));
  }
  function j() {
    return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
  }
  function Y(B) {
    if (B == null && (B = 10), this.signum() == 0 || B < 2 || B > 36) return "0";
    var F = this.chunkSize(B), H = Math.pow(B, F), re = I(H), ce = n(), le = n(), Ae = "";
    for (this.divRemTo(re, ce, le); ce.signum() > 0; )
      Ae = (H + le.intValue()).toString(B).substr(1) + Ae, ce.divRemTo(re, ce, le);
    return le.intValue().toString(B) + Ae;
  }
  function M(B, F) {
    this.fromInt(0), F == null && (F = 10);
    for (var H = this.chunkSize(F), re = Math.pow(F, H), ce = !1, le = 0, Ae = 0, ve = 0; ve < B.length; ++ve) {
      var Ke = p(B, ve);
      if (Ke < 0) {
        B.charAt(ve) == "-" && this.signum() == 0 && (ce = !0);
        continue;
      }
      Ae = F * Ae + Ke, ++le >= H && (this.dMultiply(re), this.dAddOffset(Ae, 0), le = 0, Ae = 0);
    }
    le > 0 && (this.dMultiply(Math.pow(F, le)), this.dAddOffset(Ae, 0)), ce && r.ZERO.subTo(this, this);
  }
  function X(B, F, H) {
    if (typeof F == "number")
      if (B < 2) this.fromInt(1);
      else
        for (this.fromNumber(B, H), this.testBit(B - 1) || this.bitwiseTo(r.ONE.shiftLeft(B - 1), ze, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(F); )
          this.dAddOffset(2, 0), this.bitLength() > B && this.subTo(r.ONE.shiftLeft(B - 1), this);
    else {
      var re = new Array(), ce = B & 7;
      re.length = (B >> 3) + 1, F.nextBytes(re), ce > 0 ? re[0] &= (1 << ce) - 1 : re[0] = 0, this.fromString(re, 256);
    }
  }
  function J() {
    var B = this.t, F = new Array();
    F[0] = this.s;
    var H = this.DB - B * this.DB % 8, re, ce = 0;
    if (B-- > 0)
      for (H < this.DB && (re = this.data[B] >> H) != (this.s & this.DM) >> H && (F[ce++] = re | this.s << this.DB - H); B >= 0; )
        H < 8 ? (re = (this.data[B] & (1 << H) - 1) << 8 - H, re |= this.data[--B] >> (H += this.DB - 8)) : (re = this.data[B] >> (H -= 8) & 255, H <= 0 && (H += this.DB, --B)), re & 128 && (re |= -256), ce == 0 && (this.s & 128) != (re & 128) && ++ce, (ce > 0 || re != this.s) && (F[ce++] = re);
    return F;
  }
  function Z(B) {
    return this.compareTo(B) == 0;
  }
  function oe(B) {
    return this.compareTo(B) < 0 ? this : B;
  }
  function he(B) {
    return this.compareTo(B) > 0 ? this : B;
  }
  function Ee(B, F, H) {
    var re, ce, le = Math.min(B.t, this.t);
    for (re = 0; re < le; ++re) H.data[re] = F(this.data[re], B.data[re]);
    if (B.t < this.t) {
      for (ce = B.s & this.DM, re = le; re < this.t; ++re) H.data[re] = F(this.data[re], ce);
      H.t = this.t;
    } else {
      for (ce = this.s & this.DM, re = le; re < B.t; ++re) H.data[re] = F(ce, B.data[re]);
      H.t = B.t;
    }
    H.s = F(this.s, B.s), H.clamp();
  }
  function be(B, F) {
    return B & F;
  }
  function Re(B) {
    var F = n();
    return this.bitwiseTo(B, be, F), F;
  }
  function ze(B, F) {
    return B | F;
  }
  function nt(B) {
    var F = n();
    return this.bitwiseTo(B, ze, F), F;
  }
  function it(B, F) {
    return B ^ F;
  }
  function je(B) {
    var F = n();
    return this.bitwiseTo(B, it, F), F;
  }
  function Ze(B, F) {
    return B & ~F;
  }
  function qe(B) {
    var F = n();
    return this.bitwiseTo(B, Ze, F), F;
  }
  function He() {
    for (var B = n(), F = 0; F < this.t; ++F) B.data[F] = this.DM & ~this.data[F];
    return B.t = this.t, B.s = ~this.s, B;
  }
  function ke(B) {
    var F = n();
    return B < 0 ? this.rShiftTo(-B, F) : this.lShiftTo(B, F), F;
  }
  function Pt(B) {
    var F = n();
    return B < 0 ? this.lShiftTo(-B, F) : this.rShiftTo(B, F), F;
  }
  function nr(B) {
    if (B == 0) return -1;
    var F = 0;
    return B & 65535 || (B >>= 16, F += 16), B & 255 || (B >>= 8, F += 8), B & 15 || (B >>= 4, F += 4), B & 3 || (B >>= 2, F += 2), B & 1 || ++F, F;
  }
  function ur() {
    for (var B = 0; B < this.t; ++B)
      if (this.data[B] != 0) return B * this.DB + nr(this.data[B]);
    return this.s < 0 ? this.t * this.DB : -1;
  }
  function _r(B) {
    for (var F = 0; B != 0; )
      B &= B - 1, ++F;
    return F;
  }
  function lr() {
    for (var B = 0, F = this.s & this.DM, H = 0; H < this.t; ++H) B += _r(this.data[H] ^ F);
    return B;
  }
  function xn(B) {
    var F = Math.floor(B / this.DB);
    return F >= this.t ? this.s != 0 : (this.data[F] & 1 << B % this.DB) != 0;
  }
  function oi(B, F) {
    var H = r.ONE.shiftLeft(B);
    return this.bitwiseTo(H, F, H), H;
  }
  function ht(B) {
    return this.changeBit(B, ze);
  }
  function pt(B) {
    return this.changeBit(B, Ze);
  }
  function gt(B) {
    return this.changeBit(B, it);
  }
  function ct(B, F) {
    for (var H = 0, re = 0, ce = Math.min(B.t, this.t); H < ce; )
      re += this.data[H] + B.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
    if (B.t < this.t) {
      for (re += B.s; H < this.t; )
        re += this.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
      re += this.s;
    } else {
      for (re += this.s; H < B.t; )
        re += B.data[H], F.data[H++] = re & this.DM, re >>= this.DB;
      re += B.s;
    }
    F.s = re < 0 ? -1 : 0, re > 0 ? F.data[H++] = re : re < -1 && (F.data[H++] = this.DV + re), F.t = H, F.clamp();
  }
  function ut(B) {
    var F = n();
    return this.addTo(B, F), F;
  }
  function Xe(B) {
    var F = n();
    return this.subTo(B, F), F;
  }
  function yt(B) {
    var F = n();
    return this.multiplyTo(B, F), F;
  }
  function mt(B) {
    var F = n();
    return this.divRemTo(B, F, null), F;
  }
  function Et(B) {
    var F = n();
    return this.divRemTo(B, null, F), F;
  }
  function vt(B) {
    var F = n(), H = n();
    return this.divRemTo(B, F, H), new Array(F, H);
  }
  function At(B) {
    this.data[this.t] = this.am(0, B - 1, this, 0, 0, this.t), ++this.t, this.clamp();
  }
  function We(B, F) {
    if (B != 0) {
      for (; this.t <= F; ) this.data[this.t++] = 0;
      for (this.data[F] += B; this.data[F] >= this.DV; )
        this.data[F] -= this.DV, ++F >= this.t && (this.data[this.t++] = 0), ++this.data[F];
    }
  }
  function et() {
  }
  function lt(B) {
    return B;
  }
  function Ct(B, F, H) {
    B.multiplyTo(F, H);
  }
  function _t(B, F) {
    B.squareTo(F);
  }
  et.prototype.convert = lt, et.prototype.revert = lt, et.prototype.mulTo = Ct, et.prototype.sqrTo = _t;
  function dc(B) {
    return this.exp(B, new et());
  }
  function hn(B, F, H) {
    var re = Math.min(this.t + B.t, F);
    for (H.s = 0, H.t = re; re > 0; ) H.data[--re] = 0;
    var ce;
    for (ce = H.t - this.t; re < ce; ++re) H.data[re + this.t] = this.am(0, B.data[re], H, re, 0, this.t);
    for (ce = Math.min(B.t, F); re < ce; ++re) this.am(0, B.data[re], H, re, 0, F - re);
    H.clamp();
  }
  function hc(B, F, H) {
    --F;
    var re = H.t = this.t + B.t - F;
    for (H.s = 0; --re >= 0; ) H.data[re] = 0;
    for (re = Math.max(F - this.t, 0); re < B.t; ++re)
      H.data[this.t + re - F] = this.am(F - re, B.data[re], H, 0, 0, this.t + re - F);
    H.clamp(), H.drShiftTo(1, H);
  }
  function pn(B) {
    this.r2 = n(), this.q3 = n(), r.ONE.dlShiftTo(2 * B.t, this.r2), this.mu = this.r2.divide(B), this.m = B;
  }
  function pc(B) {
    if (B.s < 0 || B.t > 2 * this.m.t) return B.mod(this.m);
    if (B.compareTo(this.m) < 0) return B;
    var F = n();
    return B.copyTo(F), this.reduce(F), F;
  }
  function gc(B) {
    return B;
  }
  function yc(B) {
    for (B.drShiftTo(this.m.t - 1, this.r2), B.t > this.m.t + 1 && (B.t = this.m.t + 1, B.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); B.compareTo(this.r2) < 0; ) B.dAddOffset(1, this.m.t + 1);
    for (B.subTo(this.r2, B); B.compareTo(this.m) >= 0; ) B.subTo(this.m, B);
  }
  function gn(B, F) {
    B.squareTo(F), this.reduce(F);
  }
  function mc(B, F, H) {
    B.multiplyTo(F, H), this.reduce(H);
  }
  pn.prototype.convert = pc, pn.prototype.revert = gc, pn.prototype.reduce = yc, pn.prototype.mulTo = mc, pn.prototype.sqrTo = gn;
  function Ec(B, F) {
    var H = B.bitLength(), re, ce = I(1), le;
    if (H <= 0) return ce;
    H < 18 ? re = 1 : H < 48 ? re = 3 : H < 144 ? re = 4 : H < 768 ? re = 5 : re = 6, H < 8 ? le = new ne(F) : F.isEven() ? le = new pn(F) : le = new Ce(F);
    var Ae = new Array(), ve = 3, Ke = re - 1, St = (1 << re) - 1;
    if (Ae[1] = le.convert(this), re > 1) {
      var Jt = n();
      for (le.sqrTo(Ae[1], Jt); ve <= St; )
        Ae[ve] = n(), le.mulTo(Jt, Ae[ve - 2], Ae[ve]), ve += 2;
    }
    var Kt = B.t - 1, Sr, ui = !0, zt = n(), ar;
    for (H = h(B.data[Kt]) - 1; Kt >= 0; ) {
      for (H >= Ke ? Sr = B.data[Kt] >> H - Ke & St : (Sr = (B.data[Kt] & (1 << H + 1) - 1) << Ke - H, Kt > 0 && (Sr |= B.data[Kt - 1] >> this.DB + H - Ke)), ve = re; !(Sr & 1); )
        Sr >>= 1, --ve;
      if ((H -= ve) < 0 && (H += this.DB, --Kt), ui)
        Ae[Sr].copyTo(ce), ui = !1;
      else {
        for (; ve > 1; )
          le.sqrTo(ce, zt), le.sqrTo(zt, ce), ve -= 2;
        ve > 0 ? le.sqrTo(ce, zt) : (ar = ce, ce = zt, zt = ar), le.mulTo(zt, Ae[Sr], ce);
      }
      for (; Kt >= 0 && !(B.data[Kt] & 1 << H); )
        le.sqrTo(ce, zt), ar = ce, ce = zt, zt = ar, --H < 0 && (H = this.DB - 1, --Kt);
    }
    return le.revert(ce);
  }
  function vc(B) {
    var F = this.s < 0 ? this.negate() : this.clone(), H = B.s < 0 ? B.negate() : B.clone();
    if (F.compareTo(H) < 0) {
      var re = F;
      F = H, H = re;
    }
    var ce = F.getLowestSetBit(), le = H.getLowestSetBit();
    if (le < 0) return F;
    for (ce < le && (le = ce), le > 0 && (F.rShiftTo(le, F), H.rShiftTo(le, H)); F.signum() > 0; )
      (ce = F.getLowestSetBit()) > 0 && F.rShiftTo(ce, F), (ce = H.getLowestSetBit()) > 0 && H.rShiftTo(ce, H), F.compareTo(H) >= 0 ? (F.subTo(H, F), F.rShiftTo(1, F)) : (H.subTo(F, H), H.rShiftTo(1, H));
    return le > 0 && H.lShiftTo(le, H), H;
  }
  function Ac(B) {
    if (B <= 0) return 0;
    var F = this.DV % B, H = this.s < 0 ? B - 1 : 0;
    if (this.t > 0)
      if (F == 0) H = this.data[0] % B;
      else for (var re = this.t - 1; re >= 0; --re) H = (F * H + this.data[re]) % B;
    return H;
  }
  function Cc(B) {
    var F = B.isEven();
    if (this.isEven() && F || B.signum() == 0) return r.ZERO;
    for (var H = B.clone(), re = this.clone(), ce = I(1), le = I(0), Ae = I(0), ve = I(1); H.signum() != 0; ) {
      for (; H.isEven(); )
        H.rShiftTo(1, H), F ? ((!ce.isEven() || !le.isEven()) && (ce.addTo(this, ce), le.subTo(B, le)), ce.rShiftTo(1, ce)) : le.isEven() || le.subTo(B, le), le.rShiftTo(1, le);
      for (; re.isEven(); )
        re.rShiftTo(1, re), F ? ((!Ae.isEven() || !ve.isEven()) && (Ae.addTo(this, Ae), ve.subTo(B, ve)), Ae.rShiftTo(1, Ae)) : ve.isEven() || ve.subTo(B, ve), ve.rShiftTo(1, ve);
      H.compareTo(re) >= 0 ? (H.subTo(re, H), F && ce.subTo(Ae, ce), le.subTo(ve, le)) : (re.subTo(H, re), F && Ae.subTo(ce, Ae), ve.subTo(le, ve));
    }
    if (re.compareTo(r.ONE) != 0) return r.ZERO;
    if (ve.compareTo(B) >= 0) return ve.subtract(B);
    if (ve.signum() < 0) ve.addTo(B, ve);
    else return ve;
    return ve.signum() < 0 ? ve.add(B) : ve;
  }
  var ir = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], ja = (1 << 26) / ir[ir.length - 1];
  function ci(B) {
    var F, H = this.abs();
    if (H.t == 1 && H.data[0] <= ir[ir.length - 1]) {
      for (F = 0; F < ir.length; ++F)
        if (H.data[0] == ir[F]) return !0;
      return !1;
    }
    if (H.isEven()) return !1;
    for (F = 1; F < ir.length; ) {
      for (var re = ir[F], ce = F + 1; ce < ir.length && re < ja; ) re *= ir[ce++];
      for (re = H.modInt(re); F < ce; ) if (re % ir[F++] == 0) return !1;
    }
    return H.millerRabin(B);
  }
  function _c(B) {
    var F = this.subtract(r.ONE), H = F.getLowestSetBit();
    if (H <= 0) return !1;
    for (var re = F.shiftRight(H), ce = Wi(), le, Ae = 0; Ae < B; ++Ae) {
      do
        le = new r(this.bitLength(), ce);
      while (le.compareTo(r.ONE) <= 0 || le.compareTo(F) >= 0);
      var ve = le.modPow(re, this);
      if (ve.compareTo(r.ONE) != 0 && ve.compareTo(F) != 0) {
        for (var Ke = 1; Ke++ < H && ve.compareTo(F) != 0; )
          if (ve = ve.modPowInt(2, this), ve.compareTo(r.ONE) == 0) return !1;
        if (ve.compareTo(F) != 0) return !1;
      }
    }
    return !0;
  }
  function Wi() {
    return {
      // x is an array to fill with bytes
      nextBytes: function(B) {
        for (var F = 0; F < B.length; ++F)
          B[F] = Math.floor(Math.random() * 256);
      }
    };
  }
  return r.prototype.chunkSize = z, r.prototype.toRadix = Y, r.prototype.fromRadix = M, r.prototype.fromNumber = X, r.prototype.bitwiseTo = Ee, r.prototype.changeBit = oi, r.prototype.addTo = ct, r.prototype.dMultiply = At, r.prototype.dAddOffset = We, r.prototype.multiplyLowerTo = hn, r.prototype.multiplyUpperTo = hc, r.prototype.modInt = Ac, r.prototype.millerRabin = _c, r.prototype.clone = U, r.prototype.intValue = k, r.prototype.byteValue = W, r.prototype.shortValue = q, r.prototype.signum = j, r.prototype.toByteArray = J, r.prototype.equals = Z, r.prototype.min = oe, r.prototype.max = he, r.prototype.and = Re, r.prototype.or = nt, r.prototype.xor = je, r.prototype.andNot = qe, r.prototype.not = He, r.prototype.shiftLeft = ke, r.prototype.shiftRight = Pt, r.prototype.getLowestSetBit = ur, r.prototype.bitCount = lr, r.prototype.testBit = xn, r.prototype.setBit = ht, r.prototype.clearBit = pt, r.prototype.flipBit = gt, r.prototype.add = ut, r.prototype.subtract = Xe, r.prototype.multiply = yt, r.prototype.divide = mt, r.prototype.remainder = Et, r.prototype.divideAndRemainder = vt, r.prototype.modPow = Ec, r.prototype.modInverse = Cc, r.prototype.pow = dc, r.prototype.gcd = vc, r.prototype.isProbablePrime = ci, lu;
}
var fu = { exports: {} }, du = { exports: {} }, ep;
function Da() {
  if (ep) return du.exports;
  ep = 1;
  var t = Pe();
  dn(), $e();
  var e = du.exports = t.sha1 = t.sha1 || {};
  t.md.sha1 = t.md.algorithms.sha1 = e, e.create = function() {
    n || i();
    var s = null, o = t.util.createBuffer(), l = new Array(80), u = {
      algorithm: "sha1",
      blockLength: 64,
      digestLength: 20,
      // 56-bit length of message so far (does not including padding)
      messageLength: 0,
      // true message length
      fullMessageLength: null,
      // size of message length in bytes
      messageLengthSize: 8
    };
    return u.start = function() {
      u.messageLength = 0, u.fullMessageLength = u.messageLength64 = [];
      for (var f = u.messageLengthSize / 4, y = 0; y < f; ++y)
        u.fullMessageLength.push(0);
      return o = t.util.createBuffer(), s = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878,
        h4: 3285377520
      }, u;
    }, u.start(), u.update = function(f, y) {
      y === "utf8" && (f = t.util.encodeUtf8(f));
      var m = f.length;
      u.messageLength += m, m = [m / 4294967296 >>> 0, m >>> 0];
      for (var p = u.fullMessageLength.length - 1; p >= 0; --p)
        u.fullMessageLength[p] += m[1], m[1] = m[0] + (u.fullMessageLength[p] / 4294967296 >>> 0), u.fullMessageLength[p] = u.fullMessageLength[p] >>> 0, m[0] = m[1] / 4294967296 >>> 0;
      return o.putBytes(f), a(s, l, o), (o.read > 2048 || o.length() === 0) && o.compact(), u;
    }, u.digest = function() {
      var f = t.util.createBuffer();
      f.putBytes(o.bytes());
      var y = u.fullMessageLength[u.fullMessageLength.length - 1] + u.messageLengthSize, m = y & u.blockLength - 1;
      f.putBytes(r.substr(0, u.blockLength - m));
      for (var p, S, A = u.fullMessageLength[0] * 8, I = 0; I < u.fullMessageLength.length - 1; ++I)
        p = u.fullMessageLength[I + 1] * 8, S = p / 4294967296 >>> 0, A += S, f.putInt32(A >>> 0), A = p >>> 0;
      f.putInt32(A);
      var c = {
        h0: s.h0,
        h1: s.h1,
        h2: s.h2,
        h3: s.h3,
        h4: s.h4
      };
      a(c, l, f);
      var E = t.util.createBuffer();
      return E.putInt32(c.h0), E.putInt32(c.h1), E.putInt32(c.h2), E.putInt32(c.h3), E.putInt32(c.h4), E;
    }, u;
  };
  var r = null, n = !1;
  function i() {
    r = "", r += t.util.fillString("\0", 64), n = !0;
  }
  function a(s, o, l) {
    for (var u, f, y, m, p, S, A, I, c = l.length(); c >= 64; ) {
      for (f = s.h0, y = s.h1, m = s.h2, p = s.h3, S = s.h4, I = 0; I < 16; ++I)
        u = l.getInt32(), o[I] = u, A = p ^ y & (m ^ p), u = (f << 5 | f >>> 27) + A + S + 1518500249 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      for (; I < 20; ++I)
        u = o[I - 3] ^ o[I - 8] ^ o[I - 14] ^ o[I - 16], u = u << 1 | u >>> 31, o[I] = u, A = p ^ y & (m ^ p), u = (f << 5 | f >>> 27) + A + S + 1518500249 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      for (; I < 32; ++I)
        u = o[I - 3] ^ o[I - 8] ^ o[I - 14] ^ o[I - 16], u = u << 1 | u >>> 31, o[I] = u, A = y ^ m ^ p, u = (f << 5 | f >>> 27) + A + S + 1859775393 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      for (; I < 40; ++I)
        u = o[I - 6] ^ o[I - 16] ^ o[I - 28] ^ o[I - 32], u = u << 2 | u >>> 30, o[I] = u, A = y ^ m ^ p, u = (f << 5 | f >>> 27) + A + S + 1859775393 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      for (; I < 60; ++I)
        u = o[I - 6] ^ o[I - 16] ^ o[I - 28] ^ o[I - 32], u = u << 2 | u >>> 30, o[I] = u, A = y & m | p & (y ^ m), u = (f << 5 | f >>> 27) + A + S + 2400959708 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      for (; I < 80; ++I)
        u = o[I - 6] ^ o[I - 16] ^ o[I - 28] ^ o[I - 32], u = u << 2 | u >>> 30, o[I] = u, A = y ^ m ^ p, u = (f << 5 | f >>> 27) + A + S + 3395469782 + u, S = p, p = m, m = (y << 30 | y >>> 2) >>> 0, y = f, f = u;
      s.h0 = s.h0 + f | 0, s.h1 = s.h1 + y | 0, s.h2 = s.h2 + m | 0, s.h3 = s.h3 + p | 0, s.h4 = s.h4 + S | 0, c -= 64;
    }
  }
  return du.exports;
}
var tp;
function Cy() {
  if (tp) return fu.exports;
  tp = 1;
  var t = Pe();
  $e(), Pr(), Da();
  var e = fu.exports = t.pkcs1 = t.pkcs1 || {};
  e.encode_rsa_oaep = function(n, i, a) {
    var s, o, l, u;
    typeof a == "string" ? (s = a, o = arguments[3] || void 0, l = arguments[4] || void 0) : a && (s = a.label || void 0, o = a.seed || void 0, l = a.md || void 0, a.mgf1 && a.mgf1.md && (u = a.mgf1.md)), l ? l.start() : l = t.md.sha1.create(), u || (u = l);
    var f = Math.ceil(n.n.bitLength() / 8), y = f - 2 * l.digestLength - 2;
    if (i.length > y) {
      var m = new Error("RSAES-OAEP input message length is too long.");
      throw m.length = i.length, m.maxLength = y, m;
    }
    s || (s = ""), l.update(s, "raw");
    for (var p = l.digest(), S = "", A = y - i.length, I = 0; I < A; I++)
      S += "\0";
    var c = p.getBytes() + S + "" + i;
    if (!o)
      o = t.random.getBytes(l.digestLength);
    else if (o.length !== l.digestLength) {
      var m = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      throw m.seedLength = o.length, m.digestLength = l.digestLength, m;
    }
    var E = r(o, f - l.digestLength - 1, u), v = t.util.xorBytes(c, E, c.length), R = r(v, l.digestLength, u), N = t.util.xorBytes(o, R, o.length);
    return "\0" + N + v;
  }, e.decode_rsa_oaep = function(n, i, a) {
    var s, o, l;
    typeof a == "string" ? (s = a, o = arguments[3] || void 0) : a && (s = a.label || void 0, o = a.md || void 0, a.mgf1 && a.mgf1.md && (l = a.mgf1.md));
    var u = Math.ceil(n.n.bitLength() / 8);
    if (i.length !== u) {
      var v = new Error("RSAES-OAEP encoded message length is invalid.");
      throw v.length = i.length, v.expectedLength = u, v;
    }
    if (o === void 0 ? o = t.md.sha1.create() : o.start(), l || (l = o), u < 2 * o.digestLength + 2)
      throw new Error("RSAES-OAEP key is too short for the hash function.");
    s || (s = ""), o.update(s, "raw");
    for (var f = o.digest().getBytes(), y = i.charAt(0), m = i.substring(1, o.digestLength + 1), p = i.substring(1 + o.digestLength), S = r(p, o.digestLength, l), A = t.util.xorBytes(m, S, m.length), I = r(A, u - o.digestLength - 1, l), c = t.util.xorBytes(p, I, p.length), E = c.substring(0, o.digestLength), v = y !== "\0", R = 0; R < o.digestLength; ++R)
      v |= f.charAt(R) !== E.charAt(R);
    for (var N = 1, C = o.digestLength, h = o.digestLength; h < c.length; h++) {
      var d = c.charCodeAt(h), O = d & 1 ^ 1, P = N ? 65534 : 0;
      v |= d & P, N = N & O, C += N;
    }
    if (v || c.charCodeAt(C) !== 1)
      throw new Error("Invalid RSAES-OAEP padding.");
    return c.substring(C + 1);
  };
  function r(n, i, a) {
    a || (a = t.md.sha1.create());
    for (var s = "", o = Math.ceil(i / a.digestLength), l = 0; l < o; ++l) {
      var u = String.fromCharCode(
        l >> 24 & 255,
        l >> 16 & 255,
        l >> 8 & 255,
        l & 255
      );
      a.start(), a.update(n + u), s += a.digest().getBytes();
    }
    return s.substring(0, i);
  }
  return fu.exports;
}
var es = { exports: {} }, rp;
function _y() {
  if (rp) return es.exports;
  rp = 1;
  var t = Pe();
  return $e(), ko(), Pr(), function() {
    if (t.prime) {
      es.exports = t.prime;
      return;
    }
    var e = es.exports = t.prime = t.prime || {}, r = t.jsbn.BigInteger, n = [6, 4, 2, 4, 2, 4, 6, 2], i = new r(null);
    i.fromInt(30);
    var a = function(m, p) {
      return m | p;
    };
    e.generateProbablePrime = function(m, p, S) {
      typeof p == "function" && (S = p, p = {}), p = p || {};
      var A = p.algorithm || "PRIMEINC";
      typeof A == "string" && (A = { name: A }), A.options = A.options || {};
      var I = p.prng || t.random, c = {
        // x is an array to fill with bytes
        nextBytes: function(E) {
          for (var v = I.getBytesSync(E.length), R = 0; R < E.length; ++R)
            E[R] = v.charCodeAt(R);
        }
      };
      if (A.name === "PRIMEINC")
        return s(m, c, A.options, S);
      throw new Error("Invalid prime generation algorithm: " + A.name);
    };
    function s(m, p, S, A) {
      return "workers" in S ? u(m, p, S, A) : o(m, p, S, A);
    }
    function o(m, p, S, A) {
      var I = f(m, p), c = 0, E = y(I.bitLength());
      "millerRabinTests" in S && (E = S.millerRabinTests);
      var v = 10;
      "maxBlockTime" in S && (v = S.maxBlockTime), l(I, m, p, c, E, v, A);
    }
    function l(m, p, S, A, I, c, E) {
      var v = +/* @__PURE__ */ new Date();
      do {
        if (m.bitLength() > p && (m = f(p, S)), m.isProbablePrime(I))
          return E(null, m);
        m.dAddOffset(n[A++ % 8], 0);
      } while (c < 0 || +/* @__PURE__ */ new Date() - v < c);
      t.util.setImmediate(function() {
        l(m, p, S, A, I, c, E);
      });
    }
    function u(m, p, S, A) {
      if (typeof Worker > "u")
        return o(m, p, S, A);
      var I = f(m, p), c = S.workers, E = S.workLoad || 100, v = E * 30 / 8, R = S.workerScript || "forge/prime.worker.js";
      if (c === -1)
        return t.util.estimateCores(function(C, h) {
          C && (h = 2), c = h - 1, N();
        });
      N();
      function N() {
        c = Math.max(1, c);
        for (var C = [], h = 0; h < c; ++h)
          C[h] = new Worker(R);
        for (var h = 0; h < c; ++h)
          C[h].addEventListener("message", O);
        var d = !1;
        function O(P) {
          if (!d) {
            var L = P.data;
            if (L.found) {
              for (var D = 0; D < C.length; ++D)
                C[D].terminate();
              return d = !0, A(null, new r(L.prime, 16));
            }
            I.bitLength() > m && (I = f(m, p));
            var V = I.toString(16);
            P.target.postMessage({
              hex: V,
              workLoad: E
            }), I.dAddOffset(v, 0);
          }
        }
      }
    }
    function f(m, p) {
      var S = new r(m, p), A = m - 1;
      return S.testBit(A) || S.bitwiseTo(r.ONE.shiftLeft(A), a, S), S.dAddOffset(31 - S.mod(i).byteValue(), 0), S;
    }
    function y(m) {
      return m <= 100 ? 27 : m <= 150 ? 18 : m <= 200 ? 15 : m <= 250 ? 12 : m <= 300 ? 9 : m <= 350 ? 8 : m <= 400 ? 7 : m <= 500 ? 6 : m <= 600 ? 5 : m <= 800 ? 4 : m <= 1250 ? 3 : 2;
    }
  }(), es.exports;
}
var hu, np;
function Bo() {
  if (np) return hu;
  np = 1;
  var t = Pe();
  if (Wr(), ko(), ii(), Cy(), _y(), Pr(), $e(), typeof e > "u")
    var e = t.jsbn.BigInteger;
  var r = t.util.isNodejs ? ge : null, n = t.asn1, i = t.util;
  t.pki = t.pki || {}, hu = t.pki.rsa = t.rsa = t.rsa || {};
  var a = t.pki, s = [6, 4, 2, 4, 2, 4, 6, 2], o = {
    // PrivateKeyInfo
    name: "PrivateKeyInfo",
    tagClass: n.Class.UNIVERSAL,
    type: n.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // Version (INTEGER)
      name: "PrivateKeyInfo.version",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyVersion"
    }, {
      // privateKeyAlgorithm
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OID,
        constructed: !1,
        capture: "privateKeyOid"
      }]
    }, {
      // PrivateKey
      name: "PrivateKeyInfo",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.OCTETSTRING,
      constructed: !1,
      capture: "privateKey"
    }]
  }, l = {
    // RSAPrivateKey
    name: "RSAPrivateKey",
    tagClass: n.Class.UNIVERSAL,
    type: n.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // Version (INTEGER)
      name: "RSAPrivateKey.version",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyVersion"
    }, {
      // modulus (n)
      name: "RSAPrivateKey.modulus",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyModulus"
    }, {
      // publicExponent (e)
      name: "RSAPrivateKey.publicExponent",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyPublicExponent"
    }, {
      // privateExponent (d)
      name: "RSAPrivateKey.privateExponent",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyPrivateExponent"
    }, {
      // prime1 (p)
      name: "RSAPrivateKey.prime1",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyPrime1"
    }, {
      // prime2 (q)
      name: "RSAPrivateKey.prime2",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyPrime2"
    }, {
      // exponent1 (d mod (p-1))
      name: "RSAPrivateKey.exponent1",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyExponent1"
    }, {
      // exponent2 (d mod (q-1))
      name: "RSAPrivateKey.exponent2",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyExponent2"
    }, {
      // coefficient ((inverse of q) mod p)
      name: "RSAPrivateKey.coefficient",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyCoefficient"
    }]
  }, u = {
    // RSAPublicKey
    name: "RSAPublicKey",
    tagClass: n.Class.UNIVERSAL,
    type: n.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // modulus (n)
      name: "RSAPublicKey.modulus",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "publicKeyModulus"
    }, {
      // publicExponent (e)
      name: "RSAPublicKey.exponent",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.INTEGER,
      constructed: !1,
      capture: "publicKeyExponent"
    }]
  }, f = t.pki.rsa.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: n.Class.UNIVERSAL,
    type: n.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "subjectPublicKeyInfo",
    value: [{
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OID,
        constructed: !1,
        capture: "publicKeyOid"
      }]
    }, {
      // subjectPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.BITSTRING,
      constructed: !1,
      value: [{
        // RSAPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        captureAsn1: "rsaPublicKey"
      }]
    }]
  }, y = {
    name: "DigestInfo",
    tagClass: n.Class.UNIVERSAL,
    type: n.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "DigestInfo.DigestAlgorithm",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OID,
        constructed: !1,
        capture: "algorithmIdentifier"
      }, {
        // NULL paramters
        name: "DigestInfo.DigestAlgorithm.parameters",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.NULL,
        // captured only to check existence for md2 and md5
        capture: "parameters",
        optional: !0,
        constructed: !1
      }]
    }, {
      // digest
      name: "DigestInfo.digest",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.OCTETSTRING,
      constructed: !1,
      capture: "digest"
    }]
  }, m = function(h) {
    var d;
    if (h.algorithm in a.oids)
      d = a.oids[h.algorithm];
    else {
      var O = new Error("Unknown message digest algorithm.");
      throw O.algorithm = h.algorithm, O;
    }
    var P = n.oidToDer(d).getBytes(), L = n.create(
      n.Class.UNIVERSAL,
      n.Type.SEQUENCE,
      !0,
      []
    ), D = n.create(
      n.Class.UNIVERSAL,
      n.Type.SEQUENCE,
      !0,
      []
    );
    D.value.push(n.create(
      n.Class.UNIVERSAL,
      n.Type.OID,
      !1,
      P
    )), D.value.push(n.create(
      n.Class.UNIVERSAL,
      n.Type.NULL,
      !1,
      ""
    ));
    var V = n.create(
      n.Class.UNIVERSAL,
      n.Type.OCTETSTRING,
      !1,
      h.digest().getBytes()
    );
    return L.value.push(D), L.value.push(V), n.toDer(L).getBytes();
  }, p = function(h, d, O) {
    if (O)
      return h.modPow(d.e, d.n);
    if (!d.p || !d.q)
      return h.modPow(d.d, d.n);
    d.dP || (d.dP = d.d.mod(d.p.subtract(e.ONE))), d.dQ || (d.dQ = d.d.mod(d.q.subtract(e.ONE))), d.qInv || (d.qInv = d.q.modInverse(d.p));
    var P;
    do
      P = new e(
        t.util.bytesToHex(t.random.getBytes(d.n.bitLength() / 8)),
        16
      );
    while (P.compareTo(d.n) >= 0 || !P.gcd(d.n).equals(e.ONE));
    h = h.multiply(P.modPow(d.e, d.n)).mod(d.n);
    for (var L = h.mod(d.p).modPow(d.dP, d.p), D = h.mod(d.q).modPow(d.dQ, d.q); L.compareTo(D) < 0; )
      L = L.add(d.p);
    var V = L.subtract(D).multiply(d.qInv).mod(d.p).multiply(d.q).add(D);
    return V = V.multiply(P.modInverse(d.n)).mod(d.n), V;
  };
  a.rsa.encrypt = function(h, d, O) {
    var P = O, L, D = Math.ceil(d.n.bitLength() / 8);
    O !== !1 && O !== !0 ? (P = O === 2, L = S(h, d, O)) : (L = t.util.createBuffer(), L.putBytes(h));
    for (var V = new e(L.toHex(), 16), $ = p(V, d, P), K = $.toString(16), Q = t.util.createBuffer(), ee = D - Math.ceil(K.length / 2); ee > 0; )
      Q.putByte(0), --ee;
    return Q.putBytes(t.util.hexToBytes(K)), Q.getBytes();
  }, a.rsa.decrypt = function(h, d, O, P) {
    var L = Math.ceil(d.n.bitLength() / 8);
    if (h.length !== L) {
      var D = new Error("Encrypted message length is invalid.");
      throw D.length = h.length, D.expected = L, D;
    }
    var V = new e(t.util.createBuffer(h).toHex(), 16);
    if (V.compareTo(d.n) >= 0)
      throw new Error("Encrypted message is invalid.");
    for (var $ = p(V, d, O), K = $.toString(16), Q = t.util.createBuffer(), ee = L - Math.ceil(K.length / 2); ee > 0; )
      Q.putByte(0), --ee;
    return Q.putBytes(t.util.hexToBytes(K)), P !== !1 ? A(Q.getBytes(), d, O) : Q.getBytes();
  }, a.rsa.createKeyPairGenerationState = function(h, d, O) {
    typeof h == "string" && (h = parseInt(h, 10)), h = h || 2048, O = O || {};
    var P = O.prng || t.random, L = {
      // x is an array to fill with bytes
      nextBytes: function($) {
        for (var K = P.getBytesSync($.length), Q = 0; Q < $.length; ++Q)
          $[Q] = K.charCodeAt(Q);
      }
    }, D = O.algorithm || "PRIMEINC", V;
    if (D === "PRIMEINC")
      V = {
        algorithm: D,
        state: 0,
        bits: h,
        rng: L,
        eInt: d || 65537,
        e: new e(null),
        p: null,
        q: null,
        qBits: h >> 1,
        pBits: h - (h >> 1),
        pqState: 0,
        num: null,
        keys: null
      }, V.e.fromInt(V.eInt);
    else
      throw new Error("Invalid key generation algorithm: " + D);
    return V;
  }, a.rsa.stepKeyPairGenerationState = function(h, d) {
    "algorithm" in h || (h.algorithm = "PRIMEINC");
    var O = new e(null);
    O.fromInt(30);
    for (var P = 0, L = function(ne, ae) {
      return ne | ae;
    }, D = +/* @__PURE__ */ new Date(), V, $ = 0; h.keys === null && (d <= 0 || $ < d); ) {
      if (h.state === 0) {
        var K = h.p === null ? h.pBits : h.qBits, Q = K - 1;
        h.pqState === 0 ? (h.num = new e(K, h.rng), h.num.testBit(Q) || h.num.bitwiseTo(
          e.ONE.shiftLeft(Q),
          L,
          h.num
        ), h.num.dAddOffset(31 - h.num.mod(O).byteValue(), 0), P = 0, ++h.pqState) : h.pqState === 1 ? h.num.bitLength() > K ? h.pqState = 0 : h.num.isProbablePrime(
          E(h.num.bitLength())
        ) ? ++h.pqState : h.num.dAddOffset(s[P++ % 8], 0) : h.pqState === 2 ? h.pqState = h.num.subtract(e.ONE).gcd(h.e).compareTo(e.ONE) === 0 ? 3 : 0 : h.pqState === 3 && (h.pqState = 0, h.p === null ? h.p = h.num : h.q = h.num, h.p !== null && h.q !== null && ++h.state, h.num = null);
      } else if (h.state === 1)
        h.p.compareTo(h.q) < 0 && (h.num = h.p, h.p = h.q, h.q = h.num), ++h.state;
      else if (h.state === 2)
        h.p1 = h.p.subtract(e.ONE), h.q1 = h.q.subtract(e.ONE), h.phi = h.p1.multiply(h.q1), ++h.state;
      else if (h.state === 3)
        h.phi.gcd(h.e).compareTo(e.ONE) === 0 ? ++h.state : (h.p = null, h.q = null, h.state = 0);
      else if (h.state === 4)
        h.n = h.p.multiply(h.q), h.n.bitLength() === h.bits ? ++h.state : (h.q = null, h.state = 0);
      else if (h.state === 5) {
        var ee = h.e.modInverse(h.phi);
        h.keys = {
          privateKey: a.rsa.setPrivateKey(
            h.n,
            h.e,
            ee,
            h.p,
            h.q,
            ee.mod(h.p1),
            ee.mod(h.q1),
            h.q.modInverse(h.p)
          ),
          publicKey: a.rsa.setPublicKey(h.n, h.e)
        };
      }
      V = +/* @__PURE__ */ new Date(), $ += V - D, D = V;
    }
    return h.keys !== null;
  }, a.rsa.generateKeyPair = function(h, d, O, P) {
    if (arguments.length === 1 ? typeof h == "object" ? (O = h, h = void 0) : typeof h == "function" && (P = h, h = void 0) : arguments.length === 2 ? typeof h == "number" ? typeof d == "function" ? (P = d, d = void 0) : typeof d != "number" && (O = d, d = void 0) : (O = h, P = d, h = void 0, d = void 0) : arguments.length === 3 && (typeof d == "number" ? typeof O == "function" && (P = O, O = void 0) : (P = O, O = d, d = void 0)), O = O || {}, h === void 0 && (h = O.bits || 2048), d === void 0 && (d = O.e || 65537), !t.options.usePureJavaScript && !O.prng && h >= 256 && h <= 16384 && (d === 65537 || d === 3)) {
      if (P) {
        if (v("generateKeyPair"))
          return r.generateKeyPair("rsa", {
            modulusLength: h,
            publicExponent: d,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          }, function($, K, Q) {
            if ($)
              return P($);
            P(null, {
              privateKey: a.privateKeyFromPem(Q),
              publicKey: a.publicKeyFromPem(K)
            });
          });
        if (R("generateKey") && R("exportKey"))
          return i.globalScope.crypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: h,
            publicExponent: C(d),
            hash: { name: "SHA-256" }
          }, !0, ["sign", "verify"]).then(function($) {
            return i.globalScope.crypto.subtle.exportKey(
              "pkcs8",
              $.privateKey
            );
          }).then(void 0, function($) {
            P($);
          }).then(function($) {
            if ($) {
              var K = a.privateKeyFromAsn1(
                n.fromDer(t.util.createBuffer($))
              );
              P(null, {
                privateKey: K,
                publicKey: a.setRsaPublicKey(K.n, K.e)
              });
            }
          });
        if (N("generateKey") && N("exportKey")) {
          var L = i.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: h,
            publicExponent: C(d),
            hash: { name: "SHA-256" }
          }, !0, ["sign", "verify"]);
          L.oncomplete = function($) {
            var K = $.target.result, Q = i.globalScope.msCrypto.subtle.exportKey(
              "pkcs8",
              K.privateKey
            );
            Q.oncomplete = function(ee) {
              var ne = ee.target.result, ae = a.privateKeyFromAsn1(
                n.fromDer(t.util.createBuffer(ne))
              );
              P(null, {
                privateKey: ae,
                publicKey: a.setRsaPublicKey(ae.n, ae.e)
              });
            }, Q.onerror = function(ee) {
              P(ee);
            };
          }, L.onerror = function($) {
            P($);
          };
          return;
        }
      } else if (v("generateKeyPairSync")) {
        var D = r.generateKeyPairSync("rsa", {
          modulusLength: h,
          publicExponent: d,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: a.privateKeyFromPem(D.privateKey),
          publicKey: a.publicKeyFromPem(D.publicKey)
        };
      }
    }
    var V = a.rsa.createKeyPairGenerationState(h, d, O);
    if (!P)
      return a.rsa.stepKeyPairGenerationState(V, 0), V.keys;
    I(V, O, P);
  }, a.setRsaPublicKey = a.rsa.setPublicKey = function(h, d) {
    var O = {
      n: h,
      e: d
    };
    return O.encrypt = function(P, L, D) {
      if (typeof L == "string" ? L = L.toUpperCase() : L === void 0 && (L = "RSAES-PKCS1-V1_5"), L === "RSAES-PKCS1-V1_5")
        L = {
          encode: function($, K, Q) {
            return S($, K, 2).getBytes();
          }
        };
      else if (L === "RSA-OAEP" || L === "RSAES-OAEP")
        L = {
          encode: function($, K) {
            return t.pkcs1.encode_rsa_oaep(K, $, D);
          }
        };
      else if (["RAW", "NONE", "NULL", null].indexOf(L) !== -1)
        L = { encode: function($) {
          return $;
        } };
      else if (typeof L == "string")
        throw new Error('Unsupported encryption scheme: "' + L + '".');
      var V = L.encode(P, O, !0);
      return a.rsa.encrypt(V, O, !0);
    }, O.verify = function(P, L, D, V) {
      typeof D == "string" ? D = D.toUpperCase() : D === void 0 && (D = "RSASSA-PKCS1-V1_5"), V === void 0 && (V = {
        _parseAllDigestBytes: !0
      }), "_parseAllDigestBytes" in V || (V._parseAllDigestBytes = !0), D === "RSASSA-PKCS1-V1_5" ? D = {
        verify: function(K, Q) {
          Q = A(Q, O, !0);
          var ee = n.fromDer(Q, {
            parseAllBytes: V._parseAllDigestBytes
          }), ne = {}, ae = [];
          if (!n.validate(ee, y, ne, ae)) {
            var se = new Error(
              "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
            );
            throw se.errors = ae, se;
          }
          var me = n.derToOid(ne.algorithmIdentifier);
          if (!(me === t.oids.md2 || me === t.oids.md5 || me === t.oids.sha1 || me === t.oids.sha224 || me === t.oids.sha256 || me === t.oids.sha384 || me === t.oids.sha512 || me === t.oids["sha512-224"] || me === t.oids["sha512-256"])) {
            var se = new Error(
              "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
            );
            throw se.oid = me, se;
          }
          if ((me === t.oids.md2 || me === t.oids.md5) && !("parameters" in ne))
            throw new Error(
              "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
            );
          return K === ne.digest;
        }
      } : (D === "NONE" || D === "NULL" || D === null) && (D = {
        verify: function(K, Q) {
          return Q = A(Q, O, !0), K === Q;
        }
      });
      var $ = a.rsa.decrypt(L, O, !0, !1);
      return D.verify(P, $, O.n.bitLength());
    }, O;
  }, a.setRsaPrivateKey = a.rsa.setPrivateKey = function(h, d, O, P, L, D, V, $) {
    var K = {
      n: h,
      e: d,
      d: O,
      p: P,
      q: L,
      dP: D,
      dQ: V,
      qInv: $
    };
    return K.decrypt = function(Q, ee, ne) {
      typeof ee == "string" ? ee = ee.toUpperCase() : ee === void 0 && (ee = "RSAES-PKCS1-V1_5");
      var ae = a.rsa.decrypt(Q, K, !1, !1);
      if (ee === "RSAES-PKCS1-V1_5")
        ee = { decode: A };
      else if (ee === "RSA-OAEP" || ee === "RSAES-OAEP")
        ee = {
          decode: function(se, me) {
            return t.pkcs1.decode_rsa_oaep(me, se, ne);
          }
        };
      else if (["RAW", "NONE", "NULL", null].indexOf(ee) !== -1)
        ee = { decode: function(se) {
          return se;
        } };
      else
        throw new Error('Unsupported encryption scheme: "' + ee + '".');
      return ee.decode(ae, K, !1);
    }, K.sign = function(Q, ee) {
      var ne = !1;
      typeof ee == "string" && (ee = ee.toUpperCase()), ee === void 0 || ee === "RSASSA-PKCS1-V1_5" ? (ee = { encode: m }, ne = 1) : (ee === "NONE" || ee === "NULL" || ee === null) && (ee = { encode: function() {
        return Q;
      } }, ne = 1);
      var ae = ee.encode(Q, K.n.bitLength());
      return a.rsa.encrypt(ae, K, ne);
    }, K;
  }, a.wrapRsaPrivateKey = function(h) {
    return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
      // version (0)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        n.integerToDer(0).getBytes()
      ),
      // privateKeyAlgorithm
      n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
        n.create(
          n.Class.UNIVERSAL,
          n.Type.OID,
          !1,
          n.oidToDer(a.oids.rsaEncryption).getBytes()
        ),
        n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")
      ]),
      // PrivateKey
      n.create(
        n.Class.UNIVERSAL,
        n.Type.OCTETSTRING,
        !1,
        n.toDer(h).getBytes()
      )
    ]);
  }, a.privateKeyFromAsn1 = function(h) {
    var d = {}, O = [];
    if (n.validate(h, o, d, O) && (h = n.fromDer(t.util.createBuffer(d.privateKey))), d = {}, O = [], !n.validate(h, l, d, O)) {
      var P = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      throw P.errors = O, P;
    }
    var L, D, V, $, K, Q, ee, ne;
    return L = t.util.createBuffer(d.privateKeyModulus).toHex(), D = t.util.createBuffer(d.privateKeyPublicExponent).toHex(), V = t.util.createBuffer(d.privateKeyPrivateExponent).toHex(), $ = t.util.createBuffer(d.privateKeyPrime1).toHex(), K = t.util.createBuffer(d.privateKeyPrime2).toHex(), Q = t.util.createBuffer(d.privateKeyExponent1).toHex(), ee = t.util.createBuffer(d.privateKeyExponent2).toHex(), ne = t.util.createBuffer(d.privateKeyCoefficient).toHex(), a.setRsaPrivateKey(
      new e(L, 16),
      new e(D, 16),
      new e(V, 16),
      new e($, 16),
      new e(K, 16),
      new e(Q, 16),
      new e(ee, 16),
      new e(ne, 16)
    );
  }, a.privateKeyToAsn1 = a.privateKeyToRSAPrivateKey = function(h) {
    return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
      // version (0 = only 2 primes, 1 multiple primes)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        n.integerToDer(0).getBytes()
      ),
      // modulus (n)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.n)
      ),
      // publicExponent (e)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.e)
      ),
      // privateExponent (d)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.d)
      ),
      // privateKeyPrime1 (p)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.p)
      ),
      // privateKeyPrime2 (q)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.q)
      ),
      // privateKeyExponent1 (dP)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.dP)
      ),
      // privateKeyExponent2 (dQ)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.dQ)
      ),
      // coefficient (qInv)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.qInv)
      )
    ]);
  }, a.publicKeyFromAsn1 = function(h) {
    var d = {}, O = [];
    if (n.validate(h, f, d, O)) {
      var P = n.derToOid(d.publicKeyOid);
      if (P !== a.oids.rsaEncryption) {
        var L = new Error("Cannot read public key. Unknown OID.");
        throw L.oid = P, L;
      }
      h = d.rsaPublicKey;
    }
    if (O = [], !n.validate(h, u, d, O)) {
      var L = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      throw L.errors = O, L;
    }
    var D = t.util.createBuffer(d.publicKeyModulus).toHex(), V = t.util.createBuffer(d.publicKeyExponent).toHex();
    return a.setRsaPublicKey(
      new e(D, 16),
      new e(V, 16)
    );
  }, a.publicKeyToAsn1 = a.publicKeyToSubjectPublicKeyInfo = function(h) {
    return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
      // AlgorithmIdentifier
      n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
        // algorithm
        n.create(
          n.Class.UNIVERSAL,
          n.Type.OID,
          !1,
          n.oidToDer(a.oids.rsaEncryption).getBytes()
        ),
        // parameters (null)
        n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, "")
      ]),
      // subjectPublicKey
      n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, [
        a.publicKeyToRSAPublicKey(h)
      ])
    ]);
  }, a.publicKeyToRSAPublicKey = function(h) {
    return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
      // modulus (n)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.n)
      ),
      // publicExponent (e)
      n.create(
        n.Class.UNIVERSAL,
        n.Type.INTEGER,
        !1,
        c(h.e)
      )
    ]);
  };
  function S(h, d, O) {
    var P = t.util.createBuffer(), L = Math.ceil(d.n.bitLength() / 8);
    if (h.length > L - 11) {
      var D = new Error("Message is too long for PKCS#1 v1.5 padding.");
      throw D.length = h.length, D.max = L - 11, D;
    }
    P.putByte(0), P.putByte(O);
    var V = L - 3 - h.length, $;
    if (O === 0 || O === 1) {
      $ = O === 0 ? 0 : 255;
      for (var K = 0; K < V; ++K)
        P.putByte($);
    } else
      for (; V > 0; ) {
        for (var Q = 0, ee = t.random.getBytes(V), K = 0; K < V; ++K)
          $ = ee.charCodeAt(K), $ === 0 ? ++Q : P.putByte($);
        V = Q;
      }
    return P.putByte(0), P.putBytes(h), P;
  }
  function A(h, d, O, P) {
    var L = Math.ceil(d.n.bitLength() / 8), D = t.util.createBuffer(h), V = D.getByte(), $ = D.getByte();
    if (V !== 0 || O && $ !== 0 && $ !== 1 || !O && $ != 2 || O && $ === 0 && typeof P > "u")
      throw new Error("Encryption block is invalid.");
    var K = 0;
    if ($ === 0) {
      K = L - 3 - P;
      for (var Q = 0; Q < K; ++Q)
        if (D.getByte() !== 0)
          throw new Error("Encryption block is invalid.");
    } else if ($ === 1)
      for (K = 0; D.length() > 1; ) {
        if (D.getByte() !== 255) {
          --D.read;
          break;
        }
        ++K;
      }
    else if ($ === 2)
      for (K = 0; D.length() > 1; ) {
        if (D.getByte() === 0) {
          --D.read;
          break;
        }
        ++K;
      }
    var ee = D.getByte();
    if (ee !== 0 || K !== L - 3 - D.length())
      throw new Error("Encryption block is invalid.");
    return D.getBytes();
  }
  function I(h, d, O) {
    typeof d == "function" && (O = d, d = {}), d = d || {};
    var P = {
      algorithm: {
        name: d.algorithm || "PRIMEINC",
        options: {
          workers: d.workers || 2,
          workLoad: d.workLoad || 100,
          workerScript: d.workerScript
        }
      }
    };
    "prng" in d && (P.prng = d.prng), L();
    function L() {
      D(h.pBits, function($, K) {
        if ($)
          return O($);
        if (h.p = K, h.q !== null)
          return V($, h.q);
        D(h.qBits, V);
      });
    }
    function D($, K) {
      t.prime.generateProbablePrime($, P, K);
    }
    function V($, K) {
      if ($)
        return O($);
      if (h.q = K, h.p.compareTo(h.q) < 0) {
        var Q = h.p;
        h.p = h.q, h.q = Q;
      }
      if (h.p.subtract(e.ONE).gcd(h.e).compareTo(e.ONE) !== 0) {
        h.p = null, L();
        return;
      }
      if (h.q.subtract(e.ONE).gcd(h.e).compareTo(e.ONE) !== 0) {
        h.q = null, D(h.qBits, V);
        return;
      }
      if (h.p1 = h.p.subtract(e.ONE), h.q1 = h.q.subtract(e.ONE), h.phi = h.p1.multiply(h.q1), h.phi.gcd(h.e).compareTo(e.ONE) !== 0) {
        h.p = h.q = null, L();
        return;
      }
      if (h.n = h.p.multiply(h.q), h.n.bitLength() !== h.bits) {
        h.q = null, D(h.qBits, V);
        return;
      }
      var ee = h.e.modInverse(h.phi);
      h.keys = {
        privateKey: a.rsa.setPrivateKey(
          h.n,
          h.e,
          ee,
          h.p,
          h.q,
          ee.mod(h.p1),
          ee.mod(h.q1),
          h.q.modInverse(h.p)
        ),
        publicKey: a.rsa.setPublicKey(h.n, h.e)
      }, O(null, h.keys);
    }
  }
  function c(h) {
    var d = h.toString(16);
    d[0] >= "8" && (d = "00" + d);
    var O = t.util.hexToBytes(d);
    return O.length > 1 && // leading 0x00 for positive integer
    (O.charCodeAt(0) === 0 && !(O.charCodeAt(1) & 128) || // leading 0xFF for negative integer
    O.charCodeAt(0) === 255 && (O.charCodeAt(1) & 128) === 128) ? O.substr(1) : O;
  }
  function E(h) {
    return h <= 100 ? 27 : h <= 150 ? 18 : h <= 200 ? 15 : h <= 250 ? 12 : h <= 300 ? 9 : h <= 350 ? 8 : h <= 400 ? 7 : h <= 500 ? 6 : h <= 600 ? 5 : h <= 800 ? 4 : h <= 1250 ? 3 : 2;
  }
  function v(h) {
    return t.util.isNodejs && typeof r[h] == "function";
  }
  function R(h) {
    return typeof i.globalScope < "u" && typeof i.globalScope.crypto == "object" && typeof i.globalScope.crypto.subtle == "object" && typeof i.globalScope.crypto.subtle[h] == "function";
  }
  function N(h) {
    return typeof i.globalScope < "u" && typeof i.globalScope.msCrypto == "object" && typeof i.globalScope.msCrypto.subtle == "object" && typeof i.globalScope.msCrypto.subtle[h] == "function";
  }
  function C(h) {
    for (var d = t.util.hexToBytes(h.toString(16)), O = new Uint8Array(d.length), P = 0; P < d.length; ++P)
      O[P] = d.charCodeAt(P);
    return O;
  }
  return hu;
}
var pu, ip;
function Sy() {
  if (ip) return pu;
  ip = 1;
  var t = Pe();
  if (ni(), Wr(), Po(), dn(), ii(), Tf(), Vi(), Pr(), Ay(), Bo(), $e(), typeof e > "u")
    var e = t.jsbn.BigInteger;
  var r = t.asn1, n = t.pki = t.pki || {};
  pu = n.pbe = t.pbe = t.pbe || {};
  var i = n.oids, a = {
    name: "EncryptedPrivateKeyInfo",
    tagClass: r.Class.UNIVERSAL,
    type: r.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.OID,
        constructed: !1,
        capture: "encryptionOid"
      }, {
        name: "AlgorithmIdentifier.parameters",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "encryptionParams"
      }]
    }, {
      // encryptedData
      name: "EncryptedPrivateKeyInfo.encryptedData",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.OCTETSTRING,
      constructed: !1,
      capture: "encryptedData"
    }]
  }, s = {
    name: "PBES2Algorithms",
    tagClass: r.Class.UNIVERSAL,
    type: r.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc.oid",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.OID,
        constructed: !1,
        capture: "kdfOid"
      }, {
        name: "PBES2Algorithms.params",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.params.salt",
          tagClass: r.Class.UNIVERSAL,
          type: r.Type.OCTETSTRING,
          constructed: !1,
          capture: "kdfSalt"
        }, {
          name: "PBES2Algorithms.params.iterationCount",
          tagClass: r.Class.UNIVERSAL,
          type: r.Type.INTEGER,
          constructed: !1,
          capture: "kdfIterationCount"
        }, {
          name: "PBES2Algorithms.params.keyLength",
          tagClass: r.Class.UNIVERSAL,
          type: r.Type.INTEGER,
          constructed: !1,
          optional: !0,
          capture: "keyLength"
        }, {
          // prf
          name: "PBES2Algorithms.params.prf",
          tagClass: r.Class.UNIVERSAL,
          type: r.Type.SEQUENCE,
          constructed: !0,
          optional: !0,
          value: [{
            name: "PBES2Algorithms.params.prf.algorithm",
            tagClass: r.Class.UNIVERSAL,
            type: r.Type.OID,
            constructed: !1,
            capture: "prfOid"
          }]
        }]
      }]
    }, {
      name: "PBES2Algorithms.encryptionScheme",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.encryptionScheme.oid",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.OID,
        constructed: !1,
        capture: "encOid"
      }, {
        name: "PBES2Algorithms.encryptionScheme.iv",
        tagClass: r.Class.UNIVERSAL,
        type: r.Type.OCTETSTRING,
        constructed: !1,
        capture: "encIv"
      }]
    }]
  }, o = {
    name: "pkcs-12PbeParams",
    tagClass: r.Class.UNIVERSAL,
    type: r.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "pkcs-12PbeParams.salt",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.OCTETSTRING,
      constructed: !1,
      capture: "salt"
    }, {
      name: "pkcs-12PbeParams.iterations",
      tagClass: r.Class.UNIVERSAL,
      type: r.Type.INTEGER,
      constructed: !1,
      capture: "iterations"
    }]
  };
  n.encryptPrivateKeyInfo = function(m, p, S) {
    S = S || {}, S.saltSize = S.saltSize || 8, S.count = S.count || 2048, S.algorithm = S.algorithm || "aes128", S.prfAlgorithm = S.prfAlgorithm || "sha1";
    var A = t.random.getBytesSync(S.saltSize), I = S.count, c = r.integerToDer(I), E, v, R;
    if (S.algorithm.indexOf("aes") === 0 || S.algorithm === "des") {
      var N, C, h;
      switch (S.algorithm) {
        case "aes128":
          E = 16, N = 16, C = i["aes128-CBC"], h = t.aes.createEncryptionCipher;
          break;
        case "aes192":
          E = 24, N = 16, C = i["aes192-CBC"], h = t.aes.createEncryptionCipher;
          break;
        case "aes256":
          E = 32, N = 16, C = i["aes256-CBC"], h = t.aes.createEncryptionCipher;
          break;
        case "des":
          E = 8, N = 8, C = i.desCBC, h = t.des.createEncryptionCipher;
          break;
        default:
          var d = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          throw d.algorithm = S.algorithm, d;
      }
      var O = "hmacWith" + S.prfAlgorithm.toUpperCase(), P = f(O), L = t.pkcs5.pbkdf2(p, A, I, E, P), D = t.random.getBytesSync(N), V = h(L);
      V.start(D), V.update(r.toDer(m)), V.finish(), R = V.output.getBytes();
      var $ = y(A, c, E, O);
      v = r.create(
        r.Class.UNIVERSAL,
        r.Type.SEQUENCE,
        !0,
        [
          r.create(
            r.Class.UNIVERSAL,
            r.Type.OID,
            !1,
            r.oidToDer(i.pkcs5PBES2).getBytes()
          ),
          r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
            // keyDerivationFunc
            r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
              r.create(
                r.Class.UNIVERSAL,
                r.Type.OID,
                !1,
                r.oidToDer(i.pkcs5PBKDF2).getBytes()
              ),
              // PBKDF2-params
              $
            ]),
            // encryptionScheme
            r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
              r.create(
                r.Class.UNIVERSAL,
                r.Type.OID,
                !1,
                r.oidToDer(C).getBytes()
              ),
              // iv
              r.create(
                r.Class.UNIVERSAL,
                r.Type.OCTETSTRING,
                !1,
                D
              )
            ])
          ])
        ]
      );
    } else if (S.algorithm === "3des") {
      E = 24;
      var K = new t.util.ByteBuffer(A), L = n.pbe.generatePkcs12Key(p, K, 1, I, E), D = n.pbe.generatePkcs12Key(p, K, 2, I, E), V = t.des.createEncryptionCipher(L);
      V.start(D), V.update(r.toDer(m)), V.finish(), R = V.output.getBytes(), v = r.create(
        r.Class.UNIVERSAL,
        r.Type.SEQUENCE,
        !0,
        [
          r.create(
            r.Class.UNIVERSAL,
            r.Type.OID,
            !1,
            r.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
          ),
          // pkcs-12PbeParams
          r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
            // salt
            r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, A),
            // iteration count
            r.create(
              r.Class.UNIVERSAL,
              r.Type.INTEGER,
              !1,
              c.getBytes()
            )
          ])
        ]
      );
    } else {
      var d = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      throw d.algorithm = S.algorithm, d;
    }
    var Q = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
      // encryptionAlgorithm
      v,
      // encryptedData
      r.create(
        r.Class.UNIVERSAL,
        r.Type.OCTETSTRING,
        !1,
        R
      )
    ]);
    return Q;
  }, n.decryptPrivateKeyInfo = function(m, p) {
    var S = null, A = {}, I = [];
    if (!r.validate(m, a, A, I)) {
      var c = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw c.errors = I, c;
    }
    var E = r.derToOid(A.encryptionOid), v = n.pbe.getCipher(E, A.encryptionParams, p), R = t.util.createBuffer(A.encryptedData);
    return v.update(R), v.finish() && (S = r.fromDer(v.output)), S;
  }, n.encryptedPrivateKeyToPem = function(m, p) {
    var S = {
      type: "ENCRYPTED PRIVATE KEY",
      body: r.toDer(m).getBytes()
    };
    return t.pem.encode(S, { maxline: p });
  }, n.encryptedPrivateKeyFromPem = function(m) {
    var p = t.pem.decode(m)[0];
    if (p.type !== "ENCRYPTED PRIVATE KEY") {
      var S = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      throw S.headerType = p.type, S;
    }
    if (p.procType && p.procType.type === "ENCRYPTED")
      throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    return r.fromDer(p.body);
  }, n.encryptRsaPrivateKey = function(m, p, S) {
    if (S = S || {}, !S.legacy) {
      var A = n.wrapRsaPrivateKey(n.privateKeyToAsn1(m));
      return A = n.encryptPrivateKeyInfo(A, p, S), n.encryptedPrivateKeyToPem(A);
    }
    var I, c, E, v;
    switch (S.algorithm) {
      case "aes128":
        I = "AES-128-CBC", E = 16, c = t.random.getBytesSync(16), v = t.aes.createEncryptionCipher;
        break;
      case "aes192":
        I = "AES-192-CBC", E = 24, c = t.random.getBytesSync(16), v = t.aes.createEncryptionCipher;
        break;
      case "aes256":
        I = "AES-256-CBC", E = 32, c = t.random.getBytesSync(16), v = t.aes.createEncryptionCipher;
        break;
      case "3des":
        I = "DES-EDE3-CBC", E = 24, c = t.random.getBytesSync(8), v = t.des.createEncryptionCipher;
        break;
      case "des":
        I = "DES-CBC", E = 8, c = t.random.getBytesSync(8), v = t.des.createEncryptionCipher;
        break;
      default:
        var R = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + S.algorithm + '".');
        throw R.algorithm = S.algorithm, R;
    }
    var N = t.pbe.opensslDeriveBytes(p, c.substr(0, 8), E), C = v(N);
    C.start(c), C.update(r.toDer(n.privateKeyToAsn1(m))), C.finish();
    var h = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm: I,
        parameters: t.util.bytesToHex(c).toUpperCase()
      },
      body: C.output.getBytes()
    };
    return t.pem.encode(h);
  }, n.decryptRsaPrivateKey = function(m, p) {
    var S = null, A = t.pem.decode(m)[0];
    if (A.type !== "ENCRYPTED PRIVATE KEY" && A.type !== "PRIVATE KEY" && A.type !== "RSA PRIVATE KEY") {
      var I = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      throw I.headerType = I, I;
    }
    if (A.procType && A.procType.type === "ENCRYPTED") {
      var c, E;
      switch (A.dekInfo.algorithm) {
        case "DES-CBC":
          c = 8, E = t.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          c = 24, E = t.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          c = 16, E = t.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          c = 24, E = t.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          c = 32, E = t.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          c = 5, E = function(h) {
            return t.rc2.createDecryptionCipher(h, 40);
          };
          break;
        case "RC2-64-CBC":
          c = 8, E = function(h) {
            return t.rc2.createDecryptionCipher(h, 64);
          };
          break;
        case "RC2-128-CBC":
          c = 16, E = function(h) {
            return t.rc2.createDecryptionCipher(h, 128);
          };
          break;
        default:
          var I = new Error('Could not decrypt private key; unsupported encryption algorithm "' + A.dekInfo.algorithm + '".');
          throw I.algorithm = A.dekInfo.algorithm, I;
      }
      var v = t.util.hexToBytes(A.dekInfo.parameters), R = t.pbe.opensslDeriveBytes(p, v.substr(0, 8), c), N = E(R);
      if (N.start(v), N.update(t.util.createBuffer(A.body)), N.finish())
        S = N.output.getBytes();
      else
        return S;
    } else
      S = A.body;
    return A.type === "ENCRYPTED PRIVATE KEY" ? S = n.decryptPrivateKeyInfo(r.fromDer(S), p) : S = r.fromDer(S), S !== null && (S = n.privateKeyFromAsn1(S)), S;
  }, n.pbe.generatePkcs12Key = function(m, p, S, A, I, c) {
    var E, v;
    if (typeof c > "u" || c === null) {
      if (!("sha1" in t.md))
        throw new Error('"sha1" hash algorithm unavailable.');
      c = t.md.sha1.create();
    }
    var R = c.digestLength, N = c.blockLength, C = new t.util.ByteBuffer(), h = new t.util.ByteBuffer();
    if (m != null) {
      for (v = 0; v < m.length; v++)
        h.putInt16(m.charCodeAt(v));
      h.putInt16(0);
    }
    var d = h.length(), O = p.length(), P = new t.util.ByteBuffer();
    P.fillWithByte(S, N);
    var L = N * Math.ceil(O / N), D = new t.util.ByteBuffer();
    for (v = 0; v < L; v++)
      D.putByte(p.at(v % O));
    var V = N * Math.ceil(d / N), $ = new t.util.ByteBuffer();
    for (v = 0; v < V; v++)
      $.putByte(h.at(v % d));
    var K = D;
    K.putBuffer($);
    for (var Q = Math.ceil(I / R), ee = 1; ee <= Q; ee++) {
      var ne = new t.util.ByteBuffer();
      ne.putBytes(P.bytes()), ne.putBytes(K.bytes());
      for (var ae = 0; ae < A; ae++)
        c.start(), c.update(ne.getBytes()), ne = c.digest();
      var se = new t.util.ByteBuffer();
      for (v = 0; v < N; v++)
        se.putByte(ne.at(v % R));
      var me = Math.ceil(O / N) + Math.ceil(d / N), ye = new t.util.ByteBuffer();
      for (E = 0; E < me; E++) {
        var Se = new t.util.ByteBuffer(K.getBytes(N)), te = 511;
        for (v = se.length() - 1; v >= 0; v--)
          te = te >> 8, te += se.at(v) + Se.at(v), Se.setAt(v, te & 255);
        ye.putBuffer(Se);
      }
      K = ye, C.putBuffer(ne);
    }
    return C.truncate(C.length() - I), C;
  }, n.pbe.getCipher = function(m, p, S) {
    switch (m) {
      case n.oids.pkcs5PBES2:
        return n.pbe.getCipherForPBES2(m, p, S);
      case n.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case n.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return n.pbe.getCipherForPKCS12PBE(m, p, S);
      default:
        var A = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        throw A.oid = m, A.supportedOids = [
          "pkcs5PBES2",
          "pbeWithSHAAnd3-KeyTripleDES-CBC",
          "pbewithSHAAnd40BitRC2-CBC"
        ], A;
    }
  }, n.pbe.getCipherForPBES2 = function(m, p, S) {
    var A = {}, I = [];
    if (!r.validate(p, s, A, I)) {
      var c = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw c.errors = I, c;
    }
    if (m = r.derToOid(A.kdfOid), m !== n.oids.pkcs5PBKDF2) {
      var c = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      throw c.oid = m, c.supportedOids = ["pkcs5PBKDF2"], c;
    }
    if (m = r.derToOid(A.encOid), m !== n.oids["aes128-CBC"] && m !== n.oids["aes192-CBC"] && m !== n.oids["aes256-CBC"] && m !== n.oids["des-EDE3-CBC"] && m !== n.oids.desCBC) {
      var c = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      throw c.oid = m, c.supportedOids = [
        "aes128-CBC",
        "aes192-CBC",
        "aes256-CBC",
        "des-EDE3-CBC",
        "desCBC"
      ], c;
    }
    var E = A.kdfSalt, v = t.util.createBuffer(A.kdfIterationCount);
    v = v.getInt(v.length() << 3);
    var R, N;
    switch (n.oids[m]) {
      case "aes128-CBC":
        R = 16, N = t.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        R = 24, N = t.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        R = 32, N = t.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        R = 24, N = t.des.createDecryptionCipher;
        break;
      case "desCBC":
        R = 8, N = t.des.createDecryptionCipher;
        break;
    }
    var C = u(A.prfOid), h = t.pkcs5.pbkdf2(S, E, v, R, C), d = A.encIv, O = N(h);
    return O.start(d), O;
  }, n.pbe.getCipherForPKCS12PBE = function(m, p, S) {
    var A = {}, I = [];
    if (!r.validate(p, o, A, I)) {
      var c = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw c.errors = I, c;
    }
    var E = t.util.createBuffer(A.salt), v = t.util.createBuffer(A.iterations);
    v = v.getInt(v.length() << 3);
    var R, N, C;
    switch (m) {
      case n.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        R = 24, N = 8, C = t.des.startDecrypting;
        break;
      case n.oids["pbewithSHAAnd40BitRC2-CBC"]:
        R = 5, N = 8, C = function(L, D) {
          var V = t.rc2.createDecryptionCipher(L, 40);
          return V.start(D, null), V;
        };
        break;
      default:
        var c = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        throw c.oid = m, c;
    }
    var h = u(A.prfOid), d = n.pbe.generatePkcs12Key(S, E, 1, v, R, h);
    h.start();
    var O = n.pbe.generatePkcs12Key(S, E, 2, v, N, h);
    return C(d, O);
  }, n.pbe.opensslDeriveBytes = function(m, p, S, A) {
    if (typeof A > "u" || A === null) {
      if (!("md5" in t.md))
        throw new Error('"md5" hash algorithm unavailable.');
      A = t.md.md5.create();
    }
    p === null && (p = "");
    for (var I = [l(A, m + p)], c = 16, E = 1; c < S; ++E, c += 16)
      I.push(l(A, I[E - 1] + m + p));
    return I.join("").substr(0, S);
  };
  function l(m, p) {
    return m.start().update(p).digest().getBytes();
  }
  function u(m) {
    var p;
    if (!m)
      p = "hmacWithSHA1";
    else if (p = n.oids[r.derToOid(m)], !p) {
      var S = new Error("Unsupported PRF OID.");
      throw S.oid = m, S.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ], S;
    }
    return f(p);
  }
  function f(m) {
    var p = t.md;
    switch (m) {
      case "hmacWithSHA224":
        p = t.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        m = m.substr(8).toLowerCase();
        break;
      default:
        var S = new Error("Unsupported PRF algorithm.");
        throw S.algorithm = m, S.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ], S;
    }
    if (!p || !(m in p))
      throw new Error("Unknown hash algorithm: " + m);
    return p[m].create();
  }
  function y(m, p, S, A) {
    var I = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
      // salt
      r.create(
        r.Class.UNIVERSAL,
        r.Type.OCTETSTRING,
        !1,
        m
      ),
      // iteration count
      r.create(
        r.Class.UNIVERSAL,
        r.Type.INTEGER,
        !1,
        p.getBytes()
      )
    ]);
    return A !== "hmacWithSHA1" && I.value.push(
      // key length
      r.create(
        r.Class.UNIVERSAL,
        r.Type.INTEGER,
        !1,
        t.util.hexToBytes(S.toString(16))
      ),
      // AlgorithmIdentifier
      r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [
        // algorithm
        r.create(
          r.Class.UNIVERSAL,
          r.Type.OID,
          !1,
          r.oidToDer(n.oids[A]).getBytes()
        ),
        // parameters (null)
        r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")
      ])
    ), I;
  }
  return pu;
}
var gu = { exports: {} }, yu = { exports: {} }, ap;
function Iy() {
  if (ap) return yu.exports;
  ap = 1;
  var t = Pe();
  Wr(), $e();
  var e = t.asn1, r = yu.exports = t.pkcs7asn1 = t.pkcs7asn1 || {};
  t.pkcs7 = t.pkcs7 || {}, t.pkcs7.asn1 = r;
  var n = {
    name: "ContentInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "ContentInfo.ContentType",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      captureAsn1: "content"
    }]
  };
  r.contentInfoValidator = n;
  var i = {
    name: "EncryptedContentInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedContentInfo.contentType",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "contentType"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.OID,
        constructed: !1,
        capture: "encAlgorithm"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
        tagClass: e.Class.UNIVERSAL,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "EncryptedContentInfo.encryptedContent",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 0,
      /* The PKCS#7 structure output by OpenSSL somewhat differs from what
       * other implementations do generate.
       *
       * OpenSSL generates a structure like this:
       * SEQUENCE {
       *    ...
       *    [0]
       *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
       *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
       *       ...
       * }
       *
       * Whereas other implementations (and this PKCS#7 module) generate:
       * SEQUENCE {
       *    ...
       *    [0] {
       *       OCTET STRING
       *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
       *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
       *          ...
       *    }
       * }
       *
       * In order to support both, we just capture the context specific
       * field here.  The OCTET STRING bit is removed below.
       */
      capture: "encryptedContent",
      captureAsn1: "encryptedContentAsn1"
    }]
  };
  r.envelopedDataValidator = {
    name: "EnvelopedData",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EnvelopedData.Version",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }, {
      name: "EnvelopedData.RecipientInfos",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SET,
      constructed: !0,
      captureAsn1: "recipientInfos"
    }].concat(i)
  }, r.encryptedDataValidator = {
    name: "EncryptedData",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedData.Version",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }].concat(i)
  };
  var a = {
    name: "SignerInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.version",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.INTEGER,
      constructed: !1
    }, {
      name: "SignerInfo.issuerAndSerialNumber",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignerInfo.issuerAndSerialNumber.issuer",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "issuer"
      }, {
        name: "SignerInfo.issuerAndSerialNumber.serialNumber",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.INTEGER,
        constructed: !1,
        capture: "serial"
      }]
    }, {
      name: "SignerInfo.digestAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignerInfo.digestAlgorithm.algorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.OID,
        constructed: !1,
        capture: "digestAlgorithm"
      }, {
        name: "SignerInfo.digestAlgorithm.parameter",
        tagClass: e.Class.UNIVERSAL,
        constructed: !1,
        captureAsn1: "digestParameter",
        optional: !0
      }]
    }, {
      name: "SignerInfo.authenticatedAttributes",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      capture: "authenticatedAttributes"
    }, {
      name: "SignerInfo.digestEncryptionAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      capture: "signatureAlgorithm"
    }, {
      name: "SignerInfo.encryptedDigest",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OCTETSTRING,
      constructed: !1,
      capture: "signature"
    }, {
      name: "SignerInfo.unauthenticatedAttributes",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: !0,
      optional: !0,
      capture: "unauthenticatedAttributes"
    }]
  };
  return r.signedDataValidator = {
    name: "SignedData",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: "SignedData.Version",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.INTEGER,
        constructed: !1,
        capture: "version"
      },
      {
        name: "SignedData.DigestAlgorithms",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SET,
        constructed: !0,
        captureAsn1: "digestAlgorithms"
      },
      n,
      {
        name: "SignedData.Certificates",
        tagClass: e.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: !0,
        captureAsn1: "certificates"
      },
      {
        name: "SignedData.CertificateRevocationLists",
        tagClass: e.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: !0,
        captureAsn1: "crls"
      },
      {
        name: "SignedData.SignerInfos",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SET,
        capture: "signerInfos",
        optional: !0,
        value: [a]
      }
    ]
  }, r.recipientInfoValidator = {
    name: "RecipientInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.version",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }, {
      name: "RecipientInfo.issuerAndSerial",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RecipientInfo.issuerAndSerial.issuer",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "issuer"
      }, {
        name: "RecipientInfo.issuerAndSerial.serialNumber",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.INTEGER,
        constructed: !1,
        capture: "serial"
      }]
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.OID,
        constructed: !1,
        capture: "encAlgorithm"
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
        tagClass: e.Class.UNIVERSAL,
        constructed: !1,
        captureAsn1: "encParameter",
        optional: !0
      }]
    }, {
      name: "RecipientInfo.encryptedKey",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OCTETSTRING,
      constructed: !1,
      capture: "encKey"
    }]
  }, yu.exports;
}
var mu = { exports: {} }, Eu = { exports: {} }, sp;
function by() {
  if (sp) return Eu.exports;
  sp = 1;
  var t = Pe();
  $e(), t.mgf = t.mgf || {};
  var e = Eu.exports = t.mgf.mgf1 = t.mgf1 = t.mgf1 || {};
  return e.create = function(r) {
    var n = {
      /**
       * Generate mask of specified length.
       *
       * @param {String} seed The seed for mask generation.
       * @param maskLen Number of bytes to generate.
       * @return {String} The generated mask.
       */
      generate: function(i, a) {
        for (var s = new t.util.ByteBuffer(), o = Math.ceil(a / r.digestLength), l = 0; l < o; l++) {
          var u = new t.util.ByteBuffer();
          u.putInt32(l), r.start(), r.update(i + u.getBytes()), s.putBuffer(r.digest());
        }
        return s.truncate(s.length() - a), s.getBytes();
      }
    };
    return n;
  }, Eu.exports;
}
var vu, op;
function jI() {
  if (op) return vu;
  op = 1;
  var t = Pe();
  return by(), vu = t.mgf = t.mgf || {}, t.mgf.mgf1 = t.mgf1, vu;
}
var Au = { exports: {} }, cp;
function Rf() {
  if (cp) return Au.exports;
  cp = 1;
  var t = Pe();
  Pr(), $e();
  var e = Au.exports = t.pss = t.pss || {};
  return e.create = function(r) {
    arguments.length === 3 && (r = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    });
    var n = r.md, i = r.mgf, a = n.digestLength, s = r.salt || null;
    typeof s == "string" && (s = t.util.createBuffer(s));
    var o;
    if ("saltLength" in r)
      o = r.saltLength;
    else if (s !== null)
      o = s.length();
    else
      throw new Error("Salt length not specified or specific salt not given.");
    if (s !== null && s.length() !== o)
      throw new Error("Given salt length does not match length of given salt.");
    var l = r.prng || t.random, u = {};
    return u.encode = function(f, y) {
      var m, p = y - 1, S = Math.ceil(p / 8), A = f.digest().getBytes();
      if (S < a + o + 2)
        throw new Error("Message is too long to encrypt.");
      var I;
      s === null ? I = l.getBytesSync(o) : I = s.bytes();
      var c = new t.util.ByteBuffer();
      c.fillWithByte(0, 8), c.putBytes(A), c.putBytes(I), n.start(), n.update(c.getBytes());
      var E = n.digest().getBytes(), v = new t.util.ByteBuffer();
      v.fillWithByte(0, S - o - a - 2), v.putByte(1), v.putBytes(I);
      var R = v.getBytes(), N = S - a - 1, C = i.generate(E, N), h = "";
      for (m = 0; m < N; m++)
        h += String.fromCharCode(R.charCodeAt(m) ^ C.charCodeAt(m));
      var d = 65280 >> 8 * S - p & 255;
      return h = String.fromCharCode(h.charCodeAt(0) & ~d) + h.substr(1), h + E + "";
    }, u.verify = function(f, y, m) {
      var p, S = m - 1, A = Math.ceil(S / 8);
      if (y = y.substr(-A), A < a + o + 2)
        throw new Error("Inconsistent parameters to PSS signature verification.");
      if (y.charCodeAt(A - 1) !== 188)
        throw new Error("Encoded message does not end in 0xBC.");
      var I = A - a - 1, c = y.substr(0, I), E = y.substr(I, a), v = 65280 >> 8 * A - S & 255;
      if (c.charCodeAt(0) & v)
        throw new Error("Bits beyond keysize not zero as expected.");
      var R = i.generate(E, I), N = "";
      for (p = 0; p < I; p++)
        N += String.fromCharCode(c.charCodeAt(p) ^ R.charCodeAt(p));
      N = String.fromCharCode(N.charCodeAt(0) & ~v) + N.substr(1);
      var C = A - a - o - 2;
      for (p = 0; p < C; p++)
        if (N.charCodeAt(p) !== 0)
          throw new Error("Leftmost octets not zero as expected");
      if (N.charCodeAt(C) !== 1)
        throw new Error("Inconsistent PSS signature, 0x01 marker not found");
      var h = N.substr(-o), d = new t.util.ByteBuffer();
      d.fillWithByte(0, 8), d.putBytes(f), d.putBytes(h), n.start(), n.update(d.getBytes());
      var O = n.digest().getBytes();
      return E === O;
    }, u;
  }, Au.exports;
}
var up;
function Nf() {
  if (up) return mu.exports;
  up = 1;
  var t = Pe();
  ni(), Wr(), Po(), dn(), jI(), ii(), Vi(), Rf(), Bo(), $e();
  var e = t.asn1, r = mu.exports = t.pki = t.pki || {}, n = r.oids, i = {};
  i.CN = n.commonName, i.commonName = "CN", i.C = n.countryName, i.countryName = "C", i.L = n.localityName, i.localityName = "L", i.ST = n.stateOrProvinceName, i.stateOrProvinceName = "ST", i.O = n.organizationName, i.organizationName = "O", i.OU = n.organizationalUnitName, i.organizationalUnitName = "OU", i.E = n.emailAddress, i.emailAddress = "E";
  var a = t.pki.rsa.publicKeyValidator, s = {
    name: "Certificate",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "Certificate.TBSCertificate",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "tbsCertificate",
      value: [
        {
          name: "Certificate.TBSCertificate.version",
          tagClass: e.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.version.integer",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.INTEGER,
            constructed: !1,
            capture: "certVersion"
          }]
        },
        {
          name: "Certificate.TBSCertificate.serialNumber",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.INTEGER,
          constructed: !1,
          capture: "certSerialNumber"
        },
        {
          name: "Certificate.TBSCertificate.signature",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate.signature.algorithm",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.OID,
            constructed: !1,
            capture: "certinfoSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: e.Class.UNIVERSAL,
            optional: !0,
            captureAsn1: "certinfoSignatureParams"
          }]
        },
        {
          name: "Certificate.TBSCertificate.issuer",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certIssuer"
        },
        {
          name: "Certificate.TBSCertificate.validity",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          // Note: UTC and generalized times may both appear so the capture
          // names are based on their detected order, the names used below
          // are only for the common case, which validity time really means
          // "notBefore" and which means "notAfter" will be determined by order
          value: [{
            // notBefore (Time) (UTC time case)
            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity1UTCTime"
          }, {
            // notBefore (Time) (generalized time case)
            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity2GeneralizedTime"
          }, {
            // notAfter (Time) (only UTC time is supported)
            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity3UTCTime"
          }, {
            // notAfter (Time) (only UTC time is supported)
            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity4GeneralizedTime"
          }]
        },
        {
          // Name (subject) (RDNSequence)
          name: "Certificate.TBSCertificate.subject",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certSubject"
        },
        // SubjectPublicKeyInfo
        a,
        {
          // issuerUniqueID (optional)
          name: "Certificate.TBSCertificate.issuerUniqueID",
          tagClass: e.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.issuerUniqueID.id",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.BITSTRING,
            constructed: !1,
            // TODO: support arbitrary bit length ids
            captureBitStringValue: "certIssuerUniqueId"
          }]
        },
        {
          // subjectUniqueID (optional)
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: e.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.subjectUniqueID.id",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.BITSTRING,
            constructed: !1,
            // TODO: support arbitrary bit length ids
            captureBitStringValue: "certSubjectUniqueId"
          }]
        },
        {
          // Extensions (optional)
          name: "Certificate.TBSCertificate.extensions",
          tagClass: e.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: !0,
          captureAsn1: "certExtensions",
          optional: !0
        }
      ]
    }, {
      // AlgorithmIdentifier (signature algorithm)
      name: "Certificate.signatureAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        // algorithm
        name: "Certificate.signatureAlgorithm.algorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.OID,
        constructed: !1,
        capture: "certSignatureOid"
      }, {
        name: "Certificate.TBSCertificate.signature.parameters",
        tagClass: e.Class.UNIVERSAL,
        optional: !0,
        captureAsn1: "certSignatureParams"
      }]
    }, {
      // SignatureValue
      name: "Certificate.signatureValue",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.BITSTRING,
      constructed: !1,
      captureBitStringValue: "certSignature"
    }]
  }, o = {
    name: "rsapss",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "rsapss.hashAlgorithm",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
        tagClass: e.Class.UNIVERSAL,
        type: e.Class.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.OID,
          constructed: !1,
          capture: "hashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }, {
      name: "rsapss.maskGenAlgorithm",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: !0,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
        tagClass: e.Class.UNIVERSAL,
        type: e.Class.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.OID,
          constructed: !1,
          capture: "maskGenOid"
        }, {
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.OID,
            constructed: !1,
            capture: "maskGenHashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }]
    }, {
      name: "rsapss.saltLength",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 2,
      optional: !0,
      value: [{
        name: "rsapss.saltLength.saltLength",
        tagClass: e.Class.UNIVERSAL,
        type: e.Class.INTEGER,
        constructed: !1,
        capture: "saltLength"
      }]
    }, {
      name: "rsapss.trailerField",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      type: 3,
      optional: !0,
      value: [{
        name: "rsapss.trailer.trailer",
        tagClass: e.Class.UNIVERSAL,
        type: e.Class.INTEGER,
        constructed: !1,
        capture: "trailer"
      }]
    }]
  }, l = {
    name: "CertificationRequestInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "certificationRequestInfo",
    value: [
      {
        name: "CertificationRequestInfo.integer",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.INTEGER,
        constructed: !1,
        capture: "certificationRequestInfoVersion"
      },
      {
        // Name (subject) (RDNSequence)
        name: "CertificationRequestInfo.subject",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certificationRequestInfoSubject"
      },
      // SubjectPublicKeyInfo
      a,
      {
        name: "CertificationRequestInfo.attributes",
        tagClass: e.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        capture: "certificationRequestInfoAttributes",
        value: [{
          name: "CertificationRequestInfo.attributes",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "CertificationRequestInfo.attributes.type",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.OID,
            constructed: !1
          }, {
            name: "CertificationRequestInfo.attributes.value",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.SET,
            constructed: !0
          }]
        }]
      }
    ]
  }, u = {
    name: "CertificationRequest",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "csr",
    value: [
      l,
      {
        // AlgorithmIdentifier (signature algorithm)
        name: "CertificationRequest.signatureAlgorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        value: [{
          // algorithm
          name: "CertificationRequest.signatureAlgorithm.algorithm",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.OID,
          constructed: !1,
          capture: "csrSignatureOid"
        }, {
          name: "CertificationRequest.signatureAlgorithm.parameters",
          tagClass: e.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "csrSignatureParams"
        }]
      },
      {
        // signature
        name: "CertificationRequest.signature",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.BITSTRING,
        constructed: !1,
        captureBitStringValue: "csrSignature"
      }
    ]
  };
  r.RDNAttributesAsArray = function(C, h) {
    for (var d = [], O, P, L, D = 0; D < C.value.length; ++D) {
      O = C.value[D];
      for (var V = 0; V < O.value.length; ++V)
        L = {}, P = O.value[V], L.type = e.derToOid(P.value[0].value), L.value = P.value[1].value, L.valueTagClass = P.value[1].type, L.type in n && (L.name = n[L.type], L.name in i && (L.shortName = i[L.name])), h && (h.update(L.type), h.update(L.value)), d.push(L);
    }
    return d;
  }, r.CRIAttributesAsArray = function(C) {
    for (var h = [], d = 0; d < C.length; ++d)
      for (var O = C[d], P = e.derToOid(O.value[0].value), L = O.value[1].value, D = 0; D < L.length; ++D) {
        var V = {};
        if (V.type = P, V.value = L[D].value, V.valueTagClass = L[D].type, V.type in n && (V.name = n[V.type], V.name in i && (V.shortName = i[V.name])), V.type === n.extensionRequest) {
          V.extensions = [];
          for (var $ = 0; $ < V.value.length; ++$)
            V.extensions.push(r.certificateExtensionFromAsn1(V.value[$]));
        }
        h.push(V);
      }
    return h;
  };
  function f(C, h) {
    typeof h == "string" && (h = { shortName: h });
    for (var d = null, O, P = 0; d === null && P < C.attributes.length; ++P)
      O = C.attributes[P], (h.type && h.type === O.type || h.name && h.name === O.name || h.shortName && h.shortName === O.shortName) && (d = O);
    return d;
  }
  var y = function(C, h, d) {
    var O = {};
    if (C !== n["RSASSA-PSS"])
      return O;
    d && (O = {
      hash: {
        algorithmOid: n.sha1
      },
      mgf: {
        algorithmOid: n.mgf1,
        hash: {
          algorithmOid: n.sha1
        }
      },
      saltLength: 20
    });
    var P = {}, L = [];
    if (!e.validate(h, o, P, L)) {
      var D = new Error("Cannot read RSASSA-PSS parameter block.");
      throw D.errors = L, D;
    }
    return P.hashOid !== void 0 && (O.hash = O.hash || {}, O.hash.algorithmOid = e.derToOid(P.hashOid)), P.maskGenOid !== void 0 && (O.mgf = O.mgf || {}, O.mgf.algorithmOid = e.derToOid(P.maskGenOid), O.mgf.hash = O.mgf.hash || {}, O.mgf.hash.algorithmOid = e.derToOid(P.maskGenHashOid)), P.saltLength !== void 0 && (O.saltLength = P.saltLength.charCodeAt(0)), O;
  }, m = function(C) {
    switch (n[C.signatureOid]) {
      case "sha1WithRSAEncryption":
      case "sha1WithRSASignature":
        return t.md.sha1.create();
      case "md5WithRSAEncryption":
        return t.md.md5.create();
      case "sha256WithRSAEncryption":
        return t.md.sha256.create();
      case "sha384WithRSAEncryption":
        return t.md.sha384.create();
      case "sha512WithRSAEncryption":
        return t.md.sha512.create();
      case "RSASSA-PSS":
        return t.md.sha256.create();
      default:
        var h = new Error(
          "Could not compute " + C.type + " digest. Unknown signature OID."
        );
        throw h.signatureOid = C.signatureOid, h;
    }
  }, p = function(C) {
    var h = C.certificate, d;
    switch (h.signatureOid) {
      case n.sha1WithRSAEncryption:
      case n.sha1WithRSASignature:
        break;
      case n["RSASSA-PSS"]:
        var O, P;
        if (O = n[h.signatureParameters.mgf.hash.algorithmOid], O === void 0 || t.md[O] === void 0) {
          var L = new Error("Unsupported MGF hash function.");
          throw L.oid = h.signatureParameters.mgf.hash.algorithmOid, L.name = O, L;
        }
        if (P = n[h.signatureParameters.mgf.algorithmOid], P === void 0 || t.mgf[P] === void 0) {
          var L = new Error("Unsupported MGF function.");
          throw L.oid = h.signatureParameters.mgf.algorithmOid, L.name = P, L;
        }
        if (P = t.mgf[P].create(t.md[O].create()), O = n[h.signatureParameters.hash.algorithmOid], O === void 0 || t.md[O] === void 0) {
          var L = new Error("Unsupported RSASSA-PSS hash function.");
          throw L.oid = h.signatureParameters.hash.algorithmOid, L.name = O, L;
        }
        d = t.pss.create(
          t.md[O].create(),
          P,
          h.signatureParameters.saltLength
        );
        break;
    }
    return h.publicKey.verify(
      C.md.digest().getBytes(),
      C.signature,
      d
    );
  };
  r.certificateFromPem = function(C, h, d) {
    var O = t.pem.decode(C)[0];
    if (O.type !== "CERTIFICATE" && O.type !== "X509 CERTIFICATE" && O.type !== "TRUSTED CERTIFICATE") {
      var P = new Error(
        'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
      );
      throw P.headerType = O.type, P;
    }
    if (O.procType && O.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert certificate from PEM; PEM is encrypted."
      );
    var L = e.fromDer(O.body, d);
    return r.certificateFromAsn1(L, h);
  }, r.certificateToPem = function(C, h) {
    var d = {
      type: "CERTIFICATE",
      body: e.toDer(r.certificateToAsn1(C)).getBytes()
    };
    return t.pem.encode(d, { maxline: h });
  }, r.publicKeyFromPem = function(C) {
    var h = t.pem.decode(C)[0];
    if (h.type !== "PUBLIC KEY" && h.type !== "RSA PUBLIC KEY") {
      var d = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      throw d.headerType = h.type, d;
    }
    if (h.procType && h.procType.type === "ENCRYPTED")
      throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    var O = e.fromDer(h.body);
    return r.publicKeyFromAsn1(O);
  }, r.publicKeyToPem = function(C, h) {
    var d = {
      type: "PUBLIC KEY",
      body: e.toDer(r.publicKeyToAsn1(C)).getBytes()
    };
    return t.pem.encode(d, { maxline: h });
  }, r.publicKeyToRSAPublicKeyPem = function(C, h) {
    var d = {
      type: "RSA PUBLIC KEY",
      body: e.toDer(r.publicKeyToRSAPublicKey(C)).getBytes()
    };
    return t.pem.encode(d, { maxline: h });
  }, r.getPublicKeyFingerprint = function(C, h) {
    h = h || {};
    var d = h.md || t.md.sha1.create(), O = h.type || "RSAPublicKey", P;
    switch (O) {
      case "RSAPublicKey":
        P = e.toDer(r.publicKeyToRSAPublicKey(C)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        P = e.toDer(r.publicKeyToAsn1(C)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + h.type + '".');
    }
    d.start(), d.update(P);
    var L = d.digest();
    if (h.encoding === "hex") {
      var D = L.toHex();
      return h.delimiter ? D.match(/.{2}/g).join(h.delimiter) : D;
    } else {
      if (h.encoding === "binary")
        return L.getBytes();
      if (h.encoding)
        throw new Error('Unknown encoding "' + h.encoding + '".');
    }
    return L;
  }, r.certificationRequestFromPem = function(C, h, d) {
    var O = t.pem.decode(C)[0];
    if (O.type !== "CERTIFICATE REQUEST") {
      var P = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      throw P.headerType = O.type, P;
    }
    if (O.procType && O.procType.type === "ENCRYPTED")
      throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    var L = e.fromDer(O.body, d);
    return r.certificationRequestFromAsn1(L, h);
  }, r.certificationRequestToPem = function(C, h) {
    var d = {
      type: "CERTIFICATE REQUEST",
      body: e.toDer(r.certificationRequestToAsn1(C)).getBytes()
    };
    return t.pem.encode(d, { maxline: h });
  }, r.createCertificate = function() {
    var C = {};
    return C.version = 2, C.serialNumber = "00", C.signatureOid = null, C.signature = null, C.siginfo = {}, C.siginfo.algorithmOid = null, C.validity = {}, C.validity.notBefore = /* @__PURE__ */ new Date(), C.validity.notAfter = /* @__PURE__ */ new Date(), C.issuer = {}, C.issuer.getField = function(h) {
      return f(C.issuer, h);
    }, C.issuer.addField = function(h) {
      A([h]), C.issuer.attributes.push(h);
    }, C.issuer.attributes = [], C.issuer.hash = null, C.subject = {}, C.subject.getField = function(h) {
      return f(C.subject, h);
    }, C.subject.addField = function(h) {
      A([h]), C.subject.attributes.push(h);
    }, C.subject.attributes = [], C.subject.hash = null, C.extensions = [], C.publicKey = null, C.md = null, C.setSubject = function(h, d) {
      A(h), C.subject.attributes = h, delete C.subject.uniqueId, d && (C.subject.uniqueId = d), C.subject.hash = null;
    }, C.setIssuer = function(h, d) {
      A(h), C.issuer.attributes = h, delete C.issuer.uniqueId, d && (C.issuer.uniqueId = d), C.issuer.hash = null;
    }, C.setExtensions = function(h) {
      for (var d = 0; d < h.length; ++d)
        I(h[d], { cert: C });
      C.extensions = h;
    }, C.getExtension = function(h) {
      typeof h == "string" && (h = { name: h });
      for (var d = null, O, P = 0; d === null && P < C.extensions.length; ++P)
        O = C.extensions[P], (h.id && O.id === h.id || h.name && O.name === h.name) && (d = O);
      return d;
    }, C.sign = function(h, d) {
      C.md = d || t.md.sha1.create();
      var O = n[C.md.algorithm + "WithRSAEncryption"];
      if (!O) {
        var P = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        throw P.algorithm = C.md.algorithm, P;
      }
      C.signatureOid = C.siginfo.algorithmOid = O, C.tbsCertificate = r.getTBSCertificate(C);
      var L = e.toDer(C.tbsCertificate);
      C.md.update(L.getBytes()), C.signature = h.sign(C.md);
    }, C.verify = function(h) {
      var d = !1;
      if (!C.issued(h)) {
        var O = h.issuer, P = C.subject, L = new Error(
          "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
        );
        throw L.expectedIssuer = P.attributes, L.actualIssuer = O.attributes, L;
      }
      var D = h.md;
      if (D === null) {
        D = m({
          signatureOid: h.signatureOid,
          type: "certificate"
        });
        var V = h.tbsCertificate || r.getTBSCertificate(h), $ = e.toDer(V);
        D.update($.getBytes());
      }
      return D !== null && (d = p({
        certificate: C,
        md: D,
        signature: h.signature
      })), d;
    }, C.isIssuer = function(h) {
      var d = !1, O = C.issuer, P = h.subject;
      if (O.hash && P.hash)
        d = O.hash === P.hash;
      else if (O.attributes.length === P.attributes.length) {
        d = !0;
        for (var L, D, V = 0; d && V < O.attributes.length; ++V)
          L = O.attributes[V], D = P.attributes[V], (L.type !== D.type || L.value !== D.value) && (d = !1);
      }
      return d;
    }, C.issued = function(h) {
      return h.isIssuer(C);
    }, C.generateSubjectKeyIdentifier = function() {
      return r.getPublicKeyFingerprint(C.publicKey, { type: "RSAPublicKey" });
    }, C.verifySubjectKeyIdentifier = function() {
      for (var h = n.subjectKeyIdentifier, d = 0; d < C.extensions.length; ++d) {
        var O = C.extensions[d];
        if (O.id === h) {
          var P = C.generateSubjectKeyIdentifier().getBytes();
          return t.util.hexToBytes(O.subjectKeyIdentifier) === P;
        }
      }
      return !1;
    }, C;
  }, r.certificateFromAsn1 = function(C, h) {
    var d = {}, O = [];
    if (!e.validate(C, s, d, O)) {
      var P = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
      throw P.errors = O, P;
    }
    var L = e.derToOid(d.publicKeyOid);
    if (L !== r.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.");
    var D = r.createCertificate();
    D.version = d.certVersion ? d.certVersion.charCodeAt(0) : 0;
    var V = t.util.createBuffer(d.certSerialNumber);
    D.serialNumber = V.toHex(), D.signatureOid = t.asn1.derToOid(d.certSignatureOid), D.signatureParameters = y(
      D.signatureOid,
      d.certSignatureParams,
      !0
    ), D.siginfo.algorithmOid = t.asn1.derToOid(d.certinfoSignatureOid), D.siginfo.parameters = y(
      D.siginfo.algorithmOid,
      d.certinfoSignatureParams,
      !1
    ), D.signature = d.certSignature;
    var $ = [];
    if (d.certValidity1UTCTime !== void 0 && $.push(e.utcTimeToDate(d.certValidity1UTCTime)), d.certValidity2GeneralizedTime !== void 0 && $.push(e.generalizedTimeToDate(
      d.certValidity2GeneralizedTime
    )), d.certValidity3UTCTime !== void 0 && $.push(e.utcTimeToDate(d.certValidity3UTCTime)), d.certValidity4GeneralizedTime !== void 0 && $.push(e.generalizedTimeToDate(
      d.certValidity4GeneralizedTime
    )), $.length > 2)
      throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    if ($.length < 2)
      throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    if (D.validity.notBefore = $[0], D.validity.notAfter = $[1], D.tbsCertificate = d.tbsCertificate, h) {
      D.md = m({
        signatureOid: D.signatureOid,
        type: "certificate"
      });
      var K = e.toDer(D.tbsCertificate);
      D.md.update(K.getBytes());
    }
    var Q = t.md.sha1.create(), ee = e.toDer(d.certIssuer);
    Q.update(ee.getBytes()), D.issuer.getField = function(se) {
      return f(D.issuer, se);
    }, D.issuer.addField = function(se) {
      A([se]), D.issuer.attributes.push(se);
    }, D.issuer.attributes = r.RDNAttributesAsArray(d.certIssuer), d.certIssuerUniqueId && (D.issuer.uniqueId = d.certIssuerUniqueId), D.issuer.hash = Q.digest().toHex();
    var ne = t.md.sha1.create(), ae = e.toDer(d.certSubject);
    return ne.update(ae.getBytes()), D.subject.getField = function(se) {
      return f(D.subject, se);
    }, D.subject.addField = function(se) {
      A([se]), D.subject.attributes.push(se);
    }, D.subject.attributes = r.RDNAttributesAsArray(d.certSubject), d.certSubjectUniqueId && (D.subject.uniqueId = d.certSubjectUniqueId), D.subject.hash = ne.digest().toHex(), d.certExtensions ? D.extensions = r.certificateExtensionsFromAsn1(d.certExtensions) : D.extensions = [], D.publicKey = r.publicKeyFromAsn1(d.subjectPublicKeyInfo), D;
  }, r.certificateExtensionsFromAsn1 = function(C) {
    for (var h = [], d = 0; d < C.value.length; ++d)
      for (var O = C.value[d], P = 0; P < O.value.length; ++P)
        h.push(r.certificateExtensionFromAsn1(O.value[P]));
    return h;
  }, r.certificateExtensionFromAsn1 = function(C) {
    var h = {};
    if (h.id = e.derToOid(C.value[0].value), h.critical = !1, C.value[1].type === e.Type.BOOLEAN ? (h.critical = C.value[1].value.charCodeAt(0) !== 0, h.value = C.value[2].value) : h.value = C.value[1].value, h.id in n) {
      if (h.name = n[h.id], h.name === "keyUsage") {
        var d = e.fromDer(h.value), O = 0, P = 0;
        d.value.length > 1 && (O = d.value.charCodeAt(1), P = d.value.length > 2 ? d.value.charCodeAt(2) : 0), h.digitalSignature = (O & 128) === 128, h.nonRepudiation = (O & 64) === 64, h.keyEncipherment = (O & 32) === 32, h.dataEncipherment = (O & 16) === 16, h.keyAgreement = (O & 8) === 8, h.keyCertSign = (O & 4) === 4, h.cRLSign = (O & 2) === 2, h.encipherOnly = (O & 1) === 1, h.decipherOnly = (P & 128) === 128;
      } else if (h.name === "basicConstraints") {
        var d = e.fromDer(h.value);
        d.value.length > 0 && d.value[0].type === e.Type.BOOLEAN ? h.cA = d.value[0].value.charCodeAt(0) !== 0 : h.cA = !1;
        var L = null;
        d.value.length > 0 && d.value[0].type === e.Type.INTEGER ? L = d.value[0].value : d.value.length > 1 && (L = d.value[1].value), L !== null && (h.pathLenConstraint = e.derToInteger(L));
      } else if (h.name === "extKeyUsage")
        for (var d = e.fromDer(h.value), D = 0; D < d.value.length; ++D) {
          var V = e.derToOid(d.value[D].value);
          V in n ? h[n[V]] = !0 : h[V] = !0;
        }
      else if (h.name === "nsCertType") {
        var d = e.fromDer(h.value), O = 0;
        d.value.length > 1 && (O = d.value.charCodeAt(1)), h.client = (O & 128) === 128, h.server = (O & 64) === 64, h.email = (O & 32) === 32, h.objsign = (O & 16) === 16, h.reserved = (O & 8) === 8, h.sslCA = (O & 4) === 4, h.emailCA = (O & 2) === 2, h.objCA = (O & 1) === 1;
      } else if (h.name === "subjectAltName" || h.name === "issuerAltName") {
        h.altNames = [];
        for (var $, d = e.fromDer(h.value), K = 0; K < d.value.length; ++K) {
          $ = d.value[K];
          var Q = {
            type: $.type,
            value: $.value
          };
          switch (h.altNames.push(Q), $.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              Q.ip = t.util.bytesToIP($.value);
              break;
            case 8:
              Q.oid = e.derToOid($.value);
              break;
          }
        }
      } else if (h.name === "subjectKeyIdentifier") {
        var d = e.fromDer(h.value);
        h.subjectKeyIdentifier = t.util.bytesToHex(d.value);
      }
    }
    return h;
  }, r.certificationRequestFromAsn1 = function(C, h) {
    var d = {}, O = [];
    if (!e.validate(C, u, d, O)) {
      var P = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
      throw P.errors = O, P;
    }
    var L = e.derToOid(d.publicKeyOid);
    if (L !== r.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.");
    var D = r.createCertificationRequest();
    if (D.version = d.csrVersion ? d.csrVersion.charCodeAt(0) : 0, D.signatureOid = t.asn1.derToOid(d.csrSignatureOid), D.signatureParameters = y(
      D.signatureOid,
      d.csrSignatureParams,
      !0
    ), D.siginfo.algorithmOid = t.asn1.derToOid(d.csrSignatureOid), D.siginfo.parameters = y(
      D.siginfo.algorithmOid,
      d.csrSignatureParams,
      !1
    ), D.signature = d.csrSignature, D.certificationRequestInfo = d.certificationRequestInfo, h) {
      D.md = m({
        signatureOid: D.signatureOid,
        type: "certification request"
      });
      var V = e.toDer(D.certificationRequestInfo);
      D.md.update(V.getBytes());
    }
    var $ = t.md.sha1.create();
    return D.subject.getField = function(K) {
      return f(D.subject, K);
    }, D.subject.addField = function(K) {
      A([K]), D.subject.attributes.push(K);
    }, D.subject.attributes = r.RDNAttributesAsArray(
      d.certificationRequestInfoSubject,
      $
    ), D.subject.hash = $.digest().toHex(), D.publicKey = r.publicKeyFromAsn1(d.subjectPublicKeyInfo), D.getAttribute = function(K) {
      return f(D, K);
    }, D.addAttribute = function(K) {
      A([K]), D.attributes.push(K);
    }, D.attributes = r.CRIAttributesAsArray(
      d.certificationRequestInfoAttributes || []
    ), D;
  }, r.createCertificationRequest = function() {
    var C = {};
    return C.version = 0, C.signatureOid = null, C.signature = null, C.siginfo = {}, C.siginfo.algorithmOid = null, C.subject = {}, C.subject.getField = function(h) {
      return f(C.subject, h);
    }, C.subject.addField = function(h) {
      A([h]), C.subject.attributes.push(h);
    }, C.subject.attributes = [], C.subject.hash = null, C.publicKey = null, C.attributes = [], C.getAttribute = function(h) {
      return f(C, h);
    }, C.addAttribute = function(h) {
      A([h]), C.attributes.push(h);
    }, C.md = null, C.setSubject = function(h) {
      A(h), C.subject.attributes = h, C.subject.hash = null;
    }, C.setAttributes = function(h) {
      A(h), C.attributes = h;
    }, C.sign = function(h, d) {
      C.md = d || t.md.sha1.create();
      var O = n[C.md.algorithm + "WithRSAEncryption"];
      if (!O) {
        var P = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        throw P.algorithm = C.md.algorithm, P;
      }
      C.signatureOid = C.siginfo.algorithmOid = O, C.certificationRequestInfo = r.getCertificationRequestInfo(C);
      var L = e.toDer(C.certificationRequestInfo);
      C.md.update(L.getBytes()), C.signature = h.sign(C.md);
    }, C.verify = function() {
      var h = !1, d = C.md;
      if (d === null) {
        d = m({
          signatureOid: C.signatureOid,
          type: "certification request"
        });
        var O = C.certificationRequestInfo || r.getCertificationRequestInfo(C), P = e.toDer(O);
        d.update(P.getBytes());
      }
      return d !== null && (h = p({
        certificate: C,
        md: d,
        signature: C.signature
      })), h;
    }, C;
  };
  function S(C) {
    for (var h = e.create(
      e.Class.UNIVERSAL,
      e.Type.SEQUENCE,
      !0,
      []
    ), d, O, P = C.attributes, L = 0; L < P.length; ++L) {
      d = P[L];
      var D = d.value, V = e.Type.PRINTABLESTRING;
      "valueTagClass" in d && (V = d.valueTagClass, V === e.Type.UTF8 && (D = t.util.encodeUtf8(D))), O = e.create(e.Class.UNIVERSAL, e.Type.SET, !0, [
        e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
          // AttributeType
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OID,
            !1,
            e.oidToDer(d.type).getBytes()
          ),
          // AttributeValue
          e.create(e.Class.UNIVERSAL, V, !1, D)
        ])
      ]), h.value.push(O);
    }
    return h;
  }
  function A(C) {
    for (var h, d = 0; d < C.length; ++d) {
      if (h = C[d], typeof h.name > "u" && (h.type && h.type in r.oids ? h.name = r.oids[h.type] : h.shortName && h.shortName in i && (h.name = r.oids[i[h.shortName]])), typeof h.type > "u")
        if (h.name && h.name in r.oids)
          h.type = r.oids[h.name];
        else {
          var O = new Error("Attribute type not specified.");
          throw O.attribute = h, O;
        }
      if (typeof h.shortName > "u" && h.name && h.name in i && (h.shortName = i[h.name]), h.type === n.extensionRequest && (h.valueConstructed = !0, h.valueTagClass = e.Type.SEQUENCE, !h.value && h.extensions)) {
        h.value = [];
        for (var P = 0; P < h.extensions.length; ++P)
          h.value.push(r.certificateExtensionToAsn1(
            I(h.extensions[P])
          ));
      }
      if (typeof h.value > "u") {
        var O = new Error("Attribute value not specified.");
        throw O.attribute = h, O;
      }
    }
  }
  function I(C, h) {
    if (h = h || {}, typeof C.name > "u" && C.id && C.id in r.oids && (C.name = r.oids[C.id]), typeof C.id > "u")
      if (C.name && C.name in r.oids)
        C.id = r.oids[C.name];
      else {
        var d = new Error("Extension ID not specified.");
        throw d.extension = C, d;
      }
    if (typeof C.value < "u")
      return C;
    if (C.name === "keyUsage") {
      var O = 0, P = 0, L = 0;
      C.digitalSignature && (P |= 128, O = 7), C.nonRepudiation && (P |= 64, O = 6), C.keyEncipherment && (P |= 32, O = 5), C.dataEncipherment && (P |= 16, O = 4), C.keyAgreement && (P |= 8, O = 3), C.keyCertSign && (P |= 4, O = 2), C.cRLSign && (P |= 2, O = 1), C.encipherOnly && (P |= 1, O = 0), C.decipherOnly && (L |= 128, O = 7);
      var D = String.fromCharCode(O);
      L !== 0 ? D += String.fromCharCode(P) + String.fromCharCode(L) : P !== 0 && (D += String.fromCharCode(P)), C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.BITSTRING,
        !1,
        D
      );
    } else if (C.name === "basicConstraints")
      C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.SEQUENCE,
        !0,
        []
      ), C.cA && C.value.value.push(e.create(
        e.Class.UNIVERSAL,
        e.Type.BOOLEAN,
        !1,
        ""
      )), "pathLenConstraint" in C && C.value.value.push(e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        e.integerToDer(C.pathLenConstraint).getBytes()
      ));
    else if (C.name === "extKeyUsage") {
      C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.SEQUENCE,
        !0,
        []
      );
      var V = C.value.value;
      for (var $ in C)
        C[$] === !0 && ($ in n ? V.push(e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(n[$]).getBytes()
        )) : $.indexOf(".") !== -1 && V.push(e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer($).getBytes()
        )));
    } else if (C.name === "nsCertType") {
      var O = 0, P = 0;
      C.client && (P |= 128, O = 7), C.server && (P |= 64, O = 6), C.email && (P |= 32, O = 5), C.objsign && (P |= 16, O = 4), C.reserved && (P |= 8, O = 3), C.sslCA && (P |= 4, O = 2), C.emailCA && (P |= 2, O = 1), C.objCA && (P |= 1, O = 0);
      var D = String.fromCharCode(O);
      P !== 0 && (D += String.fromCharCode(P)), C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.BITSTRING,
        !1,
        D
      );
    } else if (C.name === "subjectAltName" || C.name === "issuerAltName") {
      C.value = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, []);
      for (var K, Q = 0; Q < C.altNames.length; ++Q) {
        K = C.altNames[Q];
        var D = K.value;
        if (K.type === 7 && K.ip) {
          if (D = t.util.bytesFromIP(K.ip), D === null) {
            var d = new Error(
              'Extension "ip" value is not a valid IPv4 or IPv6 address.'
            );
            throw d.extension = C, d;
          }
        } else K.type === 8 && (K.oid ? D = e.oidToDer(e.oidToDer(K.oid)) : D = e.oidToDer(D));
        C.value.value.push(e.create(
          e.Class.CONTEXT_SPECIFIC,
          K.type,
          !1,
          D
        ));
      }
    } else if (C.name === "nsComment" && h.cert) {
      if (!/^[\x00-\x7F]*$/.test(C.comment) || C.comment.length < 1 || C.comment.length > 128)
        throw new Error('Invalid "nsComment" content.');
      C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.IA5STRING,
        !1,
        C.comment
      );
    } else if (C.name === "subjectKeyIdentifier" && h.cert) {
      var ee = h.cert.generateSubjectKeyIdentifier();
      C.subjectKeyIdentifier = ee.toHex(), C.value = e.create(
        e.Class.UNIVERSAL,
        e.Type.OCTETSTRING,
        !1,
        ee.getBytes()
      );
    } else if (C.name === "authorityKeyIdentifier" && h.cert) {
      C.value = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, []);
      var V = C.value.value;
      if (C.keyIdentifier) {
        var ne = C.keyIdentifier === !0 ? h.cert.generateSubjectKeyIdentifier().getBytes() : C.keyIdentifier;
        V.push(
          e.create(e.Class.CONTEXT_SPECIFIC, 0, !1, ne)
        );
      }
      if (C.authorityCertIssuer) {
        var ae = [
          e.create(e.Class.CONTEXT_SPECIFIC, 4, !0, [
            S(C.authorityCertIssuer === !0 ? h.cert.issuer : C.authorityCertIssuer)
          ])
        ];
        V.push(
          e.create(e.Class.CONTEXT_SPECIFIC, 1, !0, ae)
        );
      }
      if (C.serialNumber) {
        var se = t.util.hexToBytes(C.serialNumber === !0 ? h.cert.serialNumber : C.serialNumber);
        V.push(
          e.create(e.Class.CONTEXT_SPECIFIC, 2, !1, se)
        );
      }
    } else if (C.name === "cRLDistributionPoints") {
      C.value = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, []);
      for (var V = C.value.value, me = e.create(
        e.Class.UNIVERSAL,
        e.Type.SEQUENCE,
        !0,
        []
      ), ye = e.create(
        e.Class.CONTEXT_SPECIFIC,
        0,
        !0,
        []
      ), K, Q = 0; Q < C.altNames.length; ++Q) {
        K = C.altNames[Q];
        var D = K.value;
        if (K.type === 7 && K.ip) {
          if (D = t.util.bytesFromIP(K.ip), D === null) {
            var d = new Error(
              'Extension "ip" value is not a valid IPv4 or IPv6 address.'
            );
            throw d.extension = C, d;
          }
        } else K.type === 8 && (K.oid ? D = e.oidToDer(e.oidToDer(K.oid)) : D = e.oidToDer(D));
        ye.value.push(e.create(
          e.Class.CONTEXT_SPECIFIC,
          K.type,
          !1,
          D
        ));
      }
      me.value.push(e.create(
        e.Class.CONTEXT_SPECIFIC,
        0,
        !0,
        [ye]
      )), V.push(me);
    }
    if (typeof C.value > "u") {
      var d = new Error("Extension value not specified.");
      throw d.extension = C, d;
    }
    return C;
  }
  function c(C, h) {
    switch (C) {
      case n["RSASSA-PSS"]:
        var d = [];
        return h.hash.algorithmOid !== void 0 && d.push(e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(h.hash.algorithmOid).getBytes()
            ),
            e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
          ])
        ])), h.mgf.algorithmOid !== void 0 && d.push(e.create(e.Class.CONTEXT_SPECIFIC, 1, !0, [
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(h.mgf.algorithmOid).getBytes()
            ),
            e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
              e.create(
                e.Class.UNIVERSAL,
                e.Type.OID,
                !1,
                e.oidToDer(h.mgf.hash.algorithmOid).getBytes()
              ),
              e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
            ])
          ])
        ])), h.saltLength !== void 0 && d.push(e.create(e.Class.CONTEXT_SPECIFIC, 2, !0, [
          e.create(
            e.Class.UNIVERSAL,
            e.Type.INTEGER,
            !1,
            e.integerToDer(h.saltLength).getBytes()
          )
        ])), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, d);
      default:
        return e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "");
    }
  }
  function E(C) {
    var h = e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, []);
    if (C.attributes.length === 0)
      return h;
    for (var d = C.attributes, O = 0; O < d.length; ++O) {
      var P = d[O], L = P.value, D = e.Type.UTF8;
      "valueTagClass" in P && (D = P.valueTagClass), D === e.Type.UTF8 && (L = t.util.encodeUtf8(L));
      var V = !1;
      "valueConstructed" in P && (V = P.valueConstructed);
      var $ = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // AttributeType
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(P.type).getBytes()
        ),
        e.create(e.Class.UNIVERSAL, e.Type.SET, !0, [
          // AttributeValue
          e.create(
            e.Class.UNIVERSAL,
            D,
            V,
            L
          )
        ])
      ]);
      h.value.push($);
    }
    return h;
  }
  var v = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), R = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
  function N(C) {
    return C >= v && C < R ? e.create(
      e.Class.UNIVERSAL,
      e.Type.UTCTIME,
      !1,
      e.dateToUtcTime(C)
    ) : e.create(
      e.Class.UNIVERSAL,
      e.Type.GENERALIZEDTIME,
      !1,
      e.dateToGeneralizedTime(C)
    );
  }
  return r.getTBSCertificate = function(C) {
    var h = N(C.validity.notBefore), d = N(C.validity.notAfter), O = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // version
      e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
        // integer
        e.create(
          e.Class.UNIVERSAL,
          e.Type.INTEGER,
          !1,
          e.integerToDer(C.version).getBytes()
        )
      ]),
      // serialNumber
      e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        t.util.hexToBytes(C.serialNumber)
      ),
      // signature
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(C.siginfo.algorithmOid).getBytes()
        ),
        // parameters
        c(
          C.siginfo.algorithmOid,
          C.siginfo.parameters
        )
      ]),
      // issuer
      S(C.issuer),
      // validity
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        h,
        d
      ]),
      // subject
      S(C.subject),
      // SubjectPublicKeyInfo
      r.publicKeyToAsn1(C.publicKey)
    ]);
    return C.issuer.uniqueId && O.value.push(
      e.create(e.Class.CONTEXT_SPECIFIC, 1, !0, [
        e.create(
          e.Class.UNIVERSAL,
          e.Type.BITSTRING,
          !1,
          // TODO: support arbitrary bit length ids
          "\0" + C.issuer.uniqueId
        )
      ])
    ), C.subject.uniqueId && O.value.push(
      e.create(e.Class.CONTEXT_SPECIFIC, 2, !0, [
        e.create(
          e.Class.UNIVERSAL,
          e.Type.BITSTRING,
          !1,
          // TODO: support arbitrary bit length ids
          "\0" + C.subject.uniqueId
        )
      ])
    ), C.extensions.length > 0 && O.value.push(r.certificateExtensionsToAsn1(C.extensions)), O;
  }, r.getCertificationRequestInfo = function(C) {
    var h = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // version
      e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        e.integerToDer(C.version).getBytes()
      ),
      // subject
      S(C.subject),
      // SubjectPublicKeyInfo
      r.publicKeyToAsn1(C.publicKey),
      // attributes
      E(C)
    ]);
    return h;
  }, r.distinguishedNameToAsn1 = function(C) {
    return S(C);
  }, r.certificateToAsn1 = function(C) {
    var h = C.tbsCertificate || r.getTBSCertificate(C);
    return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // TBSCertificate
      h,
      // AlgorithmIdentifier (signature algorithm)
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(C.signatureOid).getBytes()
        ),
        // parameters
        c(C.signatureOid, C.signatureParameters)
      ]),
      // SignatureValue
      e.create(
        e.Class.UNIVERSAL,
        e.Type.BITSTRING,
        !1,
        "\0" + C.signature
      )
    ]);
  }, r.certificateExtensionsToAsn1 = function(C) {
    var h = e.create(e.Class.CONTEXT_SPECIFIC, 3, !0, []), d = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, []);
    h.value.push(d);
    for (var O = 0; O < C.length; ++O)
      d.value.push(r.certificateExtensionToAsn1(C[O]));
    return h;
  }, r.certificateExtensionToAsn1 = function(C) {
    var h = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, []);
    h.value.push(e.create(
      e.Class.UNIVERSAL,
      e.Type.OID,
      !1,
      e.oidToDer(C.id).getBytes()
    )), C.critical && h.value.push(e.create(
      e.Class.UNIVERSAL,
      e.Type.BOOLEAN,
      !1,
      ""
    ));
    var d = C.value;
    return typeof C.value != "string" && (d = e.toDer(d).getBytes()), h.value.push(e.create(
      e.Class.UNIVERSAL,
      e.Type.OCTETSTRING,
      !1,
      d
    )), h;
  }, r.certificationRequestToAsn1 = function(C) {
    var h = C.certificationRequestInfo || r.getCertificationRequestInfo(C);
    return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // CertificationRequestInfo
      h,
      // AlgorithmIdentifier (signature algorithm)
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(C.signatureOid).getBytes()
        ),
        // parameters
        c(C.signatureOid, C.signatureParameters)
      ]),
      // signature
      e.create(
        e.Class.UNIVERSAL,
        e.Type.BITSTRING,
        !1,
        "\0" + C.signature
      )
    ]);
  }, r.createCaStore = function(C) {
    var h = {
      // stored certificates
      certs: {}
    };
    h.getIssuer = function(D) {
      var V = d(D.issuer);
      return V;
    }, h.addCertificate = function(D) {
      if (typeof D == "string" && (D = t.pki.certificateFromPem(D)), O(D.subject), !h.hasCertificate(D))
        if (D.subject.hash in h.certs) {
          var V = h.certs[D.subject.hash];
          t.util.isArray(V) || (V = [V]), V.push(D), h.certs[D.subject.hash] = V;
        } else
          h.certs[D.subject.hash] = D;
    }, h.hasCertificate = function(D) {
      typeof D == "string" && (D = t.pki.certificateFromPem(D));
      var V = d(D.subject);
      if (!V)
        return !1;
      t.util.isArray(V) || (V = [V]);
      for (var $ = e.toDer(r.certificateToAsn1(D)).getBytes(), K = 0; K < V.length; ++K) {
        var Q = e.toDer(r.certificateToAsn1(V[K])).getBytes();
        if ($ === Q)
          return !0;
      }
      return !1;
    }, h.listAllCertificates = function() {
      var D = [];
      for (var V in h.certs)
        if (h.certs.hasOwnProperty(V)) {
          var $ = h.certs[V];
          if (!t.util.isArray($))
            D.push($);
          else
            for (var K = 0; K < $.length; ++K)
              D.push($[K]);
        }
      return D;
    }, h.removeCertificate = function(D) {
      var V;
      if (typeof D == "string" && (D = t.pki.certificateFromPem(D)), O(D.subject), !h.hasCertificate(D))
        return null;
      var $ = d(D.subject);
      if (!t.util.isArray($))
        return V = h.certs[D.subject.hash], delete h.certs[D.subject.hash], V;
      for (var K = e.toDer(r.certificateToAsn1(D)).getBytes(), Q = 0; Q < $.length; ++Q) {
        var ee = e.toDer(r.certificateToAsn1($[Q])).getBytes();
        K === ee && (V = $[Q], $.splice(Q, 1));
      }
      return $.length === 0 && delete h.certs[D.subject.hash], V;
    };
    function d(D) {
      return O(D), h.certs[D.hash] || null;
    }
    function O(D) {
      if (!D.hash) {
        var V = t.md.sha1.create();
        D.attributes = r.RDNAttributesAsArray(S(D), V), D.hash = V.digest().toHex();
      }
    }
    if (C)
      for (var P = 0; P < C.length; ++P) {
        var L = C[P];
        h.addCertificate(L);
      }
    return h;
  }, r.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority"
  }, r.verifyCertificateChain = function(C, h, d) {
    typeof d == "function" && (d = { verify: d }), d = d || {}, h = h.slice(0);
    var O = h.slice(0), P = d.validityCheckDate;
    typeof P > "u" && (P = /* @__PURE__ */ new Date());
    var L = !0, D = null, V = 0;
    do {
      var $ = h.shift(), K = null, Q = !1;
      if (P && (P < $.validity.notBefore || P > $.validity.notAfter) && (D = {
        message: "Certificate is not valid yet or has expired.",
        error: r.certificateError.certificate_expired,
        notBefore: $.validity.notBefore,
        notAfter: $.validity.notAfter,
        // TODO: we might want to reconsider renaming 'now' to
        // 'validityCheckDate' should this API be changed in the future.
        now: P
      }), D === null) {
        if (K = h[0] || C.getIssuer($), K === null && $.isIssuer($) && (Q = !0, K = $), K) {
          var ee = K;
          t.util.isArray(ee) || (ee = [ee]);
          for (var ne = !1; !ne && ee.length > 0; ) {
            K = ee.shift();
            try {
              ne = K.verify($);
            } catch {
            }
          }
          ne || (D = {
            message: "Certificate signature is invalid.",
            error: r.certificateError.bad_certificate
          });
        }
        D === null && (!K || Q) && !C.hasCertificate($) && (D = {
          message: "Certificate is not trusted.",
          error: r.certificateError.unknown_ca
        });
      }
      if (D === null && K && !$.isIssuer(K) && (D = {
        message: "Certificate issuer is invalid.",
        error: r.certificateError.bad_certificate
      }), D === null)
        for (var ae = {
          keyUsage: !0,
          basicConstraints: !0
        }, se = 0; D === null && se < $.extensions.length; ++se) {
          var me = $.extensions[se];
          me.critical && !(me.name in ae) && (D = {
            message: "Certificate has an unsupported critical extension.",
            error: r.certificateError.unsupported_certificate
          });
        }
      if (D === null && (!L || h.length === 0 && (!K || Q))) {
        var ye = $.getExtension("basicConstraints"), Se = $.getExtension("keyUsage");
        if (Se !== null && (!Se.keyCertSign || ye === null) && (D = {
          message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
          error: r.certificateError.bad_certificate
        }), D === null && ye !== null && !ye.cA && (D = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: r.certificateError.bad_certificate
        }), D === null && Se !== null && "pathLenConstraint" in ye) {
          var te = V - 1;
          te > ye.pathLenConstraint && (D = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: r.certificateError.bad_certificate
          });
        }
      }
      var Ce = D === null ? !0 : D.error, fe = d.verify ? d.verify(Ce, V, O) : Ce;
      if (fe === !0)
        D = null;
      else
        throw Ce === !0 && (D = {
          message: "The application rejected the certificate.",
          error: r.certificateError.bad_certificate
        }), (fe || fe === 0) && (typeof fe == "object" && !t.util.isArray(fe) ? (fe.message && (D.message = fe.message), fe.error && (D.error = fe.error)) : typeof fe == "string" && (D.error = fe)), D;
      L = !1, ++V;
    } while (h.length > 0);
    return !0;
  }, mu.exports;
}
var lp;
function wy() {
  if (lp) return gu.exports;
  lp = 1;
  var t = Pe();
  Wr(), Oa(), ii(), Iy(), Sy(), Pr(), Bo(), Da(), $e(), Nf();
  var e = t.asn1, r = t.pki, n = gu.exports = t.pkcs12 = t.pkcs12 || {}, i = {
    name: "ContentInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    // a ContentInfo
    constructed: !0,
    value: [{
      name: "ContentInfo.contentType",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      constructed: !0,
      captureAsn1: "content"
    }]
  }, a = {
    name: "PFX",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: "PFX.version",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.INTEGER,
        constructed: !1,
        capture: "version"
      },
      i,
      {
        name: "PFX.macData",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        captureAsn1: "mac",
        value: [{
          name: "PFX.macData.mac",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.SEQUENCE,
          // DigestInfo
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.SEQUENCE,
            // DigestAlgorithmIdentifier
            constructed: !0,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm.algorithm",
              tagClass: e.Class.UNIVERSAL,
              type: e.Type.OID,
              constructed: !1,
              capture: "macAlgorithm"
            }, {
              name: "PFX.macData.mac.digestAlgorithm.parameters",
              tagClass: e.Class.UNIVERSAL,
              captureAsn1: "macAlgorithmParameters"
            }]
          }, {
            name: "PFX.macData.mac.digest",
            tagClass: e.Class.UNIVERSAL,
            type: e.Type.OCTETSTRING,
            constructed: !1,
            capture: "macDigest"
          }]
        }, {
          name: "PFX.macData.macSalt",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.OCTETSTRING,
          constructed: !1,
          capture: "macSalt"
        }, {
          name: "PFX.macData.iterations",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.INTEGER,
          constructed: !1,
          optional: !0,
          capture: "macIterations"
        }]
      }
    ]
  }, s = {
    name: "SafeBag",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SafeBag.bagId",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "bagId"
    }, {
      name: "SafeBag.bagValue",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      constructed: !0,
      captureAsn1: "bagValue"
    }, {
      name: "SafeBag.bagAttributes",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SET,
      constructed: !0,
      optional: !0,
      capture: "bagAttributes"
    }]
  }, o = {
    name: "Attribute",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "Attribute.attrId",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "oid"
    }, {
      name: "Attribute.attrValues",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SET,
      constructed: !0,
      capture: "values"
    }]
  }, l = {
    name: "CertBag",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "CertBag.certId",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OID,
      constructed: !1,
      capture: "certId"
    }, {
      name: "CertBag.certValue",
      tagClass: e.Class.CONTEXT_SPECIFIC,
      constructed: !0,
      /* So far we only support X.509 certificates (which are wrapped in
         an OCTET STRING, hence hard code that here). */
      value: [{
        name: "CertBag.certValue[0]",
        tagClass: e.Class.UNIVERSAL,
        type: e.Class.OCTETSTRING,
        constructed: !1,
        capture: "cert"
      }]
    }]
  };
  function u(A, I, c, E) {
    for (var v = [], R = 0; R < A.length; R++)
      for (var N = 0; N < A[R].safeBags.length; N++) {
        var C = A[R].safeBags[N];
        if (!(E !== void 0 && C.type !== E)) {
          if (I === null) {
            v.push(C);
            continue;
          }
          C.attributes[I] !== void 0 && C.attributes[I].indexOf(c) >= 0 && v.push(C);
        }
      }
    return v;
  }
  n.pkcs12FromAsn1 = function(A, I, c) {
    typeof I == "string" ? (c = I, I = !0) : I === void 0 && (I = !0);
    var E = {}, v = [];
    if (!e.validate(A, a, E, v)) {
      var R = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
      throw R.errors = R, R;
    }
    var N = {
      version: E.version.charCodeAt(0),
      safeContents: [],
      /**
       * Gets bags with matching attributes.
       *
       * @param filter the attributes to filter by:
       *          [localKeyId] the localKeyId to search for.
       *          [localKeyIdHex] the localKeyId in hex to search for.
       *          [friendlyName] the friendly name to search for.
       *          [bagType] bag type to narrow each attribute search by.
       *
       * @return a map of attribute type to an array of matching bags or, if no
       *           attribute was given but a bag type, the map key will be the
       *           bag type.
       */
      getBags: function(K) {
        var Q = {}, ee;
        return "localKeyId" in K ? ee = K.localKeyId : "localKeyIdHex" in K && (ee = t.util.hexToBytes(K.localKeyIdHex)), ee === void 0 && !("friendlyName" in K) && "bagType" in K && (Q[K.bagType] = u(
          N.safeContents,
          null,
          null,
          K.bagType
        )), ee !== void 0 && (Q.localKeyId = u(
          N.safeContents,
          "localKeyId",
          ee,
          K.bagType
        )), "friendlyName" in K && (Q.friendlyName = u(
          N.safeContents,
          "friendlyName",
          K.friendlyName,
          K.bagType
        )), Q;
      },
      /**
       * DEPRECATED: use getBags() instead.
       *
       * Get bags with matching friendlyName attribute.
       *
       * @param friendlyName the friendly name to search for.
       * @param [bagType] bag type to narrow search by.
       *
       * @return an array of bags with matching friendlyName attribute.
       */
      getBagsByFriendlyName: function(K, Q) {
        return u(
          N.safeContents,
          "friendlyName",
          K,
          Q
        );
      },
      /**
       * DEPRECATED: use getBags() instead.
       *
       * Get bags with matching localKeyId attribute.
       *
       * @param localKeyId the localKeyId to search for.
       * @param [bagType] bag type to narrow search by.
       *
       * @return an array of bags with matching localKeyId attribute.
       */
      getBagsByLocalKeyId: function(K, Q) {
        return u(
          N.safeContents,
          "localKeyId",
          K,
          Q
        );
      }
    };
    if (E.version.charCodeAt(0) !== 3) {
      var R = new Error("PKCS#12 PFX of version other than 3 not supported.");
      throw R.version = E.version.charCodeAt(0), R;
    }
    if (e.derToOid(E.contentType) !== r.oids.data) {
      var R = new Error("Only PKCS#12 PFX in password integrity mode supported.");
      throw R.oid = e.derToOid(E.contentType), R;
    }
    var C = E.content.value[0];
    if (C.tagClass !== e.Class.UNIVERSAL || C.type !== e.Type.OCTETSTRING)
      throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
    if (C = f(C), E.mac) {
      var h = null, d = 0, O = e.derToOid(E.macAlgorithm);
      switch (O) {
        case r.oids.sha1:
          h = t.md.sha1.create(), d = 20;
          break;
        case r.oids.sha256:
          h = t.md.sha256.create(), d = 32;
          break;
        case r.oids.sha384:
          h = t.md.sha384.create(), d = 48;
          break;
        case r.oids.sha512:
          h = t.md.sha512.create(), d = 64;
          break;
        case r.oids.md5:
          h = t.md.md5.create(), d = 16;
          break;
      }
      if (h === null)
        throw new Error("PKCS#12 uses unsupported MAC algorithm: " + O);
      var P = new t.util.ByteBuffer(E.macSalt), L = "macIterations" in E ? parseInt(t.util.bytesToHex(E.macIterations), 16) : 1, D = n.generateKey(
        c,
        P,
        3,
        L,
        d,
        h
      ), V = t.hmac.create();
      V.start(h, D), V.update(C.value);
      var $ = V.getMac();
      if ($.getBytes() !== E.macDigest)
        throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
    return y(N, C.value, I, c), N;
  };
  function f(A) {
    if (A.composed || A.constructed) {
      for (var I = t.util.createBuffer(), c = 0; c < A.value.length; ++c)
        I.putBytes(A.value[c].value);
      A.composed = A.constructed = !1, A.value = I.getBytes();
    }
    return A;
  }
  function y(A, I, c, E) {
    if (I = e.fromDer(I, c), I.tagClass !== e.Class.UNIVERSAL || I.type !== e.Type.SEQUENCE || I.constructed !== !0)
      throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
    for (var v = 0; v < I.value.length; v++) {
      var R = I.value[v], N = {}, C = [];
      if (!e.validate(R, i, N, C)) {
        var h = new Error("Cannot read ContentInfo.");
        throw h.errors = C, h;
      }
      var d = {
        encrypted: !1
      }, O = null, P = N.content.value[0];
      switch (e.derToOid(N.contentType)) {
        case r.oids.data:
          if (P.tagClass !== e.Class.UNIVERSAL || P.type !== e.Type.OCTETSTRING)
            throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
          O = f(P).value;
          break;
        case r.oids.encryptedData:
          O = m(P, E), d.encrypted = !0;
          break;
        default:
          var h = new Error("Unsupported PKCS#12 contentType.");
          throw h.contentType = e.derToOid(N.contentType), h;
      }
      d.safeBags = p(O, c, E), A.safeContents.push(d);
    }
  }
  function m(A, I) {
    var c = {}, E = [];
    if (!e.validate(
      A,
      t.pkcs7.asn1.encryptedDataValidator,
      c,
      E
    )) {
      var v = new Error("Cannot read EncryptedContentInfo.");
      throw v.errors = E, v;
    }
    var R = e.derToOid(c.contentType);
    if (R !== r.oids.data) {
      var v = new Error(
        "PKCS#12 EncryptedContentInfo ContentType is not Data."
      );
      throw v.oid = R, v;
    }
    R = e.derToOid(c.encAlgorithm);
    var N = r.pbe.getCipher(R, c.encParameter, I), C = f(c.encryptedContentAsn1), h = t.util.createBuffer(C.value);
    if (N.update(h), !N.finish())
      throw new Error("Failed to decrypt PKCS#12 SafeContents.");
    return N.output.getBytes();
  }
  function p(A, I, c) {
    if (!I && A.length === 0)
      return [];
    if (A = e.fromDer(A, I), A.tagClass !== e.Class.UNIVERSAL || A.type !== e.Type.SEQUENCE || A.constructed !== !0)
      throw new Error(
        "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
      );
    for (var E = [], v = 0; v < A.value.length; v++) {
      var R = A.value[v], N = {}, C = [];
      if (!e.validate(R, s, N, C)) {
        var h = new Error("Cannot read SafeBag.");
        throw h.errors = C, h;
      }
      var d = {
        type: e.derToOid(N.bagId),
        attributes: S(N.bagAttributes)
      };
      E.push(d);
      var O, P, L = N.bagValue.value[0];
      switch (d.type) {
        case r.oids.pkcs8ShroudedKeyBag:
          if (L = r.decryptPrivateKeyInfo(L, c), L === null)
            throw new Error(
              "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
            );
        case r.oids.keyBag:
          try {
            d.key = r.privateKeyFromAsn1(L);
          } catch {
            d.key = null, d.asn1 = L;
          }
          continue;
        case r.oids.certBag:
          O = l, P = function() {
            if (e.derToOid(N.certId) !== r.oids.x509Certificate) {
              var V = new Error(
                "Unsupported certificate type, only X.509 supported."
              );
              throw V.oid = e.derToOid(N.certId), V;
            }
            var $ = e.fromDer(N.cert, I);
            try {
              d.cert = r.certificateFromAsn1($, !0);
            } catch {
              d.cert = null, d.asn1 = $;
            }
          };
          break;
        default:
          var h = new Error("Unsupported PKCS#12 SafeBag type.");
          throw h.oid = d.type, h;
      }
      if (O !== void 0 && !e.validate(L, O, N, C)) {
        var h = new Error("Cannot read PKCS#12 " + O.name);
        throw h.errors = C, h;
      }
      P();
    }
    return E;
  }
  function S(A) {
    var I = {};
    if (A !== void 0)
      for (var c = 0; c < A.length; ++c) {
        var E = {}, v = [];
        if (!e.validate(A[c], o, E, v)) {
          var R = new Error("Cannot read PKCS#12 BagAttribute.");
          throw R.errors = v, R;
        }
        var N = e.derToOid(E.oid);
        if (r.oids[N] !== void 0) {
          I[r.oids[N]] = [];
          for (var C = 0; C < E.values.length; ++C)
            I[r.oids[N]].push(E.values[C].value);
        }
      }
    return I;
  }
  return n.toPkcs12Asn1 = function(A, I, c, E) {
    E = E || {}, E.saltSize = E.saltSize || 8, E.count = E.count || 2048, E.algorithm = E.algorithm || E.encAlgorithm || "aes128", "useMac" in E || (E.useMac = !0), "localKeyId" in E || (E.localKeyId = null), "generateLocalKeyId" in E || (E.generateLocalKeyId = !0);
    var v = E.localKeyId, R;
    if (v !== null)
      v = t.util.hexToBytes(v);
    else if (E.generateLocalKeyId)
      if (I) {
        var N = t.util.isArray(I) ? I[0] : I;
        typeof N == "string" && (N = r.certificateFromPem(N));
        var C = t.md.sha1.create();
        C.update(e.toDer(r.certificateToAsn1(N)).getBytes()), v = C.digest().getBytes();
      } else
        v = t.random.getBytes(20);
    var h = [];
    v !== null && h.push(
      // localKeyID
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // attrId
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(r.oids.localKeyId).getBytes()
        ),
        // attrValues
        e.create(e.Class.UNIVERSAL, e.Type.SET, !0, [
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OCTETSTRING,
            !1,
            v
          )
        ])
      ])
    ), "friendlyName" in E && h.push(
      // friendlyName
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // attrId
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(r.oids.friendlyName).getBytes()
        ),
        // attrValues
        e.create(e.Class.UNIVERSAL, e.Type.SET, !0, [
          e.create(
            e.Class.UNIVERSAL,
            e.Type.BMPSTRING,
            !1,
            E.friendlyName
          )
        ])
      ])
    ), h.length > 0 && (R = e.create(e.Class.UNIVERSAL, e.Type.SET, !0, h));
    var d = [], O = [];
    I !== null && (t.util.isArray(I) ? O = I : O = [I]);
    for (var P = [], L = 0; L < O.length; ++L) {
      I = O[L], typeof I == "string" && (I = r.certificateFromPem(I));
      var D = L === 0 ? R : void 0, V = r.certificateToAsn1(I), $ = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // bagId
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(r.oids.certBag).getBytes()
        ),
        // bagValue
        e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          // CertBag
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            // certId
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(r.oids.x509Certificate).getBytes()
            ),
            // certValue (x509Certificate)
            e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
              e.create(
                e.Class.UNIVERSAL,
                e.Type.OCTETSTRING,
                !1,
                e.toDer(V).getBytes()
              )
            ])
          ])
        ]),
        // bagAttributes (OPTIONAL)
        D
      ]);
      P.push($);
    }
    if (P.length > 0) {
      var K = e.create(
        e.Class.UNIVERSAL,
        e.Type.SEQUENCE,
        !0,
        P
      ), Q = (
        // PKCS#7 ContentInfo
        e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
          // contentType
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OID,
            !1,
            // OID for the content type is 'data'
            e.oidToDer(r.oids.data).getBytes()
          ),
          // content
          e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OCTETSTRING,
              !1,
              e.toDer(K).getBytes()
            )
          ])
        ])
      );
      d.push(Q);
    }
    var ee = null;
    if (A !== null) {
      var ne = r.wrapRsaPrivateKey(r.privateKeyToAsn1(A));
      c === null ? ee = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // bagId
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(r.oids.keyBag).getBytes()
        ),
        // bagValue
        e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          // PrivateKeyInfo
          ne
        ]),
        // bagAttributes (OPTIONAL)
        R
      ]) : ee = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // bagId
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(r.oids.pkcs8ShroudedKeyBag).getBytes()
        ),
        // bagValue
        e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          // EncryptedPrivateKeyInfo
          r.encryptPrivateKeyInfo(ne, c, E)
        ]),
        // bagAttributes (OPTIONAL)
        R
      ]);
      var ae = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [ee]), se = (
        // PKCS#7 ContentInfo
        e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
          // contentType
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OID,
            !1,
            // OID for the content type is 'data'
            e.oidToDer(r.oids.data).getBytes()
          ),
          // content
          e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OCTETSTRING,
              !1,
              e.toDer(ae).getBytes()
            )
          ])
        ])
      );
      d.push(se);
    }
    var me = e.create(
      e.Class.UNIVERSAL,
      e.Type.SEQUENCE,
      !0,
      d
    ), ye;
    if (E.useMac) {
      var C = t.md.sha1.create(), Se = new t.util.ByteBuffer(
        t.random.getBytes(E.saltSize)
      ), te = E.count, A = n.generateKey(c, Se, 3, te, 20), Ce = t.hmac.create();
      Ce.start(C, A), Ce.update(e.toDer(me).getBytes());
      var fe = Ce.getMac();
      ye = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // mac DigestInfo
        e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
          // digestAlgorithm
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            // algorithm = SHA-1
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(r.oids.sha1).getBytes()
            ),
            // parameters = Null
            e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
          ]),
          // digest
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OCTETSTRING,
            !1,
            fe.getBytes()
          )
        ]),
        // macSalt OCTET STRING
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OCTETSTRING,
          !1,
          Se.getBytes()
        ),
        // iterations INTEGER (XXX: Only support count < 65536)
        e.create(
          e.Class.UNIVERSAL,
          e.Type.INTEGER,
          !1,
          e.integerToDer(te).getBytes()
        )
      ]);
    }
    return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // version (3)
      e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        e.integerToDer(3).getBytes()
      ),
      // PKCS#7 ContentInfo
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // contentType
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          // OID for the content type is 'data'
          e.oidToDer(r.oids.data).getBytes()
        ),
        // content
        e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OCTETSTRING,
            !1,
            e.toDer(me).getBytes()
          )
        ])
      ]),
      ye
    ]);
  }, n.generateKey = t.pbe.generatePkcs12Key, gu.exports;
}
var fp;
function Ty() {
  if (fp) return iu.exports;
  fp = 1;
  var t = Pe();
  Wr(), ii(), Sy(), Vi(), Tf(), wy(), Rf(), Bo(), $e(), Nf();
  var e = t.asn1, r = iu.exports = t.pki = t.pki || {};
  return r.pemToDer = function(n) {
    var i = t.pem.decode(n)[0];
    if (i.procType && i.procType.type === "ENCRYPTED")
      throw new Error("Could not convert PEM to DER; PEM is encrypted.");
    return t.util.createBuffer(i.body);
  }, r.privateKeyFromPem = function(n) {
    var i = t.pem.decode(n)[0];
    if (i.type !== "PRIVATE KEY" && i.type !== "RSA PRIVATE KEY") {
      var a = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
      throw a.headerType = i.type, a;
    }
    if (i.procType && i.procType.type === "ENCRYPTED")
      throw new Error("Could not convert private key from PEM; PEM is encrypted.");
    var s = e.fromDer(i.body);
    return r.privateKeyFromAsn1(s);
  }, r.privateKeyToPem = function(n, i) {
    var a = {
      type: "RSA PRIVATE KEY",
      body: e.toDer(r.privateKeyToAsn1(n)).getBytes()
    };
    return t.pem.encode(a, { maxline: i });
  }, r.privateKeyInfoToPem = function(n, i) {
    var a = {
      type: "PRIVATE KEY",
      body: e.toDer(n).getBytes()
    };
    return t.pem.encode(a, { maxline: i });
  }, iu.exports;
}
var Cu, dp;
function Ry() {
  if (dp) return Cu;
  dp = 1;
  var t = Pe();
  Wr(), Oa(), wf(), Vi(), Ty(), Pr(), Da(), $e();
  var e = function(w, b, T, g) {
    var x = t.util.createBuffer(), U = w.length >> 1, k = U + (w.length & 1), W = w.substr(0, k), q = w.substr(U, k), z = t.util.createBuffer(), j = t.hmac.create();
    T = b + T;
    var Y = Math.ceil(g / 16), M = Math.ceil(g / 20);
    j.start("MD5", W);
    var X = t.util.createBuffer();
    z.putBytes(T);
    for (var J = 0; J < Y; ++J)
      j.start(null, null), j.update(z.getBytes()), z.putBuffer(j.digest()), j.start(null, null), j.update(z.bytes() + T), X.putBuffer(j.digest());
    j.start("SHA1", q);
    var Z = t.util.createBuffer();
    z.clear(), z.putBytes(T);
    for (var J = 0; J < M; ++J)
      j.start(null, null), j.update(z.getBytes()), z.putBuffer(j.digest()), j.start(null, null), j.update(z.bytes() + T), Z.putBuffer(j.digest());
    return x.putBytes(t.util.xorBytes(
      X.getBytes(),
      Z.getBytes(),
      g
    )), x;
  }, r = function(w, b, T) {
    var g = t.hmac.create();
    g.start("SHA1", w);
    var x = t.util.createBuffer();
    return x.putInt32(b[0]), x.putInt32(b[1]), x.putByte(T.type), x.putByte(T.version.major), x.putByte(T.version.minor), x.putInt16(T.length), x.putBytes(T.fragment.bytes()), g.update(x.getBytes()), g.digest().getBytes();
  }, n = function(w, b, T) {
    var g = !1;
    try {
      var x = w.deflate(b.fragment.getBytes());
      b.fragment = t.util.createBuffer(x), b.length = x.length, g = !0;
    } catch {
    }
    return g;
  }, i = function(w, b, T) {
    var g = !1;
    try {
      var x = w.inflate(b.fragment.getBytes());
      b.fragment = t.util.createBuffer(x), b.length = x.length, g = !0;
    } catch {
    }
    return g;
  }, a = function(w, b) {
    var T = 0;
    switch (b) {
      case 1:
        T = w.getByte();
        break;
      case 2:
        T = w.getInt16();
        break;
      case 3:
        T = w.getInt24();
        break;
      case 4:
        T = w.getInt32();
        break;
    }
    return t.util.createBuffer(w.getBytes(T));
  }, s = function(w, b, T) {
    w.putInt(T.length(), b << 3), w.putBuffer(T);
  }, o = {};
  o.Versions = {
    TLS_1_0: { major: 3, minor: 1 },
    TLS_1_1: { major: 3, minor: 2 },
    TLS_1_2: { major: 3, minor: 3 }
  }, o.SupportedVersions = [
    o.Versions.TLS_1_1,
    o.Versions.TLS_1_0
  ], o.Version = o.SupportedVersions[0], o.MaxFragment = 15360, o.ConnectionEnd = {
    server: 0,
    client: 1
  }, o.PRFAlgorithm = {
    tls_prf_sha256: 0
  }, o.BulkCipherAlgorithm = {
    none: null,
    rc4: 0,
    des3: 1,
    aes: 2
  }, o.CipherType = {
    stream: 0,
    block: 1,
    aead: 2
  }, o.MACAlgorithm = {
    none: null,
    hmac_md5: 0,
    hmac_sha1: 1,
    hmac_sha256: 2,
    hmac_sha384: 3,
    hmac_sha512: 4
  }, o.CompressionMethod = {
    none: 0,
    deflate: 1
  }, o.ContentType = {
    change_cipher_spec: 20,
    alert: 21,
    handshake: 22,
    application_data: 23,
    heartbeat: 24
  }, o.HandshakeType = {
    hello_request: 0,
    client_hello: 1,
    server_hello: 2,
    certificate: 11,
    server_key_exchange: 12,
    certificate_request: 13,
    server_hello_done: 14,
    certificate_verify: 15,
    client_key_exchange: 16,
    finished: 20
  }, o.Alert = {}, o.Alert.Level = {
    warning: 1,
    fatal: 2
  }, o.Alert.Description = {
    close_notify: 0,
    unexpected_message: 10,
    bad_record_mac: 20,
    decryption_failed: 21,
    record_overflow: 22,
    decompression_failure: 30,
    handshake_failure: 40,
    bad_certificate: 42,
    unsupported_certificate: 43,
    certificate_revoked: 44,
    certificate_expired: 45,
    certificate_unknown: 46,
    illegal_parameter: 47,
    unknown_ca: 48,
    access_denied: 49,
    decode_error: 50,
    decrypt_error: 51,
    export_restriction: 60,
    protocol_version: 70,
    insufficient_security: 71,
    internal_error: 80,
    user_canceled: 90,
    no_renegotiation: 100
  }, o.HeartbeatMessageType = {
    heartbeat_request: 1,
    heartbeat_response: 2
  }, o.CipherSuites = {}, o.getCipherSuite = function(w) {
    var b = null;
    for (var T in o.CipherSuites) {
      var g = o.CipherSuites[T];
      if (g.id[0] === w.charCodeAt(0) && g.id[1] === w.charCodeAt(1)) {
        b = g;
        break;
      }
    }
    return b;
  }, o.handleUnexpected = function(w, b) {
    var T = !w.open && w.entity === o.ConnectionEnd.client;
    T || w.error(w, {
      message: "Unexpected message. Received TLS record out of order.",
      send: !0,
      alert: {
        level: o.Alert.Level.fatal,
        description: o.Alert.Description.unexpected_message
      }
    });
  }, o.handleHelloRequest = function(w, b, T) {
    !w.handshaking && w.handshakes > 0 && (o.queue(w, o.createAlert(w, {
      level: o.Alert.Level.warning,
      description: o.Alert.Description.no_renegotiation
    })), o.flush(w)), w.process();
  }, o.parseHelloMessage = function(w, b, T) {
    var g = null, x = w.entity === o.ConnectionEnd.client;
    if (T < 38)
      w.error(w, {
        message: x ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.illegal_parameter
        }
      });
    else {
      var U = b.fragment, k = U.length();
      if (g = {
        version: {
          major: U.getByte(),
          minor: U.getByte()
        },
        random: t.util.createBuffer(U.getBytes(32)),
        session_id: a(U, 1),
        extensions: []
      }, x ? (g.cipher_suite = U.getBytes(2), g.compression_method = U.getByte()) : (g.cipher_suites = a(U, 2), g.compression_methods = a(U, 1)), k = T - (k - U.length()), k > 0) {
        for (var W = a(U, 2); W.length() > 0; )
          g.extensions.push({
            type: [W.getByte(), W.getByte()],
            data: a(W, 2)
          });
        if (!x)
          for (var q = 0; q < g.extensions.length; ++q) {
            var z = g.extensions[q];
            if (z.type[0] === 0 && z.type[1] === 0)
              for (var j = a(z.data, 2); j.length() > 0; ) {
                var Y = j.getByte();
                if (Y !== 0)
                  break;
                w.session.extensions.server_name.serverNameList.push(
                  a(j, 2).getBytes()
                );
              }
          }
      }
      if (w.session.version && (g.version.major !== w.session.version.major || g.version.minor !== w.session.version.minor))
        return w.error(w, {
          message: "TLS version change is disallowed during renegotiation.",
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.protocol_version
          }
        });
      if (x)
        w.session.cipherSuite = o.getCipherSuite(g.cipher_suite);
      else
        for (var M = t.util.createBuffer(g.cipher_suites.bytes()); M.length() > 0 && (w.session.cipherSuite = o.getCipherSuite(M.getBytes(2)), w.session.cipherSuite === null); )
          ;
      if (w.session.cipherSuite === null)
        return w.error(w, {
          message: "No cipher suites in common.",
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.handshake_failure
          },
          cipherSuite: t.util.bytesToHex(g.cipher_suite)
        });
      x ? w.session.compressionMethod = g.compression_method : w.session.compressionMethod = o.CompressionMethod.none;
    }
    return g;
  }, o.createSecurityParameters = function(w, b) {
    var T = w.entity === o.ConnectionEnd.client, g = b.random.bytes(), x = T ? w.session.sp.client_random : g, U = T ? g : o.createRandom().getBytes();
    w.session.sp = {
      entity: w.entity,
      prf_algorithm: o.PRFAlgorithm.tls_prf_sha256,
      bulk_cipher_algorithm: null,
      cipher_type: null,
      enc_key_length: null,
      block_length: null,
      fixed_iv_length: null,
      record_iv_length: null,
      mac_algorithm: null,
      mac_length: null,
      mac_key_length: null,
      compression_algorithm: w.session.compressionMethod,
      pre_master_secret: null,
      master_secret: null,
      client_random: x,
      server_random: U
    };
  }, o.handleServerHello = function(w, b, T) {
    var g = o.parseHelloMessage(w, b, T);
    if (!w.fail) {
      if (g.version.minor <= w.version.minor)
        w.version.minor = g.version.minor;
      else
        return w.error(w, {
          message: "Incompatible TLS version.",
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.protocol_version
          }
        });
      w.session.version = w.version;
      var x = g.session_id.bytes();
      x.length > 0 && x === w.session.id ? (w.expect = p, w.session.resuming = !0, w.session.sp.server_random = g.random.bytes()) : (w.expect = u, w.session.resuming = !1, o.createSecurityParameters(w, g)), w.session.id = x, w.process();
    }
  }, o.handleClientHello = function(w, b, T) {
    var g = o.parseHelloMessage(w, b, T);
    if (!w.fail) {
      var x = g.session_id.bytes(), U = null;
      if (w.sessionCache && (U = w.sessionCache.getSession(x), U === null ? x = "" : (U.version.major !== g.version.major || U.version.minor > g.version.minor) && (U = null, x = "")), x.length === 0 && (x = t.random.getBytes(32)), w.session.id = x, w.session.clientHelloVersion = g.version, w.session.sp = {}, U)
        w.version = w.session.version = U.version, w.session.sp = U.sp;
      else {
        for (var k, W = 1; W < o.SupportedVersions.length && (k = o.SupportedVersions[W], !(k.minor <= g.version.minor)); ++W)
          ;
        w.version = { major: k.major, minor: k.minor }, w.session.version = w.version;
      }
      U !== null ? (w.expect = N, w.session.resuming = !0, w.session.sp.client_random = g.random.bytes()) : (w.expect = w.verifyClient !== !1 ? E : v, w.session.resuming = !1, o.createSecurityParameters(w, g)), w.open = !0, o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createServerHello(w)
      })), w.session.resuming ? (o.queue(w, o.createRecord(w, {
        type: o.ContentType.change_cipher_spec,
        data: o.createChangeCipherSpec()
      })), w.state.pending = o.createConnectionState(w), w.state.current.write = w.state.pending.write, o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createFinished(w)
      }))) : (o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createCertificate(w)
      })), w.fail || (o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createServerKeyExchange(w)
      })), w.verifyClient !== !1 && o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createCertificateRequest(w)
      })), o.queue(w, o.createRecord(w, {
        type: o.ContentType.handshake,
        data: o.createServerHelloDone(w)
      })))), o.flush(w), w.process();
    }
  }, o.handleCertificate = function(w, b, T) {
    if (T < 3)
      return w.error(w, {
        message: "Invalid Certificate message. Message too short.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.illegal_parameter
        }
      });
    var g = b.fragment, x = {
      certificate_list: a(g, 3)
    }, U, k, W = [];
    try {
      for (; x.certificate_list.length() > 0; )
        U = a(x.certificate_list, 3), k = t.asn1.fromDer(U), U = t.pki.certificateFromAsn1(k, !0), W.push(U);
    } catch (z) {
      return w.error(w, {
        message: "Could not parse certificate list.",
        cause: z,
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.bad_certificate
        }
      });
    }
    var q = w.entity === o.ConnectionEnd.client;
    (q || w.verifyClient === !0) && W.length === 0 ? w.error(w, {
      message: q ? "No server certificate provided." : "No client certificate provided.",
      send: !0,
      alert: {
        level: o.Alert.Level.fatal,
        description: o.Alert.Description.illegal_parameter
      }
    }) : W.length === 0 ? w.expect = q ? f : v : (q ? w.session.serverCertificate = W[0] : w.session.clientCertificate = W[0], o.verifyCertificateChain(w, W) && (w.expect = q ? f : v)), w.process();
  }, o.handleServerKeyExchange = function(w, b, T) {
    if (T > 0)
      return w.error(w, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.unsupported_certificate
        }
      });
    w.expect = y, w.process();
  }, o.handleClientKeyExchange = function(w, b, T) {
    if (T < 48)
      return w.error(w, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.unsupported_certificate
        }
      });
    var g = b.fragment, x = {
      enc_pre_master_secret: a(g, 2).getBytes()
    }, U = null;
    if (w.getPrivateKey)
      try {
        U = w.getPrivateKey(w, w.session.serverCertificate), U = t.pki.privateKeyFromPem(U);
      } catch (q) {
        w.error(w, {
          message: "Could not get private key.",
          cause: q,
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.internal_error
          }
        });
      }
    if (U === null)
      return w.error(w, {
        message: "No private key set.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.internal_error
        }
      });
    try {
      var k = w.session.sp;
      k.pre_master_secret = U.decrypt(x.enc_pre_master_secret);
      var W = w.session.clientHelloVersion;
      if (W.major !== k.pre_master_secret.charCodeAt(0) || W.minor !== k.pre_master_secret.charCodeAt(1))
        throw new Error("TLS version rollback attack detected.");
    } catch {
      k.pre_master_secret = t.random.getBytes(48);
    }
    w.expect = N, w.session.clientCertificate !== null && (w.expect = R), w.process();
  }, o.handleCertificateRequest = function(w, b, T) {
    if (T < 3)
      return w.error(w, {
        message: "Invalid CertificateRequest. Message too short.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.illegal_parameter
        }
      });
    var g = b.fragment, x = {
      certificate_types: a(g, 1),
      certificate_authorities: a(g, 2)
    };
    w.session.certificateRequest = x, w.expect = m, w.process();
  }, o.handleCertificateVerify = function(w, b, T) {
    if (T < 2)
      return w.error(w, {
        message: "Invalid CertificateVerify. Message too short.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.illegal_parameter
        }
      });
    var g = b.fragment;
    g.read -= 4;
    var x = g.bytes();
    g.read += 4;
    var U = {
      signature: a(g, 2).getBytes()
    }, k = t.util.createBuffer();
    k.putBuffer(w.session.md5.digest()), k.putBuffer(w.session.sha1.digest()), k = k.getBytes();
    try {
      var W = w.session.clientCertificate;
      if (!W.publicKey.verify(k, U.signature, "NONE"))
        throw new Error("CertificateVerify signature does not match.");
      w.session.md5.update(x), w.session.sha1.update(x);
    } catch {
      return w.error(w, {
        message: "Bad signature in CertificateVerify.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.handshake_failure
        }
      });
    }
    w.expect = N, w.process();
  }, o.handleServerHelloDone = function(w, b, T) {
    if (T > 0)
      return w.error(w, {
        message: "Invalid ServerHelloDone message. Invalid length.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.record_overflow
        }
      });
    if (w.serverCertificate === null) {
      var g = {
        message: "No server certificate provided. Not enough security.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.insufficient_security
        }
      }, x = 0, U = w.verify(w, g.alert.description, x, []);
      if (U !== !0)
        return (U || U === 0) && (typeof U == "object" && !t.util.isArray(U) ? (U.message && (g.message = U.message), U.alert && (g.alert.description = U.alert)) : typeof U == "number" && (g.alert.description = U)), w.error(w, g);
    }
    w.session.certificateRequest !== null && (b = o.createRecord(w, {
      type: o.ContentType.handshake,
      data: o.createCertificate(w)
    }), o.queue(w, b)), b = o.createRecord(w, {
      type: o.ContentType.handshake,
      data: o.createClientKeyExchange(w)
    }), o.queue(w, b), w.expect = I;
    var k = function(W, q) {
      W.session.certificateRequest !== null && W.session.clientCertificate !== null && o.queue(W, o.createRecord(W, {
        type: o.ContentType.handshake,
        data: o.createCertificateVerify(W, q)
      })), o.queue(W, o.createRecord(W, {
        type: o.ContentType.change_cipher_spec,
        data: o.createChangeCipherSpec()
      })), W.state.pending = o.createConnectionState(W), W.state.current.write = W.state.pending.write, o.queue(W, o.createRecord(W, {
        type: o.ContentType.handshake,
        data: o.createFinished(W)
      })), W.expect = p, o.flush(W), W.process();
    };
    if (w.session.certificateRequest === null || w.session.clientCertificate === null)
      return k(w, null);
    o.getClientSignature(w, k);
  }, o.handleChangeCipherSpec = function(w, b) {
    if (b.fragment.getByte() !== 1)
      return w.error(w, {
        message: "Invalid ChangeCipherSpec message received.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.illegal_parameter
        }
      });
    var T = w.entity === o.ConnectionEnd.client;
    (w.session.resuming && T || !w.session.resuming && !T) && (w.state.pending = o.createConnectionState(w)), w.state.current.read = w.state.pending.read, (!w.session.resuming && T || w.session.resuming && !T) && (w.state.pending = null), w.expect = T ? S : C, w.process();
  }, o.handleFinished = function(w, b, T) {
    var g = b.fragment;
    g.read -= 4;
    var x = g.bytes();
    g.read += 4;
    var U = b.fragment.getBytes();
    g = t.util.createBuffer(), g.putBuffer(w.session.md5.digest()), g.putBuffer(w.session.sha1.digest());
    var k = w.entity === o.ConnectionEnd.client, W = k ? "server finished" : "client finished", q = w.session.sp, z = 12, j = e;
    if (g = j(q.master_secret, W, g.getBytes(), z), g.getBytes() !== U)
      return w.error(w, {
        message: "Invalid verify_data in Finished message.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.decrypt_error
        }
      });
    w.session.md5.update(x), w.session.sha1.update(x), (w.session.resuming && k || !w.session.resuming && !k) && (o.queue(w, o.createRecord(w, {
      type: o.ContentType.change_cipher_spec,
      data: o.createChangeCipherSpec()
    })), w.state.current.write = w.state.pending.write, w.state.pending = null, o.queue(w, o.createRecord(w, {
      type: o.ContentType.handshake,
      data: o.createFinished(w)
    }))), w.expect = k ? A : h, w.handshaking = !1, ++w.handshakes, w.peerCertificate = k ? w.session.serverCertificate : w.session.clientCertificate, o.flush(w), w.isConnected = !0, w.connected(w), w.process();
  }, o.handleAlert = function(w, b) {
    var T = b.fragment, g = {
      level: T.getByte(),
      description: T.getByte()
    }, x;
    switch (g.description) {
      case o.Alert.Description.close_notify:
        x = "Connection closed.";
        break;
      case o.Alert.Description.unexpected_message:
        x = "Unexpected message.";
        break;
      case o.Alert.Description.bad_record_mac:
        x = "Bad record MAC.";
        break;
      case o.Alert.Description.decryption_failed:
        x = "Decryption failed.";
        break;
      case o.Alert.Description.record_overflow:
        x = "Record overflow.";
        break;
      case o.Alert.Description.decompression_failure:
        x = "Decompression failed.";
        break;
      case o.Alert.Description.handshake_failure:
        x = "Handshake failure.";
        break;
      case o.Alert.Description.bad_certificate:
        x = "Bad certificate.";
        break;
      case o.Alert.Description.unsupported_certificate:
        x = "Unsupported certificate.";
        break;
      case o.Alert.Description.certificate_revoked:
        x = "Certificate revoked.";
        break;
      case o.Alert.Description.certificate_expired:
        x = "Certificate expired.";
        break;
      case o.Alert.Description.certificate_unknown:
        x = "Certificate unknown.";
        break;
      case o.Alert.Description.illegal_parameter:
        x = "Illegal parameter.";
        break;
      case o.Alert.Description.unknown_ca:
        x = "Unknown certificate authority.";
        break;
      case o.Alert.Description.access_denied:
        x = "Access denied.";
        break;
      case o.Alert.Description.decode_error:
        x = "Decode error.";
        break;
      case o.Alert.Description.decrypt_error:
        x = "Decrypt error.";
        break;
      case o.Alert.Description.export_restriction:
        x = "Export restriction.";
        break;
      case o.Alert.Description.protocol_version:
        x = "Unsupported protocol version.";
        break;
      case o.Alert.Description.insufficient_security:
        x = "Insufficient security.";
        break;
      case o.Alert.Description.internal_error:
        x = "Internal error.";
        break;
      case o.Alert.Description.user_canceled:
        x = "User canceled.";
        break;
      case o.Alert.Description.no_renegotiation:
        x = "Renegotiation not supported.";
        break;
      default:
        x = "Unknown error.";
        break;
    }
    if (g.description === o.Alert.Description.close_notify)
      return w.close();
    w.error(w, {
      message: x,
      send: !1,
      // origin is the opposite end
      origin: w.entity === o.ConnectionEnd.client ? "server" : "client",
      alert: g
    }), w.process();
  }, o.handleHandshake = function(w, b) {
    var T = b.fragment, g = T.getByte(), x = T.getInt24();
    if (x > T.length())
      return w.fragmented = b, b.fragment = t.util.createBuffer(), T.read -= 4, w.process();
    w.fragmented = null, T.read -= 4;
    var U = T.bytes(x + 4);
    T.read += 4, g in ye[w.entity][w.expect] ? (w.entity === o.ConnectionEnd.server && !w.open && !w.fail && (w.handshaking = !0, w.session = {
      version: null,
      extensions: {
        server_name: {
          serverNameList: []
        }
      },
      cipherSuite: null,
      compressionMethod: null,
      serverCertificate: null,
      clientCertificate: null,
      md5: t.md.md5.create(),
      sha1: t.md.sha1.create()
    }), g !== o.HandshakeType.hello_request && g !== o.HandshakeType.certificate_verify && g !== o.HandshakeType.finished && (w.session.md5.update(U), w.session.sha1.update(U)), ye[w.entity][w.expect][g](w, b, x)) : o.handleUnexpected(w, b);
  }, o.handleApplicationData = function(w, b) {
    w.data.putBuffer(b.fragment), w.dataReady(w), w.process();
  }, o.handleHeartbeat = function(w, b) {
    var T = b.fragment, g = T.getByte(), x = T.getInt16(), U = T.getBytes(x);
    if (g === o.HeartbeatMessageType.heartbeat_request) {
      if (w.handshaking || x > U.length)
        return w.process();
      o.queue(w, o.createRecord(w, {
        type: o.ContentType.heartbeat,
        data: o.createHeartbeat(
          o.HeartbeatMessageType.heartbeat_response,
          U
        )
      })), o.flush(w);
    } else if (g === o.HeartbeatMessageType.heartbeat_response) {
      if (U !== w.expectedHeartbeatPayload)
        return w.process();
      w.heartbeatReceived && w.heartbeatReceived(w, t.util.createBuffer(U));
    }
    w.process();
  };
  var l = 0, u = 1, f = 2, y = 3, m = 4, p = 5, S = 6, A = 7, I = 8, c = 0, E = 1, v = 2, R = 3, N = 4, C = 5, h = 6, d = o.handleUnexpected, O = o.handleChangeCipherSpec, P = o.handleAlert, L = o.handleHandshake, D = o.handleApplicationData, V = o.handleHeartbeat, $ = [];
  $[o.ConnectionEnd.client] = [
    //      CC,AL,HS,AD,HB
    /*SHE*/
    [d, P, L, d, V],
    /*SCE*/
    [d, P, L, d, V],
    /*SKE*/
    [d, P, L, d, V],
    /*SCR*/
    [d, P, L, d, V],
    /*SHD*/
    [d, P, L, d, V],
    /*SCC*/
    [O, P, d, d, V],
    /*SFI*/
    [d, P, L, d, V],
    /*SAD*/
    [d, P, L, D, V],
    /*SER*/
    [d, P, L, d, V]
  ], $[o.ConnectionEnd.server] = [
    //      CC,AL,HS,AD
    /*CHE*/
    [d, P, L, d, V],
    /*CCE*/
    [d, P, L, d, V],
    /*CKE*/
    [d, P, L, d, V],
    /*CCV*/
    [d, P, L, d, V],
    /*CCC*/
    [O, P, d, d, V],
    /*CFI*/
    [d, P, L, d, V],
    /*CAD*/
    [d, P, L, D, V],
    /*CER*/
    [d, P, L, d, V]
  ];
  var K = o.handleHelloRequest, Q = o.handleServerHello, ee = o.handleCertificate, ne = o.handleServerKeyExchange, ae = o.handleCertificateRequest, se = o.handleServerHelloDone, me = o.handleFinished, ye = [];
  ye[o.ConnectionEnd.client] = [
    //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
    /*SHE*/
    [d, d, Q, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*SCE*/
    [K, d, d, d, d, d, d, d, d, d, d, ee, ne, ae, se, d, d, d, d, d, d],
    /*SKE*/
    [K, d, d, d, d, d, d, d, d, d, d, d, ne, ae, se, d, d, d, d, d, d],
    /*SCR*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, ae, se, d, d, d, d, d, d],
    /*SHD*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, d, se, d, d, d, d, d, d],
    /*SCC*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*SFI*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, me],
    /*SAD*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*SER*/
    [K, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d]
  ];
  var Se = o.handleClientHello, te = o.handleClientKeyExchange, Ce = o.handleCertificateVerify;
  ye[o.ConnectionEnd.server] = [
    //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
    /*CHE*/
    [d, Se, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*CCE*/
    [d, d, d, d, d, d, d, d, d, d, d, ee, d, d, d, d, d, d, d, d, d],
    /*CKE*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, te, d, d, d, d],
    /*CCV*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, Ce, d, d, d, d, d],
    /*CCC*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*CFI*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, me],
    /*CAD*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d],
    /*CER*/
    [d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d]
  ], o.generateKeys = function(w, b) {
    var T = e, g = b.client_random + b.server_random;
    w.session.resuming || (b.master_secret = T(
      b.pre_master_secret,
      "master secret",
      g,
      48
    ).bytes(), b.pre_master_secret = null), g = b.server_random + b.client_random;
    var x = 2 * b.mac_key_length + 2 * b.enc_key_length, U = w.version.major === o.Versions.TLS_1_0.major && w.version.minor === o.Versions.TLS_1_0.minor;
    U && (x += 2 * b.fixed_iv_length);
    var k = T(b.master_secret, "key expansion", g, x), W = {
      client_write_MAC_key: k.getBytes(b.mac_key_length),
      server_write_MAC_key: k.getBytes(b.mac_key_length),
      client_write_key: k.getBytes(b.enc_key_length),
      server_write_key: k.getBytes(b.enc_key_length)
    };
    return U && (W.client_write_IV = k.getBytes(b.fixed_iv_length), W.server_write_IV = k.getBytes(b.fixed_iv_length)), W;
  }, o.createConnectionState = function(w) {
    var b = w.entity === o.ConnectionEnd.client, T = function() {
      var U = {
        // two 32-bit numbers, first is most significant
        sequenceNumber: [0, 0],
        macKey: null,
        macLength: 0,
        macFunction: null,
        cipherState: null,
        cipherFunction: function(k) {
          return !0;
        },
        compressionState: null,
        compressFunction: function(k) {
          return !0;
        },
        updateSequenceNumber: function() {
          U.sequenceNumber[1] === 4294967295 ? (U.sequenceNumber[1] = 0, ++U.sequenceNumber[0]) : ++U.sequenceNumber[1];
        }
      };
      return U;
    }, g = {
      read: T(),
      write: T()
    };
    if (g.read.update = function(U, k) {
      return g.read.cipherFunction(k, g.read) ? g.read.compressFunction(U, k, g.read) || U.error(U, {
        message: "Could not decompress record.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.decompression_failure
        }
      }) : U.error(U, {
        message: "Could not decrypt record or bad MAC.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          // doesn't matter if decryption failed or MAC was
          // invalid, return the same error so as not to reveal
          // which one occurred
          description: o.Alert.Description.bad_record_mac
        }
      }), !U.fail;
    }, g.write.update = function(U, k) {
      return g.write.compressFunction(U, k, g.write) ? g.write.cipherFunction(k, g.write) || U.error(U, {
        message: "Could not encrypt record.",
        send: !1,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.internal_error
        }
      }) : U.error(U, {
        message: "Could not compress record.",
        send: !1,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.internal_error
        }
      }), !U.fail;
    }, w.session) {
      var x = w.session.sp;
      switch (w.session.cipherSuite.initSecurityParameters(x), x.keys = o.generateKeys(w, x), g.read.macKey = b ? x.keys.server_write_MAC_key : x.keys.client_write_MAC_key, g.write.macKey = b ? x.keys.client_write_MAC_key : x.keys.server_write_MAC_key, w.session.cipherSuite.initConnectionState(g, w, x), x.compression_algorithm) {
        case o.CompressionMethod.none:
          break;
        case o.CompressionMethod.deflate:
          g.read.compressFunction = i, g.write.compressFunction = n;
          break;
        default:
          throw new Error("Unsupported compression algorithm.");
      }
    }
    return g;
  }, o.createRandom = function() {
    var w = /* @__PURE__ */ new Date(), b = +w + w.getTimezoneOffset() * 6e4, T = t.util.createBuffer();
    return T.putInt32(b), T.putBytes(t.random.getBytes(28)), T;
  }, o.createRecord = function(w, b) {
    if (!b.data)
      return null;
    var T = {
      type: b.type,
      version: {
        major: w.version.major,
        minor: w.version.minor
      },
      length: b.data.length(),
      fragment: b.data
    };
    return T;
  }, o.createAlert = function(w, b) {
    var T = t.util.createBuffer();
    return T.putByte(b.level), T.putByte(b.description), o.createRecord(w, {
      type: o.ContentType.alert,
      data: T
    });
  }, o.createClientHello = function(w) {
    w.session.clientHelloVersion = {
      major: w.version.major,
      minor: w.version.minor
    };
    for (var b = t.util.createBuffer(), T = 0; T < w.cipherSuites.length; ++T) {
      var g = w.cipherSuites[T];
      b.putByte(g.id[0]), b.putByte(g.id[1]);
    }
    var x = b.length(), U = t.util.createBuffer();
    U.putByte(o.CompressionMethod.none);
    var k = U.length(), W = t.util.createBuffer();
    if (w.virtualHost) {
      var q = t.util.createBuffer();
      q.putByte(0), q.putByte(0);
      var z = t.util.createBuffer();
      z.putByte(0), s(z, 2, t.util.createBuffer(w.virtualHost));
      var j = t.util.createBuffer();
      s(j, 2, z), s(q, 2, j), W.putBuffer(q);
    }
    var Y = W.length();
    Y > 0 && (Y += 2);
    var M = w.session.id, X = M.length + 1 + // session ID vector
    2 + // version (major + minor)
    4 + 28 + // random time and random bytes
    2 + x + // cipher suites vector
    1 + k + // compression methods vector
    Y, J = t.util.createBuffer();
    return J.putByte(o.HandshakeType.client_hello), J.putInt24(X), J.putByte(w.version.major), J.putByte(w.version.minor), J.putBytes(w.session.sp.client_random), s(J, 1, t.util.createBuffer(M)), s(J, 2, b), s(J, 1, U), Y > 0 && s(J, 2, W), J;
  }, o.createServerHello = function(w) {
    var b = w.session.id, T = b.length + 1 + // session ID vector
    2 + // version (major + minor)
    4 + 28 + // random time and random bytes
    2 + // chosen cipher suite
    1, g = t.util.createBuffer();
    return g.putByte(o.HandshakeType.server_hello), g.putInt24(T), g.putByte(w.version.major), g.putByte(w.version.minor), g.putBytes(w.session.sp.server_random), s(g, 1, t.util.createBuffer(b)), g.putByte(w.session.cipherSuite.id[0]), g.putByte(w.session.cipherSuite.id[1]), g.putByte(w.session.compressionMethod), g;
  }, o.createCertificate = function(w) {
    var b = w.entity === o.ConnectionEnd.client, T = null;
    if (w.getCertificate) {
      var g;
      b ? g = w.session.certificateRequest : g = w.session.extensions.server_name.serverNameList, T = w.getCertificate(w, g);
    }
    var x = t.util.createBuffer();
    if (T !== null)
      try {
        t.util.isArray(T) || (T = [T]);
        for (var U = null, k = 0; k < T.length; ++k) {
          var W = t.pem.decode(T[k])[0];
          if (W.type !== "CERTIFICATE" && W.type !== "X509 CERTIFICATE" && W.type !== "TRUSTED CERTIFICATE") {
            var q = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
            throw q.headerType = W.type, q;
          }
          if (W.procType && W.procType.type === "ENCRYPTED")
            throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
          var z = t.util.createBuffer(W.body);
          U === null && (U = t.asn1.fromDer(z.bytes(), !1));
          var j = t.util.createBuffer();
          s(j, 3, z), x.putBuffer(j);
        }
        T = t.pki.certificateFromAsn1(U), b ? w.session.clientCertificate = T : w.session.serverCertificate = T;
      } catch (X) {
        return w.error(w, {
          message: "Could not send certificate list.",
          cause: X,
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.bad_certificate
          }
        });
      }
    var Y = 3 + x.length(), M = t.util.createBuffer();
    return M.putByte(o.HandshakeType.certificate), M.putInt24(Y), s(M, 3, x), M;
  }, o.createClientKeyExchange = function(w) {
    var b = t.util.createBuffer();
    b.putByte(w.session.clientHelloVersion.major), b.putByte(w.session.clientHelloVersion.minor), b.putBytes(t.random.getBytes(46));
    var T = w.session.sp;
    T.pre_master_secret = b.getBytes();
    var g = w.session.serverCertificate.publicKey;
    b = g.encrypt(T.pre_master_secret);
    var x = b.length + 2, U = t.util.createBuffer();
    return U.putByte(o.HandshakeType.client_key_exchange), U.putInt24(x), U.putInt16(b.length), U.putBytes(b), U;
  }, o.createServerKeyExchange = function(w) {
    var b = t.util.createBuffer();
    return b;
  }, o.getClientSignature = function(w, b) {
    var T = t.util.createBuffer();
    T.putBuffer(w.session.md5.digest()), T.putBuffer(w.session.sha1.digest()), T = T.getBytes(), w.getSignature = w.getSignature || function(g, x, U) {
      var k = null;
      if (g.getPrivateKey)
        try {
          k = g.getPrivateKey(g, g.session.clientCertificate), k = t.pki.privateKeyFromPem(k);
        } catch (W) {
          g.error(g, {
            message: "Could not get private key.",
            cause: W,
            send: !0,
            alert: {
              level: o.Alert.Level.fatal,
              description: o.Alert.Description.internal_error
            }
          });
        }
      k === null ? g.error(g, {
        message: "No private key set.",
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: o.Alert.Description.internal_error
        }
      }) : x = k.sign(x, null), U(g, x);
    }, w.getSignature(w, T, b);
  }, o.createCertificateVerify = function(w, b) {
    var T = b.length + 2, g = t.util.createBuffer();
    return g.putByte(o.HandshakeType.certificate_verify), g.putInt24(T), g.putInt16(b.length), g.putBytes(b), g;
  }, o.createCertificateRequest = function(w) {
    var b = t.util.createBuffer();
    b.putByte(1);
    var T = t.util.createBuffer();
    for (var g in w.caStore.certs) {
      var x = w.caStore.certs[g], U = t.pki.distinguishedNameToAsn1(x.subject), k = t.asn1.toDer(U);
      T.putInt16(k.length()), T.putBuffer(k);
    }
    var W = 1 + b.length() + 2 + T.length(), q = t.util.createBuffer();
    return q.putByte(o.HandshakeType.certificate_request), q.putInt24(W), s(q, 1, b), s(q, 2, T), q;
  }, o.createServerHelloDone = function(w) {
    var b = t.util.createBuffer();
    return b.putByte(o.HandshakeType.server_hello_done), b.putInt24(0), b;
  }, o.createChangeCipherSpec = function() {
    var w = t.util.createBuffer();
    return w.putByte(1), w;
  }, o.createFinished = function(w) {
    var b = t.util.createBuffer();
    b.putBuffer(w.session.md5.digest()), b.putBuffer(w.session.sha1.digest());
    var T = w.entity === o.ConnectionEnd.client, g = w.session.sp, x = 12, U = e, k = T ? "client finished" : "server finished";
    b = U(g.master_secret, k, b.getBytes(), x);
    var W = t.util.createBuffer();
    return W.putByte(o.HandshakeType.finished), W.putInt24(b.length()), W.putBuffer(b), W;
  }, o.createHeartbeat = function(w, b, T) {
    typeof T > "u" && (T = b.length);
    var g = t.util.createBuffer();
    g.putByte(w), g.putInt16(T), g.putBytes(b);
    var x = g.length(), U = Math.max(16, x - T - 3);
    return g.putBytes(t.random.getBytes(U)), g;
  }, o.queue = function(w, b) {
    if (b && !(b.fragment.length() === 0 && (b.type === o.ContentType.handshake || b.type === o.ContentType.alert || b.type === o.ContentType.change_cipher_spec))) {
      if (b.type === o.ContentType.handshake) {
        var T = b.fragment.bytes();
        w.session.md5.update(T), w.session.sha1.update(T), T = null;
      }
      var g;
      if (b.fragment.length() <= o.MaxFragment)
        g = [b];
      else {
        g = [];
        for (var x = b.fragment.bytes(); x.length > o.MaxFragment; )
          g.push(o.createRecord(w, {
            type: b.type,
            data: t.util.createBuffer(x.slice(0, o.MaxFragment))
          })), x = x.slice(o.MaxFragment);
        x.length > 0 && g.push(o.createRecord(w, {
          type: b.type,
          data: t.util.createBuffer(x)
        }));
      }
      for (var U = 0; U < g.length && !w.fail; ++U) {
        var k = g[U], W = w.state.current.write;
        W.update(w, k) && w.records.push(k);
      }
    }
  }, o.flush = function(w) {
    for (var b = 0; b < w.records.length; ++b) {
      var T = w.records[b];
      w.tlsData.putByte(T.type), w.tlsData.putByte(T.version.major), w.tlsData.putByte(T.version.minor), w.tlsData.putInt16(T.fragment.length()), w.tlsData.putBuffer(w.records[b].fragment);
    }
    return w.records = [], w.tlsDataReady(w);
  };
  var fe = function(w) {
    switch (w) {
      case !0:
        return !0;
      case t.pki.certificateError.bad_certificate:
        return o.Alert.Description.bad_certificate;
      case t.pki.certificateError.unsupported_certificate:
        return o.Alert.Description.unsupported_certificate;
      case t.pki.certificateError.certificate_revoked:
        return o.Alert.Description.certificate_revoked;
      case t.pki.certificateError.certificate_expired:
        return o.Alert.Description.certificate_expired;
      case t.pki.certificateError.certificate_unknown:
        return o.Alert.Description.certificate_unknown;
      case t.pki.certificateError.unknown_ca:
        return o.Alert.Description.unknown_ca;
      default:
        return o.Alert.Description.bad_certificate;
    }
  }, De = function(w) {
    switch (w) {
      case !0:
        return !0;
      case o.Alert.Description.bad_certificate:
        return t.pki.certificateError.bad_certificate;
      case o.Alert.Description.unsupported_certificate:
        return t.pki.certificateError.unsupported_certificate;
      case o.Alert.Description.certificate_revoked:
        return t.pki.certificateError.certificate_revoked;
      case o.Alert.Description.certificate_expired:
        return t.pki.certificateError.certificate_expired;
      case o.Alert.Description.certificate_unknown:
        return t.pki.certificateError.certificate_unknown;
      case o.Alert.Description.unknown_ca:
        return t.pki.certificateError.unknown_ca;
      default:
        return t.pki.certificateError.bad_certificate;
    }
  };
  o.verifyCertificateChain = function(w, b) {
    try {
      var T = {};
      for (var g in w.verifyOptions)
        T[g] = w.verifyOptions[g];
      T.verify = function(U, k, W) {
        var q = fe(U), z = w.verify(w, U, k, W);
        if (z !== !0) {
          if (typeof z == "object" && !t.util.isArray(z)) {
            var j = new Error("The application rejected the certificate.");
            throw j.send = !0, j.alert = {
              level: o.Alert.Level.fatal,
              description: o.Alert.Description.bad_certificate
            }, z.message && (j.message = z.message), z.alert && (j.alert.description = z.alert), j;
          }
          z !== U && (z = De(z));
        }
        return z;
      }, t.pki.verifyCertificateChain(w.caStore, b, T);
    } catch (U) {
      var x = U;
      (typeof x != "object" || t.util.isArray(x)) && (x = {
        send: !0,
        alert: {
          level: o.Alert.Level.fatal,
          description: fe(U)
        }
      }), "send" in x || (x.send = !0), "alert" in x || (x.alert = {
        level: o.Alert.Level.fatal,
        description: fe(x.error)
      }), w.error(w, x);
    }
    return !w.fail;
  }, o.createSessionCache = function(w, b) {
    var T = null;
    if (w && w.getSession && w.setSession && w.order)
      T = w;
    else {
      T = {}, T.cache = w || {}, T.capacity = Math.max(b || 100, 1), T.order = [];
      for (var g in w)
        T.order.length <= b ? T.order.push(g) : delete w[g];
      T.getSession = function(x) {
        var U = null, k = null;
        if (x ? k = t.util.bytesToHex(x) : T.order.length > 0 && (k = T.order[0]), k !== null && k in T.cache) {
          U = T.cache[k], delete T.cache[k];
          for (var W in T.order)
            if (T.order[W] === k) {
              T.order.splice(W, 1);
              break;
            }
        }
        return U;
      }, T.setSession = function(x, U) {
        if (T.order.length === T.capacity) {
          var k = T.order.shift();
          delete T.cache[k];
        }
        var k = t.util.bytesToHex(x);
        T.order.push(k), T.cache[k] = U;
      };
    }
    return T;
  }, o.createConnection = function(w) {
    var b = null;
    w.caStore ? t.util.isArray(w.caStore) ? b = t.pki.createCaStore(w.caStore) : b = w.caStore : b = t.pki.createCaStore();
    var T = w.cipherSuites || null;
    if (T === null) {
      T = [];
      for (var g in o.CipherSuites)
        T.push(o.CipherSuites[g]);
    }
    var x = w.server ? o.ConnectionEnd.server : o.ConnectionEnd.client, U = w.sessionCache ? o.createSessionCache(w.sessionCache) : null, k = {
      version: { major: o.Version.major, minor: o.Version.minor },
      entity: x,
      sessionId: w.sessionId,
      caStore: b,
      sessionCache: U,
      cipherSuites: T,
      connected: w.connected,
      virtualHost: w.virtualHost || null,
      verifyClient: w.verifyClient || !1,
      verify: w.verify || function(j, Y, M, X) {
        return Y;
      },
      verifyOptions: w.verifyOptions || {},
      getCertificate: w.getCertificate || null,
      getPrivateKey: w.getPrivateKey || null,
      getSignature: w.getSignature || null,
      input: t.util.createBuffer(),
      tlsData: t.util.createBuffer(),
      data: t.util.createBuffer(),
      tlsDataReady: w.tlsDataReady,
      dataReady: w.dataReady,
      heartbeatReceived: w.heartbeatReceived,
      closed: w.closed,
      error: function(j, Y) {
        Y.origin = Y.origin || (j.entity === o.ConnectionEnd.client ? "client" : "server"), Y.send && (o.queue(j, o.createAlert(j, Y.alert)), o.flush(j));
        var M = Y.fatal !== !1;
        M && (j.fail = !0), w.error(j, Y), M && j.close(!1);
      },
      deflate: w.deflate || null,
      inflate: w.inflate || null
    };
    k.reset = function(j) {
      k.version = { major: o.Version.major, minor: o.Version.minor }, k.record = null, k.session = null, k.peerCertificate = null, k.state = {
        pending: null,
        current: null
      }, k.expect = k.entity === o.ConnectionEnd.client ? l : c, k.fragmented = null, k.records = [], k.open = !1, k.handshakes = 0, k.handshaking = !1, k.isConnected = !1, k.fail = !(j || typeof j > "u"), k.input.clear(), k.tlsData.clear(), k.data.clear(), k.state.current = o.createConnectionState(k);
    }, k.reset();
    var W = function(j, Y) {
      var M = Y.type - o.ContentType.change_cipher_spec, X = $[j.entity][j.expect];
      M in X ? X[M](j, Y) : o.handleUnexpected(j, Y);
    }, q = function(j) {
      var Y = 0, M = j.input, X = M.length();
      if (X < 5)
        Y = 5 - X;
      else {
        j.record = {
          type: M.getByte(),
          version: {
            major: M.getByte(),
            minor: M.getByte()
          },
          length: M.getInt16(),
          fragment: t.util.createBuffer(),
          ready: !1
        };
        var J = j.record.version.major === j.version.major;
        J && j.session && j.session.version && (J = j.record.version.minor === j.version.minor), J || j.error(j, {
          message: "Incompatible TLS version.",
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.protocol_version
          }
        });
      }
      return Y;
    }, z = function(j) {
      var Y = 0, M = j.input, X = M.length();
      if (X < j.record.length)
        Y = j.record.length - X;
      else {
        j.record.fragment.putBytes(M.getBytes(j.record.length)), M.compact();
        var J = j.state.current.read;
        J.update(j, j.record) && (j.fragmented !== null && (j.fragmented.type === j.record.type ? (j.fragmented.fragment.putBuffer(j.record.fragment), j.record = j.fragmented) : j.error(j, {
          message: "Invalid fragmented record.",
          send: !0,
          alert: {
            level: o.Alert.Level.fatal,
            description: o.Alert.Description.unexpected_message
          }
        })), j.record.ready = !0);
      }
      return Y;
    };
    return k.handshake = function(j) {
      if (k.entity !== o.ConnectionEnd.client)
        k.error(k, {
          message: "Cannot initiate handshake as a server.",
          fatal: !1
        });
      else if (k.handshaking)
        k.error(k, {
          message: "Handshake already in progress.",
          fatal: !1
        });
      else {
        k.fail && !k.open && k.handshakes === 0 && (k.fail = !1), k.handshaking = !0, j = j || "";
        var Y = null;
        j.length > 0 && (k.sessionCache && (Y = k.sessionCache.getSession(j)), Y === null && (j = "")), j.length === 0 && k.sessionCache && (Y = k.sessionCache.getSession(), Y !== null && (j = Y.id)), k.session = {
          id: j,
          version: null,
          cipherSuite: null,
          compressionMethod: null,
          serverCertificate: null,
          certificateRequest: null,
          clientCertificate: null,
          sp: {},
          md5: t.md.md5.create(),
          sha1: t.md.sha1.create()
        }, Y && (k.version = Y.version, k.session.sp = Y.sp), k.session.sp.client_random = o.createRandom().getBytes(), k.open = !0, o.queue(k, o.createRecord(k, {
          type: o.ContentType.handshake,
          data: o.createClientHello(k)
        })), o.flush(k);
      }
    }, k.process = function(j) {
      var Y = 0;
      return j && k.input.putBytes(j), k.fail || (k.record !== null && k.record.ready && k.record.fragment.isEmpty() && (k.record = null), k.record === null && (Y = q(k)), !k.fail && k.record !== null && !k.record.ready && (Y = z(k)), !k.fail && k.record !== null && k.record.ready && W(k, k.record)), Y;
    }, k.prepare = function(j) {
      return o.queue(k, o.createRecord(k, {
        type: o.ContentType.application_data,
        data: t.util.createBuffer(j)
      })), o.flush(k);
    }, k.prepareHeartbeatRequest = function(j, Y) {
      return j instanceof t.util.ByteBuffer && (j = j.bytes()), typeof Y > "u" && (Y = j.length), k.expectedHeartbeatPayload = j, o.queue(k, o.createRecord(k, {
        type: o.ContentType.heartbeat,
        data: o.createHeartbeat(
          o.HeartbeatMessageType.heartbeat_request,
          j,
          Y
        )
      })), o.flush(k);
    }, k.close = function(j) {
      if (!k.fail && k.sessionCache && k.session) {
        var Y = {
          id: k.session.id,
          version: k.session.version,
          sp: k.session.sp
        };
        Y.sp.keys = null, k.sessionCache.setSession(Y.id, Y);
      }
      k.open && (k.open = !1, k.input.clear(), (k.isConnected || k.handshaking) && (k.isConnected = k.handshaking = !1, o.queue(k, o.createAlert(k, {
        level: o.Alert.Level.warning,
        description: o.Alert.Description.close_notify
      })), o.flush(k)), k.closed(k)), k.reset(j);
    }, k;
  }, Cu = t.tls = t.tls || {};
  for (var _e in o)
    typeof o[_e] != "function" && (t.tls[_e] = o[_e]);
  return t.tls.prf_tls1 = e, t.tls.hmac_sha1 = r, t.tls.createSessionCache = o.createSessionCache, t.tls.createConnection = o.createConnection, Cu;
}
var hp;
function qI() {
  if (hp) return Yc.exports;
  hp = 1;
  var t = Pe();
  ni(), Ry();
  var e = Yc.exports = t.tls;
  e.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
    id: [0, 47],
    name: "TLS_RSA_WITH_AES_128_CBC_SHA",
    initSecurityParameters: function(l) {
      l.bulk_cipher_algorithm = e.BulkCipherAlgorithm.aes, l.cipher_type = e.CipherType.block, l.enc_key_length = 16, l.block_length = 16, l.fixed_iv_length = 16, l.record_iv_length = 16, l.mac_algorithm = e.MACAlgorithm.hmac_sha1, l.mac_length = 20, l.mac_key_length = 20;
    },
    initConnectionState: r
  }, e.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
    id: [0, 53],
    name: "TLS_RSA_WITH_AES_256_CBC_SHA",
    initSecurityParameters: function(l) {
      l.bulk_cipher_algorithm = e.BulkCipherAlgorithm.aes, l.cipher_type = e.CipherType.block, l.enc_key_length = 32, l.block_length = 16, l.fixed_iv_length = 16, l.record_iv_length = 16, l.mac_algorithm = e.MACAlgorithm.hmac_sha1, l.mac_length = 20, l.mac_key_length = 20;
    },
    initConnectionState: r
  };
  function r(l, u, f) {
    var y = u.entity === t.tls.ConnectionEnd.client;
    l.read.cipherState = {
      init: !1,
      cipher: t.cipher.createDecipher("AES-CBC", y ? f.keys.server_write_key : f.keys.client_write_key),
      iv: y ? f.keys.server_write_IV : f.keys.client_write_IV
    }, l.write.cipherState = {
      init: !1,
      cipher: t.cipher.createCipher("AES-CBC", y ? f.keys.client_write_key : f.keys.server_write_key),
      iv: y ? f.keys.client_write_IV : f.keys.server_write_IV
    }, l.read.cipherFunction = s, l.write.cipherFunction = n, l.read.macLength = l.write.macLength = f.mac_length, l.read.macFunction = l.write.macFunction = e.hmac_sha1;
  }
  function n(l, u) {
    var f = !1, y = u.macFunction(u.macKey, u.sequenceNumber, l);
    l.fragment.putBytes(y), u.updateSequenceNumber();
    var m;
    l.version.minor === e.Versions.TLS_1_0.minor ? m = u.cipherState.init ? null : u.cipherState.iv : m = t.random.getBytesSync(16), u.cipherState.init = !0;
    var p = u.cipherState.cipher;
    return p.start({ iv: m }), l.version.minor >= e.Versions.TLS_1_1.minor && p.output.putBytes(m), p.update(l.fragment), p.finish(i) && (l.fragment = p.output, l.length = l.fragment.length(), f = !0), f;
  }
  function i(l, u, f) {
    if (!f) {
      var y = l - u.length() % l;
      u.fillWithByte(y - 1, y);
    }
    return !0;
  }
  function a(l, u, f) {
    var y = !0;
    if (f) {
      for (var m = u.length(), p = u.last(), S = m - 1 - p; S < m - 1; ++S)
        y = y && u.at(S) == p;
      y && u.truncate(p + 1);
    }
    return y;
  }
  function s(l, u) {
    var f = !1, y;
    l.version.minor === e.Versions.TLS_1_0.minor ? y = u.cipherState.init ? null : u.cipherState.iv : y = l.fragment.getBytes(16), u.cipherState.init = !0;
    var m = u.cipherState.cipher;
    m.start({ iv: y }), m.update(l.fragment), f = m.finish(a);
    var p = u.macLength, S = t.random.getBytesSync(p), A = m.output.length();
    A >= p ? (l.fragment = m.output.getBytes(A - p), S = m.output.getBytes(p)) : l.fragment = m.output.getBytes(), l.fragment = t.util.createBuffer(l.fragment), l.length = l.fragment.length();
    var I = u.macFunction(u.macKey, u.sequenceNumber, l);
    return u.updateSequenceNumber(), f = o(u.macKey, S, I) && f, f;
  }
  function o(l, u, f) {
    var y = t.hmac.create();
    return y.start("SHA1", l), y.update(u), u = y.digest().getBytes(), y.start(null, null), y.update(f), f = y.digest().getBytes(), u === f;
  }
  return Yc.exports;
}
var _u = { exports: {} }, pp;
function Ny() {
  if (pp) return _u.exports;
  pp = 1;
  var t = Pe();
  dn(), $e();
  var e = _u.exports = t.sha512 = t.sha512 || {};
  t.md.sha512 = t.md.algorithms.sha512 = e;
  var r = t.sha384 = t.sha512.sha384 = t.sha512.sha384 || {};
  r.create = function() {
    return e.create("SHA-384");
  }, t.md.sha384 = t.md.algorithms.sha384 = r, t.sha512.sha256 = t.sha512.sha256 || {
    create: function() {
      return e.create("SHA-512/256");
    }
  }, t.md["sha512/256"] = t.md.algorithms["sha512/256"] = t.sha512.sha256, t.sha512.sha224 = t.sha512.sha224 || {
    create: function() {
      return e.create("SHA-512/224");
    }
  }, t.md["sha512/224"] = t.md.algorithms["sha512/224"] = t.sha512.sha224, e.create = function(u) {
    if (i || o(), typeof u > "u" && (u = "SHA-512"), !(u in s))
      throw new Error("Invalid SHA-512 algorithm: " + u);
    for (var f = s[u], y = null, m = t.util.createBuffer(), p = new Array(80), S = 0; S < 80; ++S)
      p[S] = new Array(2);
    var A = 64;
    switch (u) {
      case "SHA-384":
        A = 48;
        break;
      case "SHA-512/256":
        A = 32;
        break;
      case "SHA-512/224":
        A = 28;
        break;
    }
    var I = {
      // SHA-512 => sha512
      algorithm: u.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength: A,
      // 56-bit length of message so far (does not including padding)
      messageLength: 0,
      // true message length
      fullMessageLength: null,
      // size of message length in bytes
      messageLengthSize: 16
    };
    return I.start = function() {
      I.messageLength = 0, I.fullMessageLength = I.messageLength128 = [];
      for (var c = I.messageLengthSize / 4, E = 0; E < c; ++E)
        I.fullMessageLength.push(0);
      m = t.util.createBuffer(), y = new Array(f.length);
      for (var E = 0; E < f.length; ++E)
        y[E] = f[E].slice(0);
      return I;
    }, I.start(), I.update = function(c, E) {
      E === "utf8" && (c = t.util.encodeUtf8(c));
      var v = c.length;
      I.messageLength += v, v = [v / 4294967296 >>> 0, v >>> 0];
      for (var R = I.fullMessageLength.length - 1; R >= 0; --R)
        I.fullMessageLength[R] += v[1], v[1] = v[0] + (I.fullMessageLength[R] / 4294967296 >>> 0), I.fullMessageLength[R] = I.fullMessageLength[R] >>> 0, v[0] = v[1] / 4294967296 >>> 0;
      return m.putBytes(c), l(y, p, m), (m.read > 2048 || m.length() === 0) && m.compact(), I;
    }, I.digest = function() {
      var c = t.util.createBuffer();
      c.putBytes(m.bytes());
      var E = I.fullMessageLength[I.fullMessageLength.length - 1] + I.messageLengthSize, v = E & I.blockLength - 1;
      c.putBytes(n.substr(0, I.blockLength - v));
      for (var R, N, C = I.fullMessageLength[0] * 8, h = 0; h < I.fullMessageLength.length - 1; ++h)
        R = I.fullMessageLength[h + 1] * 8, N = R / 4294967296 >>> 0, C += N, c.putInt32(C >>> 0), C = R >>> 0;
      c.putInt32(C);
      for (var d = new Array(y.length), h = 0; h < y.length; ++h)
        d[h] = y[h].slice(0);
      l(d, p, c);
      var O = t.util.createBuffer(), P;
      u === "SHA-512" ? P = d.length : u === "SHA-384" ? P = d.length - 2 : P = d.length - 4;
      for (var h = 0; h < P; ++h)
        O.putInt32(d[h][0]), (h !== P - 1 || u !== "SHA-512/224") && O.putInt32(d[h][1]);
      return O;
    }, I;
  };
  var n = null, i = !1, a = null, s = null;
  function o() {
    n = "", n += t.util.fillString("\0", 128), a = [
      [1116352408, 3609767458],
      [1899447441, 602891725],
      [3049323471, 3964484399],
      [3921009573, 2173295548],
      [961987163, 4081628472],
      [1508970993, 3053834265],
      [2453635748, 2937671579],
      [2870763221, 3664609560],
      [3624381080, 2734883394],
      [310598401, 1164996542],
      [607225278, 1323610764],
      [1426881987, 3590304994],
      [1925078388, 4068182383],
      [2162078206, 991336113],
      [2614888103, 633803317],
      [3248222580, 3479774868],
      [3835390401, 2666613458],
      [4022224774, 944711139],
      [264347078, 2341262773],
      [604807628, 2007800933],
      [770255983, 1495990901],
      [1249150122, 1856431235],
      [1555081692, 3175218132],
      [1996064986, 2198950837],
      [2554220882, 3999719339],
      [2821834349, 766784016],
      [2952996808, 2566594879],
      [3210313671, 3203337956],
      [3336571891, 1034457026],
      [3584528711, 2466948901],
      [113926993, 3758326383],
      [338241895, 168717936],
      [666307205, 1188179964],
      [773529912, 1546045734],
      [1294757372, 1522805485],
      [1396182291, 2643833823],
      [1695183700, 2343527390],
      [1986661051, 1014477480],
      [2177026350, 1206759142],
      [2456956037, 344077627],
      [2730485921, 1290863460],
      [2820302411, 3158454273],
      [3259730800, 3505952657],
      [3345764771, 106217008],
      [3516065817, 3606008344],
      [3600352804, 1432725776],
      [4094571909, 1467031594],
      [275423344, 851169720],
      [430227734, 3100823752],
      [506948616, 1363258195],
      [659060556, 3750685593],
      [883997877, 3785050280],
      [958139571, 3318307427],
      [1322822218, 3812723403],
      [1537002063, 2003034995],
      [1747873779, 3602036899],
      [1955562222, 1575990012],
      [2024104815, 1125592928],
      [2227730452, 2716904306],
      [2361852424, 442776044],
      [2428436474, 593698344],
      [2756734187, 3733110249],
      [3204031479, 2999351573],
      [3329325298, 3815920427],
      [3391569614, 3928383900],
      [3515267271, 566280711],
      [3940187606, 3454069534],
      [4118630271, 4000239992],
      [116418474, 1914138554],
      [174292421, 2731055270],
      [289380356, 3203993006],
      [460393269, 320620315],
      [685471733, 587496836],
      [852142971, 1086792851],
      [1017036298, 365543100],
      [1126000580, 2618297676],
      [1288033470, 3409855158],
      [1501505948, 4234509866],
      [1607167915, 987167468],
      [1816402316, 1246189591]
    ], s = {}, s["SHA-512"] = [
      [1779033703, 4089235720],
      [3144134277, 2227873595],
      [1013904242, 4271175723],
      [2773480762, 1595750129],
      [1359893119, 2917565137],
      [2600822924, 725511199],
      [528734635, 4215389547],
      [1541459225, 327033209]
    ], s["SHA-384"] = [
      [3418070365, 3238371032],
      [1654270250, 914150663],
      [2438529370, 812702999],
      [355462360, 4144912697],
      [1731405415, 4290775857],
      [2394180231, 1750603025],
      [3675008525, 1694076839],
      [1203062813, 3204075428]
    ], s["SHA-512/256"] = [
      [573645204, 4230739756],
      [2673172387, 3360449730],
      [596883563, 1867755857],
      [2520282905, 1497426621],
      [2519219938, 2827943907],
      [3193839141, 1401305490],
      [721525244, 746961066],
      [246885852, 2177182882]
    ], s["SHA-512/224"] = [
      [2352822216, 424955298],
      [1944164710, 2312950998],
      [502970286, 855612546],
      [1738396948, 1479516111],
      [258812777, 2077511080],
      [2011393907, 79989058],
      [1067287976, 1780299464],
      [286451373, 2446758561]
    ], i = !0;
  }
  function l(u, f, y) {
    for (var m, p, S, A, I, c, E, v, R, N, C, h, d, O, P, L, D, V, $, K, Q, ee, ne, ae, se, me, ye, Se, te, Ce, fe, De, _e, w, b, T = y.length(); T >= 128; ) {
      for (te = 0; te < 16; ++te)
        f[te][0] = y.getInt32() >>> 0, f[te][1] = y.getInt32() >>> 0;
      for (; te < 80; ++te)
        De = f[te - 2], Ce = De[0], fe = De[1], m = ((Ce >>> 19 | fe << 13) ^ // ROTR 19
        (fe >>> 29 | Ce << 3) ^ // ROTR 61/(swap + ROTR 29)
        Ce >>> 6) >>> 0, p = ((Ce << 13 | fe >>> 19) ^ // ROTR 19
        (fe << 3 | Ce >>> 29) ^ // ROTR 61/(swap + ROTR 29)
        (Ce << 26 | fe >>> 6)) >>> 0, w = f[te - 15], Ce = w[0], fe = w[1], S = ((Ce >>> 1 | fe << 31) ^ // ROTR 1
        (Ce >>> 8 | fe << 24) ^ // ROTR 8
        Ce >>> 7) >>> 0, A = ((Ce << 31 | fe >>> 1) ^ // ROTR 1
        (Ce << 24 | fe >>> 8) ^ // ROTR 8
        (Ce << 25 | fe >>> 7)) >>> 0, _e = f[te - 7], b = f[te - 16], fe = p + _e[1] + A + b[1], f[te][0] = m + _e[0] + S + b[0] + (fe / 4294967296 >>> 0) >>> 0, f[te][1] = fe >>> 0;
      for (d = u[0][0], O = u[0][1], P = u[1][0], L = u[1][1], D = u[2][0], V = u[2][1], $ = u[3][0], K = u[3][1], Q = u[4][0], ee = u[4][1], ne = u[5][0], ae = u[5][1], se = u[6][0], me = u[6][1], ye = u[7][0], Se = u[7][1], te = 0; te < 80; ++te)
        E = ((Q >>> 14 | ee << 18) ^ // ROTR 14
        (Q >>> 18 | ee << 14) ^ // ROTR 18
        (ee >>> 9 | Q << 23)) >>> 0, v = ((Q << 18 | ee >>> 14) ^ // ROTR 14
        (Q << 14 | ee >>> 18) ^ // ROTR 18
        (ee << 23 | Q >>> 9)) >>> 0, R = (se ^ Q & (ne ^ se)) >>> 0, N = (me ^ ee & (ae ^ me)) >>> 0, I = ((d >>> 28 | O << 4) ^ // ROTR 28
        (O >>> 2 | d << 30) ^ // ROTR 34/(swap + ROTR 2)
        (O >>> 7 | d << 25)) >>> 0, c = ((d << 4 | O >>> 28) ^ // ROTR 28
        (O << 30 | d >>> 2) ^ // ROTR 34/(swap + ROTR 2)
        (O << 25 | d >>> 7)) >>> 0, C = (d & P | D & (d ^ P)) >>> 0, h = (O & L | V & (O ^ L)) >>> 0, fe = Se + v + N + a[te][1] + f[te][1], m = ye + E + R + a[te][0] + f[te][0] + (fe / 4294967296 >>> 0) >>> 0, p = fe >>> 0, fe = c + h, S = I + C + (fe / 4294967296 >>> 0) >>> 0, A = fe >>> 0, ye = se, Se = me, se = ne, me = ae, ne = Q, ae = ee, fe = K + p, Q = $ + m + (fe / 4294967296 >>> 0) >>> 0, ee = fe >>> 0, $ = D, K = V, D = P, V = L, P = d, L = O, fe = p + A, d = m + S + (fe / 4294967296 >>> 0) >>> 0, O = fe >>> 0;
      fe = u[0][1] + O, u[0][0] = u[0][0] + d + (fe / 4294967296 >>> 0) >>> 0, u[0][1] = fe >>> 0, fe = u[1][1] + L, u[1][0] = u[1][0] + P + (fe / 4294967296 >>> 0) >>> 0, u[1][1] = fe >>> 0, fe = u[2][1] + V, u[2][0] = u[2][0] + D + (fe / 4294967296 >>> 0) >>> 0, u[2][1] = fe >>> 0, fe = u[3][1] + K, u[3][0] = u[3][0] + $ + (fe / 4294967296 >>> 0) >>> 0, u[3][1] = fe >>> 0, fe = u[4][1] + ee, u[4][0] = u[4][0] + Q + (fe / 4294967296 >>> 0) >>> 0, u[4][1] = fe >>> 0, fe = u[5][1] + ae, u[5][0] = u[5][0] + ne + (fe / 4294967296 >>> 0) >>> 0, u[5][1] = fe >>> 0, fe = u[6][1] + me, u[6][0] = u[6][0] + se + (fe / 4294967296 >>> 0) >>> 0, u[6][1] = fe >>> 0, fe = u[7][1] + Se, u[7][0] = u[7][0] + ye + (fe / 4294967296 >>> 0) >>> 0, u[7][1] = fe >>> 0, T -= 128;
    }
  }
  return _u.exports;
}
var ts = {}, gp;
function WI() {
  if (gp) return ts;
  gp = 1;
  var t = Pe();
  Wr();
  var e = t.asn1;
  return ts.privateKeyValidator = {
    // PrivateKeyInfo
    name: "PrivateKeyInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // Version (INTEGER)
      name: "PrivateKeyInfo.version",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyVersion"
    }, {
      // privateKeyAlgorithm
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.OID,
        constructed: !1,
        capture: "privateKeyOid"
      }]
    }, {
      // PrivateKey
      name: "PrivateKeyInfo",
      tagClass: e.Class.UNIVERSAL,
      type: e.Type.OCTETSTRING,
      constructed: !1,
      capture: "privateKey"
    }]
  }, ts.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: e.Class.UNIVERSAL,
    type: e.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "subjectPublicKeyInfo",
    value: [
      {
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: e.Class.UNIVERSAL,
          type: e.Type.OID,
          constructed: !1,
          capture: "publicKeyOid"
        }]
      },
      // capture group for ed25519PublicKey
      {
        tagClass: e.Class.UNIVERSAL,
        type: e.Type.BITSTRING,
        constructed: !1,
        composed: !0,
        captureBitStringValue: "ed25519PublicKey"
      }
      // FIXME: this is capture group for rsaPublicKey, use it in this API or
      // discard?
      /* {
        // subjectPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: 'rsaPublicKey'
        }]
      } */
    ]
  }, ts;
}
var Su, yp;
function JI() {
  if (yp) return Su;
  yp = 1;
  var t = Pe();
  ko(), Pr(), Ny(), $e();
  var e = WI(), r = e.publicKeyValidator, n = e.privateKeyValidator;
  if (typeof i > "u")
    var i = t.jsbn.BigInteger;
  var a = t.util.ByteBuffer, s = typeof Buffer > "u" ? Uint8Array : Buffer;
  t.pki = t.pki || {}, Su = t.pki.ed25519 = t.ed25519 = t.ed25519 || {};
  var o = t.ed25519;
  o.constants = {}, o.constants.PUBLIC_KEY_BYTE_LENGTH = 32, o.constants.PRIVATE_KEY_BYTE_LENGTH = 64, o.constants.SEED_BYTE_LENGTH = 32, o.constants.SIGN_BYTE_LENGTH = 64, o.constants.HASH_BYTE_LENGTH = 64, o.generateKeyPair = function(w) {
    w = w || {};
    var b = w.seed;
    if (b === void 0)
      b = t.random.getBytesSync(o.constants.SEED_BYTE_LENGTH);
    else if (typeof b == "string") {
      if (b.length !== o.constants.SEED_BYTE_LENGTH)
        throw new TypeError(
          '"seed" must be ' + o.constants.SEED_BYTE_LENGTH + " bytes in length."
        );
    } else if (!(b instanceof Uint8Array))
      throw new TypeError(
        '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
      );
    b = l({ message: b, encoding: "binary" });
    for (var T = new s(o.constants.PUBLIC_KEY_BYTE_LENGTH), g = new s(o.constants.PRIVATE_KEY_BYTE_LENGTH), x = 0; x < 32; ++x)
      g[x] = b[x];
    return E(T, g), { publicKey: T, privateKey: g };
  }, o.privateKeyFromAsn1 = function(w) {
    var b = {}, T = [], g = t.asn1.validate(w, n, b, T);
    if (!g) {
      var x = new Error("Invalid Key.");
      throw x.errors = T, x;
    }
    var U = t.asn1.derToOid(b.privateKeyOid), k = t.oids.EdDSA25519;
    if (U !== k)
      throw new Error('Invalid OID "' + U + '"; OID must be "' + k + '".');
    var W = b.privateKey, q = l({
      message: t.asn1.fromDer(W).value,
      encoding: "binary"
    });
    return { privateKeyBytes: q };
  }, o.publicKeyFromAsn1 = function(w) {
    var b = {}, T = [], g = t.asn1.validate(w, r, b, T);
    if (!g) {
      var x = new Error("Invalid Key.");
      throw x.errors = T, x;
    }
    var U = t.asn1.derToOid(b.publicKeyOid), k = t.oids.EdDSA25519;
    if (U !== k)
      throw new Error('Invalid OID "' + U + '"; OID must be "' + k + '".');
    var W = b.ed25519PublicKey;
    if (W.length !== o.constants.PUBLIC_KEY_BYTE_LENGTH)
      throw new Error("Key length is invalid.");
    return l({
      message: W,
      encoding: "binary"
    });
  }, o.publicKeyFromPrivateKey = function(w) {
    w = w || {};
    var b = l({
      message: w.privateKey,
      encoding: "binary"
    });
    if (b.length !== o.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.privateKey" must have a byte length of ' + o.constants.PRIVATE_KEY_BYTE_LENGTH
      );
    for (var T = new s(o.constants.PUBLIC_KEY_BYTE_LENGTH), g = 0; g < T.length; ++g)
      T[g] = b[32 + g];
    return T;
  }, o.sign = function(w) {
    w = w || {};
    var b = l(w), T = l({
      message: w.privateKey,
      encoding: "binary"
    });
    if (T.length === o.constants.SEED_BYTE_LENGTH) {
      var g = o.generateKeyPair({ seed: T });
      T = g.privateKey;
    } else if (T.length !== o.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.privateKey" must have a byte length of ' + o.constants.SEED_BYTE_LENGTH + " or " + o.constants.PRIVATE_KEY_BYTE_LENGTH
      );
    var x = new s(
      o.constants.SIGN_BYTE_LENGTH + b.length
    );
    v(x, b, b.length, T);
    for (var U = new s(o.constants.SIGN_BYTE_LENGTH), k = 0; k < U.length; ++k)
      U[k] = x[k];
    return U;
  }, o.verify = function(w) {
    w = w || {};
    var b = l(w);
    if (w.signature === void 0)
      throw new TypeError(
        '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
      );
    var T = l({
      message: w.signature,
      encoding: "binary"
    });
    if (T.length !== o.constants.SIGN_BYTE_LENGTH)
      throw new TypeError(
        '"options.signature" must have a byte length of ' + o.constants.SIGN_BYTE_LENGTH
      );
    var g = l({
      message: w.publicKey,
      encoding: "binary"
    });
    if (g.length !== o.constants.PUBLIC_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.publicKey" must have a byte length of ' + o.constants.PUBLIC_KEY_BYTE_LENGTH
      );
    var x = new s(o.constants.SIGN_BYTE_LENGTH + b.length), U = new s(o.constants.SIGN_BYTE_LENGTH + b.length), k;
    for (k = 0; k < o.constants.SIGN_BYTE_LENGTH; ++k)
      x[k] = T[k];
    for (k = 0; k < b.length; ++k)
      x[k + o.constants.SIGN_BYTE_LENGTH] = b[k];
    return R(U, x, x.length, g) >= 0;
  };
  function l(w) {
    var b = w.message;
    if (b instanceof Uint8Array || b instanceof s)
      return b;
    var T = w.encoding;
    if (b === void 0)
      if (w.md)
        b = w.md.digest().getBytes(), T = "binary";
      else
        throw new TypeError('"options.message" or "options.md" not specified.');
    if (typeof b == "string" && !T)
      throw new TypeError('"options.encoding" must be "binary" or "utf8".');
    if (typeof b == "string") {
      if (typeof Buffer < "u")
        return Buffer.from(b, T);
      b = new a(b, T);
    } else if (!(b instanceof a))
      throw new TypeError(
        '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
      );
    for (var g = new s(b.length()), x = 0; x < g.length; ++x)
      g[x] = b.at(x);
    return g;
  }
  var u = te(), f = te([1]), y = te([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), m = te([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), p = te([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), S = te([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), A = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]), I = te([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function c(w, b) {
    var T = t.md.sha512.create(), g = new a(w);
    T.update(g.getBytes(b), "binary");
    var x = T.digest().getBytes();
    if (typeof Buffer < "u")
      return Buffer.from(x, "binary");
    for (var U = new s(o.constants.HASH_BYTE_LENGTH), k = 0; k < 64; ++k)
      U[k] = x.charCodeAt(k);
    return U;
  }
  function E(w, b) {
    var T = [te(), te(), te(), te()], g, x = c(b, 32);
    for (x[0] &= 248, x[31] &= 127, x[31] |= 64, ae(T, x), O(w, T), g = 0; g < 32; ++g)
      b[g + 32] = w[g];
    return 0;
  }
  function v(w, b, T, g) {
    var x, U, k = new Float64Array(64), W = [te(), te(), te(), te()], q = c(g, 32);
    q[0] &= 248, q[31] &= 127, q[31] |= 64;
    var z = T + 64;
    for (x = 0; x < T; ++x)
      w[64 + x] = b[x];
    for (x = 0; x < 32; ++x)
      w[32 + x] = q[32 + x];
    var j = c(w.subarray(32), T + 32);
    for (C(j), ae(W, j), O(w, W), x = 32; x < 64; ++x)
      w[x] = g[x];
    var Y = c(w, T + 64);
    for (C(Y), x = 32; x < 64; ++x)
      k[x] = 0;
    for (x = 0; x < 32; ++x)
      k[x] = j[x];
    for (x = 0; x < 32; ++x)
      for (U = 0; U < 32; U++)
        k[x + U] += Y[x] * q[U];
    return N(w.subarray(32), k), z;
  }
  function R(w, b, T, g) {
    var x, U, k = new s(32), W = [te(), te(), te(), te()], q = [te(), te(), te(), te()];
    if (U = -1, T < 64 || L(q, g))
      return -1;
    for (x = 0; x < T; ++x)
      w[x] = b[x];
    for (x = 0; x < 32; ++x)
      w[x + 32] = g[x];
    var z = c(w, T);
    if (C(z), ne(W, q, z), ae(q, b.subarray(32)), h(W, q), O(k, W), T -= 64, K(b, 0, k, 0)) {
      for (x = 0; x < T; ++x)
        w[x] = 0;
      return -1;
    }
    for (x = 0; x < T; ++x)
      w[x] = b[x + 64];
    return U = T, U;
  }
  function N(w, b) {
    var T, g, x, U;
    for (g = 63; g >= 32; --g) {
      for (T = 0, x = g - 32, U = g - 12; x < U; ++x)
        b[x] += T - 16 * b[g] * A[x - (g - 32)], T = b[x] + 128 >> 8, b[x] -= T * 256;
      b[x] += T, b[g] = 0;
    }
    for (T = 0, x = 0; x < 32; ++x)
      b[x] += T - (b[31] >> 4) * A[x], T = b[x] >> 8, b[x] &= 255;
    for (x = 0; x < 32; ++x)
      b[x] -= T * A[x];
    for (g = 0; g < 32; ++g)
      b[g + 1] += b[g] >> 8, w[g] = b[g] & 255;
  }
  function C(w) {
    for (var b = new Float64Array(64), T = 0; T < 64; ++T)
      b[T] = w[T], w[T] = 0;
    N(w, b);
  }
  function h(w, b) {
    var T = te(), g = te(), x = te(), U = te(), k = te(), W = te(), q = te(), z = te(), j = te();
    fe(T, w[1], w[0]), fe(j, b[1], b[0]), _e(T, T, j), Ce(g, w[0], w[1]), Ce(j, b[0], b[1]), _e(g, g, j), _e(x, w[3], b[3]), _e(x, x, m), _e(U, w[2], b[2]), Ce(U, U, U), fe(k, g, T), fe(W, U, x), Ce(q, U, x), Ce(z, g, T), _e(w[0], k, W), _e(w[1], z, q), _e(w[2], q, W), _e(w[3], k, z);
  }
  function d(w, b, T) {
    for (var g = 0; g < 4; ++g)
      Se(w[g], b[g], T);
  }
  function O(w, b) {
    var T = te(), g = te(), x = te();
    me(x, b[2]), _e(T, b[0], x), _e(g, b[1], x), P(w, g), w[31] ^= ee(T) << 7;
  }
  function P(w, b) {
    var T, g, x, U = te(), k = te();
    for (T = 0; T < 16; ++T)
      k[T] = b[T];
    for (ye(k), ye(k), ye(k), g = 0; g < 2; ++g) {
      for (U[0] = k[0] - 65517, T = 1; T < 15; ++T)
        U[T] = k[T] - 65535 - (U[T - 1] >> 16 & 1), U[T - 1] &= 65535;
      U[15] = k[15] - 32767 - (U[14] >> 16 & 1), x = U[15] >> 16 & 1, U[14] &= 65535, Se(k, U, 1 - x);
    }
    for (T = 0; T < 16; T++)
      w[2 * T] = k[T] & 255, w[2 * T + 1] = k[T] >> 8;
  }
  function L(w, b) {
    var T = te(), g = te(), x = te(), U = te(), k = te(), W = te(), q = te();
    return se(w[2], f), D(w[1], b), De(x, w[1]), _e(U, x, y), fe(x, x, w[2]), Ce(U, w[2], U), De(k, U), De(W, k), _e(q, W, k), _e(T, q, x), _e(T, T, U), V(T, T), _e(T, T, x), _e(T, T, U), _e(T, T, U), _e(w[0], T, U), De(g, w[0]), _e(g, g, U), $(g, x) && _e(w[0], w[0], I), De(g, w[0]), _e(g, g, U), $(g, x) ? -1 : (ee(w[0]) === b[31] >> 7 && fe(w[0], u, w[0]), _e(w[3], w[0], w[1]), 0);
  }
  function D(w, b) {
    var T;
    for (T = 0; T < 16; ++T)
      w[T] = b[2 * T] + (b[2 * T + 1] << 8);
    w[15] &= 32767;
  }
  function V(w, b) {
    var T = te(), g;
    for (g = 0; g < 16; ++g)
      T[g] = b[g];
    for (g = 250; g >= 0; --g)
      De(T, T), g !== 1 && _e(T, T, b);
    for (g = 0; g < 16; ++g)
      w[g] = T[g];
  }
  function $(w, b) {
    var T = new s(32), g = new s(32);
    return P(T, w), P(g, b), K(T, 0, g, 0);
  }
  function K(w, b, T, g) {
    return Q(w, b, T, g, 32);
  }
  function Q(w, b, T, g, x) {
    var U, k = 0;
    for (U = 0; U < x; ++U)
      k |= w[b + U] ^ T[g + U];
    return (1 & k - 1 >>> 8) - 1;
  }
  function ee(w) {
    var b = new s(32);
    return P(b, w), b[0] & 1;
  }
  function ne(w, b, T) {
    var g, x;
    for (se(w[0], u), se(w[1], f), se(w[2], f), se(w[3], u), x = 255; x >= 0; --x)
      g = T[x / 8 | 0] >> (x & 7) & 1, d(w, b, g), h(b, w), h(w, w), d(w, b, g);
  }
  function ae(w, b) {
    var T = [te(), te(), te(), te()];
    se(T[0], p), se(T[1], S), se(T[2], f), _e(T[3], p, S), ne(w, T, b);
  }
  function se(w, b) {
    var T;
    for (T = 0; T < 16; T++)
      w[T] = b[T] | 0;
  }
  function me(w, b) {
    var T = te(), g;
    for (g = 0; g < 16; ++g)
      T[g] = b[g];
    for (g = 253; g >= 0; --g)
      De(T, T), g !== 2 && g !== 4 && _e(T, T, b);
    for (g = 0; g < 16; ++g)
      w[g] = T[g];
  }
  function ye(w) {
    var b, T, g = 1;
    for (b = 0; b < 16; ++b)
      T = w[b] + g + 65535, g = Math.floor(T / 65536), w[b] = T - g * 65536;
    w[0] += g - 1 + 37 * (g - 1);
  }
  function Se(w, b, T) {
    for (var g, x = ~(T - 1), U = 0; U < 16; ++U)
      g = x & (w[U] ^ b[U]), w[U] ^= g, b[U] ^= g;
  }
  function te(w) {
    var b, T = new Float64Array(16);
    if (w)
      for (b = 0; b < w.length; ++b)
        T[b] = w[b];
    return T;
  }
  function Ce(w, b, T) {
    for (var g = 0; g < 16; ++g)
      w[g] = b[g] + T[g];
  }
  function fe(w, b, T) {
    for (var g = 0; g < 16; ++g)
      w[g] = b[g] - T[g];
  }
  function De(w, b) {
    _e(w, b, b);
  }
  function _e(w, b, T) {
    var g, x, U = 0, k = 0, W = 0, q = 0, z = 0, j = 0, Y = 0, M = 0, X = 0, J = 0, Z = 0, oe = 0, he = 0, Ee = 0, be = 0, Re = 0, ze = 0, nt = 0, it = 0, je = 0, Ze = 0, qe = 0, He = 0, ke = 0, Pt = 0, nr = 0, ur = 0, _r = 0, lr = 0, xn = 0, oi = 0, ht = T[0], pt = T[1], gt = T[2], ct = T[3], ut = T[4], Xe = T[5], yt = T[6], mt = T[7], Et = T[8], vt = T[9], At = T[10], We = T[11], et = T[12], lt = T[13], Ct = T[14], _t = T[15];
    g = b[0], U += g * ht, k += g * pt, W += g * gt, q += g * ct, z += g * ut, j += g * Xe, Y += g * yt, M += g * mt, X += g * Et, J += g * vt, Z += g * At, oe += g * We, he += g * et, Ee += g * lt, be += g * Ct, Re += g * _t, g = b[1], k += g * ht, W += g * pt, q += g * gt, z += g * ct, j += g * ut, Y += g * Xe, M += g * yt, X += g * mt, J += g * Et, Z += g * vt, oe += g * At, he += g * We, Ee += g * et, be += g * lt, Re += g * Ct, ze += g * _t, g = b[2], W += g * ht, q += g * pt, z += g * gt, j += g * ct, Y += g * ut, M += g * Xe, X += g * yt, J += g * mt, Z += g * Et, oe += g * vt, he += g * At, Ee += g * We, be += g * et, Re += g * lt, ze += g * Ct, nt += g * _t, g = b[3], q += g * ht, z += g * pt, j += g * gt, Y += g * ct, M += g * ut, X += g * Xe, J += g * yt, Z += g * mt, oe += g * Et, he += g * vt, Ee += g * At, be += g * We, Re += g * et, ze += g * lt, nt += g * Ct, it += g * _t, g = b[4], z += g * ht, j += g * pt, Y += g * gt, M += g * ct, X += g * ut, J += g * Xe, Z += g * yt, oe += g * mt, he += g * Et, Ee += g * vt, be += g * At, Re += g * We, ze += g * et, nt += g * lt, it += g * Ct, je += g * _t, g = b[5], j += g * ht, Y += g * pt, M += g * gt, X += g * ct, J += g * ut, Z += g * Xe, oe += g * yt, he += g * mt, Ee += g * Et, be += g * vt, Re += g * At, ze += g * We, nt += g * et, it += g * lt, je += g * Ct, Ze += g * _t, g = b[6], Y += g * ht, M += g * pt, X += g * gt, J += g * ct, Z += g * ut, oe += g * Xe, he += g * yt, Ee += g * mt, be += g * Et, Re += g * vt, ze += g * At, nt += g * We, it += g * et, je += g * lt, Ze += g * Ct, qe += g * _t, g = b[7], M += g * ht, X += g * pt, J += g * gt, Z += g * ct, oe += g * ut, he += g * Xe, Ee += g * yt, be += g * mt, Re += g * Et, ze += g * vt, nt += g * At, it += g * We, je += g * et, Ze += g * lt, qe += g * Ct, He += g * _t, g = b[8], X += g * ht, J += g * pt, Z += g * gt, oe += g * ct, he += g * ut, Ee += g * Xe, be += g * yt, Re += g * mt, ze += g * Et, nt += g * vt, it += g * At, je += g * We, Ze += g * et, qe += g * lt, He += g * Ct, ke += g * _t, g = b[9], J += g * ht, Z += g * pt, oe += g * gt, he += g * ct, Ee += g * ut, be += g * Xe, Re += g * yt, ze += g * mt, nt += g * Et, it += g * vt, je += g * At, Ze += g * We, qe += g * et, He += g * lt, ke += g * Ct, Pt += g * _t, g = b[10], Z += g * ht, oe += g * pt, he += g * gt, Ee += g * ct, be += g * ut, Re += g * Xe, ze += g * yt, nt += g * mt, it += g * Et, je += g * vt, Ze += g * At, qe += g * We, He += g * et, ke += g * lt, Pt += g * Ct, nr += g * _t, g = b[11], oe += g * ht, he += g * pt, Ee += g * gt, be += g * ct, Re += g * ut, ze += g * Xe, nt += g * yt, it += g * mt, je += g * Et, Ze += g * vt, qe += g * At, He += g * We, ke += g * et, Pt += g * lt, nr += g * Ct, ur += g * _t, g = b[12], he += g * ht, Ee += g * pt, be += g * gt, Re += g * ct, ze += g * ut, nt += g * Xe, it += g * yt, je += g * mt, Ze += g * Et, qe += g * vt, He += g * At, ke += g * We, Pt += g * et, nr += g * lt, ur += g * Ct, _r += g * _t, g = b[13], Ee += g * ht, be += g * pt, Re += g * gt, ze += g * ct, nt += g * ut, it += g * Xe, je += g * yt, Ze += g * mt, qe += g * Et, He += g * vt, ke += g * At, Pt += g * We, nr += g * et, ur += g * lt, _r += g * Ct, lr += g * _t, g = b[14], be += g * ht, Re += g * pt, ze += g * gt, nt += g * ct, it += g * ut, je += g * Xe, Ze += g * yt, qe += g * mt, He += g * Et, ke += g * vt, Pt += g * At, nr += g * We, ur += g * et, _r += g * lt, lr += g * Ct, xn += g * _t, g = b[15], Re += g * ht, ze += g * pt, nt += g * gt, it += g * ct, je += g * ut, Ze += g * Xe, qe += g * yt, He += g * mt, ke += g * Et, Pt += g * vt, nr += g * At, ur += g * We, _r += g * et, lr += g * lt, xn += g * Ct, oi += g * _t, U += 38 * ze, k += 38 * nt, W += 38 * it, q += 38 * je, z += 38 * Ze, j += 38 * qe, Y += 38 * He, M += 38 * ke, X += 38 * Pt, J += 38 * nr, Z += 38 * ur, oe += 38 * _r, he += 38 * lr, Ee += 38 * xn, be += 38 * oi, x = 1, g = U + x + 65535, x = Math.floor(g / 65536), U = g - x * 65536, g = k + x + 65535, x = Math.floor(g / 65536), k = g - x * 65536, g = W + x + 65535, x = Math.floor(g / 65536), W = g - x * 65536, g = q + x + 65535, x = Math.floor(g / 65536), q = g - x * 65536, g = z + x + 65535, x = Math.floor(g / 65536), z = g - x * 65536, g = j + x + 65535, x = Math.floor(g / 65536), j = g - x * 65536, g = Y + x + 65535, x = Math.floor(g / 65536), Y = g - x * 65536, g = M + x + 65535, x = Math.floor(g / 65536), M = g - x * 65536, g = X + x + 65535, x = Math.floor(g / 65536), X = g - x * 65536, g = J + x + 65535, x = Math.floor(g / 65536), J = g - x * 65536, g = Z + x + 65535, x = Math.floor(g / 65536), Z = g - x * 65536, g = oe + x + 65535, x = Math.floor(g / 65536), oe = g - x * 65536, g = he + x + 65535, x = Math.floor(g / 65536), he = g - x * 65536, g = Ee + x + 65535, x = Math.floor(g / 65536), Ee = g - x * 65536, g = be + x + 65535, x = Math.floor(g / 65536), be = g - x * 65536, g = Re + x + 65535, x = Math.floor(g / 65536), Re = g - x * 65536, U += x - 1 + 37 * (x - 1), x = 1, g = U + x + 65535, x = Math.floor(g / 65536), U = g - x * 65536, g = k + x + 65535, x = Math.floor(g / 65536), k = g - x * 65536, g = W + x + 65535, x = Math.floor(g / 65536), W = g - x * 65536, g = q + x + 65535, x = Math.floor(g / 65536), q = g - x * 65536, g = z + x + 65535, x = Math.floor(g / 65536), z = g - x * 65536, g = j + x + 65535, x = Math.floor(g / 65536), j = g - x * 65536, g = Y + x + 65535, x = Math.floor(g / 65536), Y = g - x * 65536, g = M + x + 65535, x = Math.floor(g / 65536), M = g - x * 65536, g = X + x + 65535, x = Math.floor(g / 65536), X = g - x * 65536, g = J + x + 65535, x = Math.floor(g / 65536), J = g - x * 65536, g = Z + x + 65535, x = Math.floor(g / 65536), Z = g - x * 65536, g = oe + x + 65535, x = Math.floor(g / 65536), oe = g - x * 65536, g = he + x + 65535, x = Math.floor(g / 65536), he = g - x * 65536, g = Ee + x + 65535, x = Math.floor(g / 65536), Ee = g - x * 65536, g = be + x + 65535, x = Math.floor(g / 65536), be = g - x * 65536, g = Re + x + 65535, x = Math.floor(g / 65536), Re = g - x * 65536, U += x - 1 + 37 * (x - 1), w[0] = U, w[1] = k, w[2] = W, w[3] = q, w[4] = z, w[5] = j, w[6] = Y, w[7] = M, w[8] = X, w[9] = J, w[10] = Z, w[11] = oe, w[12] = he, w[13] = Ee, w[14] = be, w[15] = Re;
  }
  return Su;
}
var Iu, mp;
function zI() {
  if (mp) return Iu;
  mp = 1;
  var t = Pe();
  $e(), Pr(), ko(), Iu = t.kem = t.kem || {};
  var e = t.jsbn.BigInteger;
  t.kem.rsa = {}, t.kem.rsa.create = function(n, i) {
    i = i || {};
    var a = i.prng || t.random, s = {};
    return s.encrypt = function(o, l) {
      var u = Math.ceil(o.n.bitLength() / 8), f;
      do
        f = new e(
          t.util.bytesToHex(a.getBytesSync(u)),
          16
        ).mod(o.n);
      while (f.compareTo(e.ONE) <= 0);
      f = t.util.hexToBytes(f.toString(16));
      var y = u - f.length;
      y > 0 && (f = t.util.fillString("\0", y) + f);
      var m = o.encrypt(f, "NONE"), p = n.generate(f, l);
      return { encapsulation: m, key: p };
    }, s.decrypt = function(o, l, u) {
      var f = o.decrypt(l, "NONE");
      return n.generate(f, u);
    }, s;
  }, t.kem.kdf1 = function(n, i) {
    r(this, n, 0, i || n.digestLength);
  }, t.kem.kdf2 = function(n, i) {
    r(this, n, 1, i || n.digestLength);
  };
  function r(n, i, a, s) {
    n.generate = function(o, l) {
      for (var u = new t.util.ByteBuffer(), f = Math.ceil(l / s) + a, y = new t.util.ByteBuffer(), m = a; m < f; ++m) {
        y.putInt32(m), i.start(), i.update(o + y.getBytes());
        var p = i.digest();
        u.putBytes(p.getBytes(s));
      }
      return u.truncate(u.length() - l), u.getBytes();
    };
  }
  return Iu;
}
var bu, Ep;
function XI() {
  if (Ep) return bu;
  Ep = 1;
  var t = Pe();
  $e(), bu = t.log = t.log || {}, t.log.levels = [
    "none",
    "error",
    "warning",
    "info",
    "debug",
    "verbose",
    "max"
  ];
  var e = {}, r = [], n = null;
  t.log.LEVEL_LOCKED = 2, t.log.NO_LEVEL_CHECK = 4, t.log.INTERPOLATE = 8;
  for (var i = 0; i < t.log.levels.length; ++i) {
    var a = t.log.levels[i];
    e[a] = {
      index: i,
      name: a.toUpperCase()
    };
  }
  t.log.logMessage = function(m) {
    for (var p = e[m.level].index, S = 0; S < r.length; ++S) {
      var A = r[S];
      if (A.flags & t.log.NO_LEVEL_CHECK)
        A.f(m);
      else {
        var I = e[A.level].index;
        p <= I && A.f(A, m);
      }
    }
  }, t.log.prepareStandard = function(m) {
    "standard" in m || (m.standard = e[m.level].name + //' ' + +message.timestamp +
    " [" + m.category + "] " + m.message);
  }, t.log.prepareFull = function(m) {
    if (!("full" in m)) {
      var p = [m.message];
      p = p.concat([]), m.full = t.util.format.apply(this, p);
    }
  }, t.log.prepareStandardFull = function(m) {
    "standardFull" in m || (t.log.prepareStandard(m), m.standardFull = m.standard);
  };
  for (var s = ["error", "warning", "info", "debug", "verbose"], i = 0; i < s.length; ++i)
    (function(p) {
      t.log[p] = function(S, A) {
        var I = Array.prototype.slice.call(arguments).slice(2), c = {
          timestamp: /* @__PURE__ */ new Date(),
          level: p,
          category: S,
          message: A,
          arguments: I
          /*standard*/
          /*full*/
          /*fullMessage*/
        };
        t.log.logMessage(c);
      };
    })(s[i]);
  if (t.log.makeLogger = function(m) {
    var p = {
      flags: 0,
      f: m
    };
    return t.log.setLevel(p, "none"), p;
  }, t.log.setLevel = function(m, p) {
    var S = !1;
    if (m && !(m.flags & t.log.LEVEL_LOCKED))
      for (var A = 0; A < t.log.levels.length; ++A) {
        var I = t.log.levels[A];
        if (p == I) {
          m.level = p, S = !0;
          break;
        }
      }
    return S;
  }, t.log.lock = function(m, p) {
    typeof p > "u" || p ? m.flags |= t.log.LEVEL_LOCKED : m.flags &= ~t.log.LEVEL_LOCKED;
  }, t.log.addLogger = function(m) {
    r.push(m);
  }, typeof console < "u" && "log" in console) {
    var o;
    if (console.error && console.warn && console.info && console.debug) {
      var l = {
        error: console.error,
        warning: console.warn,
        info: console.info,
        debug: console.debug,
        verbose: console.debug
      }, u = function(m, p) {
        t.log.prepareStandard(p);
        var S = l[p.level], A = [p.standard];
        A = A.concat(p.arguments.slice()), S.apply(console, A);
      };
      o = t.log.makeLogger(u);
    } else {
      var u = function(p, S) {
        t.log.prepareStandardFull(S), console.log(S.standardFull);
      };
      o = t.log.makeLogger(u);
    }
    t.log.setLevel(o, "debug"), t.log.addLogger(o), n = o;
  } else
    console = {
      log: function() {
      }
    };
  if (n !== null && typeof window < "u" && window.location) {
    var f = new URL(window.location.href).searchParams;
    if (f.has("console.level") && t.log.setLevel(
      n,
      f.get("console.level").slice(-1)[0]
    ), f.has("console.lock")) {
      var y = f.get("console.lock").slice(-1)[0];
      y == "true" && t.log.lock(n);
    }
  }
  return t.log.consoleLogger = n, bu;
}
var wu, vp;
function YI() {
  return vp || (vp = 1, wu = dn(), wf(), Da(), Ey(), Ny()), wu;
}
var Tu = { exports: {} }, Ap;
function QI() {
  if (Ap) return Tu.exports;
  Ap = 1;
  var t = Pe();
  ni(), Wr(), Po(), ii(), Vi(), Iy(), Pr(), $e(), Nf();
  var e = t.asn1, r = Tu.exports = t.pkcs7 = t.pkcs7 || {};
  r.messageFromPem = function(p) {
    var S = t.pem.decode(p)[0];
    if (S.type !== "PKCS7") {
      var A = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
      throw A.headerType = S.type, A;
    }
    if (S.procType && S.procType.type === "ENCRYPTED")
      throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
    var I = e.fromDer(S.body);
    return r.messageFromAsn1(I);
  }, r.messageToPem = function(p, S) {
    var A = {
      type: "PKCS7",
      body: e.toDer(p.toAsn1()).getBytes()
    };
    return t.pem.encode(A, { maxline: S });
  }, r.messageFromAsn1 = function(p) {
    var S = {}, A = [];
    if (!e.validate(p, r.asn1.contentInfoValidator, S, A)) {
      var I = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
      throw I.errors = A, I;
    }
    var c = e.derToOid(S.contentType), E;
    switch (c) {
      case t.pki.oids.envelopedData:
        E = r.createEnvelopedData();
        break;
      case t.pki.oids.encryptedData:
        E = r.createEncryptedData();
        break;
      case t.pki.oids.signedData:
        E = r.createSignedData();
        break;
      default:
        throw new Error("Cannot read PKCS#7 message. ContentType with OID " + c + " is not (yet) supported.");
    }
    return E.fromAsn1(S.content.value[0]), E;
  }, r.createSignedData = function() {
    var p = null;
    return p = {
      type: t.pki.oids.signedData,
      version: 1,
      certificates: [],
      crls: [],
      // TODO: add json-formatted signer stuff here?
      signers: [],
      // populated during sign()
      digestAlgorithmIdentifiers: [],
      contentInfo: null,
      signerInfos: [],
      fromAsn1: function(I) {
        if (y(p, I, r.asn1.signedDataValidator), p.certificates = [], p.crls = [], p.digestAlgorithmIdentifiers = [], p.contentInfo = null, p.signerInfos = [], p.rawCapture.certificates)
          for (var c = p.rawCapture.certificates.value, E = 0; E < c.length; ++E)
            p.certificates.push(t.pki.certificateFromAsn1(c[E]));
      },
      toAsn1: function() {
        p.contentInfo || p.sign();
        for (var I = [], c = 0; c < p.certificates.length; ++c)
          I.push(t.pki.certificateToAsn1(p.certificates[c]));
        var E = [], v = e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            // Version
            e.create(
              e.Class.UNIVERSAL,
              e.Type.INTEGER,
              !1,
              e.integerToDer(p.version).getBytes()
            ),
            // DigestAlgorithmIdentifiers
            e.create(
              e.Class.UNIVERSAL,
              e.Type.SET,
              !0,
              p.digestAlgorithmIdentifiers
            ),
            // ContentInfo
            p.contentInfo
          ])
        ]);
        return I.length > 0 && v.value[0].value.push(
          e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, I)
        ), E.length > 0 && v.value[0].value.push(
          e.create(e.Class.CONTEXT_SPECIFIC, 1, !0, E)
        ), v.value[0].value.push(
          e.create(
            e.Class.UNIVERSAL,
            e.Type.SET,
            !0,
            p.signerInfos
          )
        ), e.create(
          e.Class.UNIVERSAL,
          e.Type.SEQUENCE,
          !0,
          [
            // ContentType
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(p.type).getBytes()
            ),
            // [0] SignedData
            v
          ]
        );
      },
      /**
       * Add (another) entity to list of signers.
       *
       * Note: If authenticatedAttributes are provided, then, per RFC 2315,
       * they must include at least two attributes: content type and
       * message digest. The message digest attribute value will be
       * auto-calculated during signing and will be ignored if provided.
       *
       * Here's an example of providing these two attributes:
       *
       * forge.pkcs7.createSignedData();
       * p7.addSigner({
       *   issuer: cert.issuer.attributes,
       *   serialNumber: cert.serialNumber,
       *   key: privateKey,
       *   digestAlgorithm: forge.pki.oids.sha1,
       *   authenticatedAttributes: [{
       *     type: forge.pki.oids.contentType,
       *     value: forge.pki.oids.data
       *   }, {
       *     type: forge.pki.oids.messageDigest
       *   }]
       * });
       *
       * TODO: Support [subjectKeyIdentifier] as signer's ID.
       *
       * @param signer the signer information:
       *          key the signer's private key.
       *          [certificate] a certificate containing the public key
       *            associated with the signer's private key; use this option as
       *            an alternative to specifying signer.issuer and
       *            signer.serialNumber.
       *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
       *          [serialNumber] the signer's certificate's serial number in
       *           hexadecimal (eg: cert.serialNumber).
       *          [digestAlgorithm] the message digest OID, as a string, to use
       *            (eg: forge.pki.oids.sha1).
       *          [authenticatedAttributes] an optional array of attributes
       *            to also sign along with the content.
       */
      addSigner: function(I) {
        var c = I.issuer, E = I.serialNumber;
        if (I.certificate) {
          var v = I.certificate;
          typeof v == "string" && (v = t.pki.certificateFromPem(v)), c = v.issuer.attributes, E = v.serialNumber;
        }
        var R = I.key;
        if (!R)
          throw new Error(
            "Could not add PKCS#7 signer; no private key specified."
          );
        typeof R == "string" && (R = t.pki.privateKeyFromPem(R));
        var N = I.digestAlgorithm || t.pki.oids.sha1;
        switch (N) {
          case t.pki.oids.sha1:
          case t.pki.oids.sha256:
          case t.pki.oids.sha384:
          case t.pki.oids.sha512:
          case t.pki.oids.md5:
            break;
          default:
            throw new Error(
              "Could not add PKCS#7 signer; unknown message digest algorithm: " + N
            );
        }
        var C = I.authenticatedAttributes || [];
        if (C.length > 0) {
          for (var h = !1, d = !1, O = 0; O < C.length; ++O) {
            var P = C[O];
            if (!h && P.type === t.pki.oids.contentType) {
              if (h = !0, d)
                break;
              continue;
            }
            if (!d && P.type === t.pki.oids.messageDigest) {
              if (d = !0, h)
                break;
              continue;
            }
          }
          if (!h || !d)
            throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
        }
        p.signers.push({
          key: R,
          version: 1,
          issuer: c,
          serialNumber: E,
          digestAlgorithm: N,
          signatureAlgorithm: t.pki.oids.rsaEncryption,
          signature: null,
          authenticatedAttributes: C,
          unauthenticatedAttributes: []
        });
      },
      /**
       * Signs the content.
       * @param options Options to apply when signing:
       *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
       */
      sign: function(I) {
        if (I = I || {}, (typeof p.content != "object" || p.contentInfo === null) && (p.contentInfo = e.create(
          e.Class.UNIVERSAL,
          e.Type.SEQUENCE,
          !0,
          [
            // ContentType
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(t.pki.oids.data).getBytes()
            )
          ]
        ), "content" in p)) {
          var c;
          p.content instanceof t.util.ByteBuffer ? c = p.content.bytes() : typeof p.content == "string" && (c = t.util.encodeUtf8(p.content)), I.detached ? p.detachedContent = e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, !1, c) : p.contentInfo.value.push(
            // [0] EXPLICIT content
            e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
              e.create(
                e.Class.UNIVERSAL,
                e.Type.OCTETSTRING,
                !1,
                c
              )
            ])
          );
        }
        if (p.signers.length !== 0) {
          var E = S();
          A(E);
        }
      },
      verify: function() {
        throw new Error("PKCS#7 signature verification not yet implemented.");
      },
      /**
       * Add a certificate.
       *
       * @param cert the certificate to add.
       */
      addCertificate: function(I) {
        typeof I == "string" && (I = t.pki.certificateFromPem(I)), p.certificates.push(I);
      },
      /**
       * Add a certificate revokation list.
       *
       * @param crl the certificate revokation list to add.
       */
      addCertificateRevokationList: function(I) {
        throw new Error("PKCS#7 CRL support not yet implemented.");
      }
    }, p;
    function S() {
      for (var I = {}, c = 0; c < p.signers.length; ++c) {
        var E = p.signers[c], v = E.digestAlgorithm;
        v in I || (I[v] = t.md[t.pki.oids[v]].create()), E.authenticatedAttributes.length === 0 ? E.md = I[v] : E.md = t.md[t.pki.oids[v]].create();
      }
      p.digestAlgorithmIdentifiers = [];
      for (var v in I)
        p.digestAlgorithmIdentifiers.push(
          // AlgorithmIdentifier
          e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
            // algorithm
            e.create(
              e.Class.UNIVERSAL,
              e.Type.OID,
              !1,
              e.oidToDer(v).getBytes()
            ),
            // parameters (null)
            e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
          ])
        );
      return I;
    }
    function A(I) {
      var c;
      if (p.detachedContent ? c = p.detachedContent : (c = p.contentInfo.value[1], c = c.value[0]), !c)
        throw new Error(
          "Could not sign PKCS#7 message; there is no content to sign."
        );
      var E = e.derToOid(p.contentInfo.value[0].value), v = e.toDer(c);
      v.getByte(), e.getBerValueLength(v), v = v.getBytes();
      for (var R in I)
        I[R].start().update(v);
      for (var N = /* @__PURE__ */ new Date(), C = 0; C < p.signers.length; ++C) {
        var h = p.signers[C];
        if (h.authenticatedAttributes.length === 0) {
          if (E !== t.pki.oids.data)
            throw new Error(
              "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
            );
        } else {
          h.authenticatedAttributesAsn1 = e.create(
            e.Class.CONTEXT_SPECIFIC,
            0,
            !0,
            []
          );
          for (var d = e.create(
            e.Class.UNIVERSAL,
            e.Type.SET,
            !0,
            []
          ), O = 0; O < h.authenticatedAttributes.length; ++O) {
            var P = h.authenticatedAttributes[O];
            P.type === t.pki.oids.messageDigest ? P.value = I[h.digestAlgorithm].digest() : P.type === t.pki.oids.signingTime && (P.value || (P.value = N)), d.value.push(u(P)), h.authenticatedAttributesAsn1.value.push(u(P));
          }
          v = e.toDer(d).getBytes(), h.md.start().update(v);
        }
        h.signature = h.key.sign(h.md, "RSASSA-PKCS1-V1_5");
      }
      p.signerInfos = l(p.signers);
    }
  }, r.createEncryptedData = function() {
    var p = null;
    return p = {
      type: t.pki.oids.encryptedData,
      version: 0,
      encryptedContent: {
        algorithm: t.pki.oids["aes256-CBC"]
      },
      /**
       * Reads an EncryptedData content block (in ASN.1 format)
       *
       * @param obj The ASN.1 representation of the EncryptedData content block
       */
      fromAsn1: function(S) {
        y(p, S, r.asn1.encryptedDataValidator);
      },
      /**
       * Decrypt encrypted content
       *
       * @param key The (symmetric) key as a byte buffer
       */
      decrypt: function(S) {
        S !== void 0 && (p.encryptedContent.key = S), m(p);
      }
    }, p;
  }, r.createEnvelopedData = function() {
    var p = null;
    return p = {
      type: t.pki.oids.envelopedData,
      version: 0,
      recipients: [],
      encryptedContent: {
        algorithm: t.pki.oids["aes256-CBC"]
      },
      /**
       * Reads an EnvelopedData content block (in ASN.1 format)
       *
       * @param obj the ASN.1 representation of the EnvelopedData content block.
       */
      fromAsn1: function(S) {
        var A = y(p, S, r.asn1.envelopedDataValidator);
        p.recipients = a(A.recipientInfos.value);
      },
      toAsn1: function() {
        return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
          // ContentType
          e.create(
            e.Class.UNIVERSAL,
            e.Type.OID,
            !1,
            e.oidToDer(p.type).getBytes()
          ),
          // [0] EnvelopedData
          e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
            e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
              // Version
              e.create(
                e.Class.UNIVERSAL,
                e.Type.INTEGER,
                !1,
                e.integerToDer(p.version).getBytes()
              ),
              // RecipientInfos
              e.create(
                e.Class.UNIVERSAL,
                e.Type.SET,
                !0,
                s(p.recipients)
              ),
              // EncryptedContentInfo
              e.create(
                e.Class.UNIVERSAL,
                e.Type.SEQUENCE,
                !0,
                f(p.encryptedContent)
              )
            ])
          ])
        ]);
      },
      /**
       * Find recipient by X.509 certificate's issuer.
       *
       * @param cert the certificate with the issuer to look for.
       *
       * @return the recipient object.
       */
      findRecipient: function(S) {
        for (var A = S.issuer.attributes, I = 0; I < p.recipients.length; ++I) {
          var c = p.recipients[I], E = c.issuer;
          if (c.serialNumber === S.serialNumber && E.length === A.length) {
            for (var v = !0, R = 0; R < A.length; ++R)
              if (E[R].type !== A[R].type || E[R].value !== A[R].value) {
                v = !1;
                break;
              }
            if (v)
              return c;
          }
        }
        return null;
      },
      /**
       * Decrypt enveloped content
       *
       * @param recipient The recipient object related to the private key
       * @param privKey The (RSA) private key object
       */
      decrypt: function(S, A) {
        if (p.encryptedContent.key === void 0 && S !== void 0 && A !== void 0)
          switch (S.encryptedContent.algorithm) {
            case t.pki.oids.rsaEncryption:
            case t.pki.oids.desCBC:
              var I = A.decrypt(S.encryptedContent.content);
              p.encryptedContent.key = t.util.createBuffer(I);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + S.encryptedContent.algorithm);
          }
        m(p);
      },
      /**
       * Add (another) entity to list of recipients.
       *
       * @param cert The certificate of the entity to add.
       */
      addRecipient: function(S) {
        p.recipients.push({
          version: 0,
          issuer: S.issuer.attributes,
          serialNumber: S.serialNumber,
          encryptedContent: {
            // We simply assume rsaEncryption here, since forge.pki only
            // supports RSA so far.  If the PKI module supports other
            // ciphers one day, we need to modify this one as well.
            algorithm: t.pki.oids.rsaEncryption,
            key: S.publicKey
          }
        });
      },
      /**
       * Encrypt enveloped content.
       *
       * This function supports two optional arguments, cipher and key, which
       * can be used to influence symmetric encryption.  Unless cipher is
       * provided, the cipher specified in encryptedContent.algorithm is used
       * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
       * is (re-)used.  If that one's not set, a random key will be generated
       * automatically.
       *
       * @param [key] The key to be used for symmetric encryption.
       * @param [cipher] The OID of the symmetric cipher to use.
       */
      encrypt: function(S, A) {
        if (p.encryptedContent.content === void 0) {
          A = A || p.encryptedContent.algorithm, S = S || p.encryptedContent.key;
          var I, c, E;
          switch (A) {
            case t.pki.oids["aes128-CBC"]:
              I = 16, c = 16, E = t.aes.createEncryptionCipher;
              break;
            case t.pki.oids["aes192-CBC"]:
              I = 24, c = 16, E = t.aes.createEncryptionCipher;
              break;
            case t.pki.oids["aes256-CBC"]:
              I = 32, c = 16, E = t.aes.createEncryptionCipher;
              break;
            case t.pki.oids["des-EDE3-CBC"]:
              I = 24, c = 8, E = t.des.createEncryptionCipher;
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + A);
          }
          if (S === void 0)
            S = t.util.createBuffer(t.random.getBytes(I));
          else if (S.length() != I)
            throw new Error("Symmetric key has wrong length; got " + S.length() + " bytes, expected " + I + ".");
          p.encryptedContent.algorithm = A, p.encryptedContent.key = S, p.encryptedContent.parameter = t.util.createBuffer(
            t.random.getBytes(c)
          );
          var v = E(S);
          if (v.start(p.encryptedContent.parameter.copy()), v.update(p.content), !v.finish())
            throw new Error("Symmetric encryption failed.");
          p.encryptedContent.content = v.output;
        }
        for (var R = 0; R < p.recipients.length; ++R) {
          var N = p.recipients[R];
          if (N.encryptedContent.content === void 0)
            switch (N.encryptedContent.algorithm) {
              case t.pki.oids.rsaEncryption:
                N.encryptedContent.content = N.encryptedContent.key.encrypt(
                  p.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + N.encryptedContent.algorithm);
            }
        }
      }
    }, p;
  };
  function n(p) {
    var S = {}, A = [];
    if (!e.validate(p, r.asn1.recipientInfoValidator, S, A)) {
      var I = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
      throw I.errors = A, I;
    }
    return {
      version: S.version.charCodeAt(0),
      issuer: t.pki.RDNAttributesAsArray(S.issuer),
      serialNumber: t.util.createBuffer(S.serial).toHex(),
      encryptedContent: {
        algorithm: e.derToOid(S.encAlgorithm),
        parameter: S.encParameter ? S.encParameter.value : void 0,
        content: S.encKey
      }
    };
  }
  function i(p) {
    return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // Version
      e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        e.integerToDer(p.version).getBytes()
      ),
      // IssuerAndSerialNumber
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // Name
        t.pki.distinguishedNameToAsn1({ attributes: p.issuer }),
        // Serial
        e.create(
          e.Class.UNIVERSAL,
          e.Type.INTEGER,
          !1,
          t.util.hexToBytes(p.serialNumber)
        )
      ]),
      // KeyEncryptionAlgorithmIdentifier
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // Algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(p.encryptedContent.algorithm).getBytes()
        ),
        // Parameter, force NULL, only RSA supported for now.
        e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
      ]),
      // EncryptedKey
      e.create(
        e.Class.UNIVERSAL,
        e.Type.OCTETSTRING,
        !1,
        p.encryptedContent.content
      )
    ]);
  }
  function a(p) {
    for (var S = [], A = 0; A < p.length; ++A)
      S.push(n(p[A]));
    return S;
  }
  function s(p) {
    for (var S = [], A = 0; A < p.length; ++A)
      S.push(i(p[A]));
    return S;
  }
  function o(p) {
    var S = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // version
      e.create(
        e.Class.UNIVERSAL,
        e.Type.INTEGER,
        !1,
        e.integerToDer(p.version).getBytes()
      ),
      // issuerAndSerialNumber
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // name
        t.pki.distinguishedNameToAsn1({ attributes: p.issuer }),
        // serial
        e.create(
          e.Class.UNIVERSAL,
          e.Type.INTEGER,
          !1,
          t.util.hexToBytes(p.serialNumber)
        )
      ]),
      // digestAlgorithm
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(p.digestAlgorithm).getBytes()
        ),
        // parameters (null)
        e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
      ])
    ]);
    if (p.authenticatedAttributesAsn1 && S.value.push(p.authenticatedAttributesAsn1), S.value.push(e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // algorithm
      e.create(
        e.Class.UNIVERSAL,
        e.Type.OID,
        !1,
        e.oidToDer(p.signatureAlgorithm).getBytes()
      ),
      // parameters (null)
      e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")
    ])), S.value.push(e.create(
      e.Class.UNIVERSAL,
      e.Type.OCTETSTRING,
      !1,
      p.signature
    )), p.unauthenticatedAttributes.length > 0) {
      for (var A = e.create(e.Class.CONTEXT_SPECIFIC, 1, !0, []), I = 0; I < p.unauthenticatedAttributes.length; ++I) {
        var c = p.unauthenticatedAttributes[I];
        A.values.push(u(c));
      }
      S.value.push(A);
    }
    return S;
  }
  function l(p) {
    for (var S = [], A = 0; A < p.length; ++A)
      S.push(o(p[A]));
    return S;
  }
  function u(p) {
    var S;
    if (p.type === t.pki.oids.contentType)
      S = e.create(
        e.Class.UNIVERSAL,
        e.Type.OID,
        !1,
        e.oidToDer(p.value).getBytes()
      );
    else if (p.type === t.pki.oids.messageDigest)
      S = e.create(
        e.Class.UNIVERSAL,
        e.Type.OCTETSTRING,
        !1,
        p.value.bytes()
      );
    else if (p.type === t.pki.oids.signingTime) {
      var A = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), I = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), c = p.value;
      if (typeof c == "string") {
        var E = Date.parse(c);
        isNaN(E) ? c.length === 13 ? c = e.utcTimeToDate(c) : c = e.generalizedTimeToDate(c) : c = new Date(E);
      }
      c >= A && c < I ? S = e.create(
        e.Class.UNIVERSAL,
        e.Type.UTCTIME,
        !1,
        e.dateToUtcTime(c)
      ) : S = e.create(
        e.Class.UNIVERSAL,
        e.Type.GENERALIZEDTIME,
        !1,
        e.dateToGeneralizedTime(c)
      );
    }
    return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
      // AttributeType
      e.create(
        e.Class.UNIVERSAL,
        e.Type.OID,
        !1,
        e.oidToDer(p.type).getBytes()
      ),
      e.create(e.Class.UNIVERSAL, e.Type.SET, !0, [
        // AttributeValue
        S
      ])
    ]);
  }
  function f(p) {
    return [
      // ContentType, always Data for the moment
      e.create(
        e.Class.UNIVERSAL,
        e.Type.OID,
        !1,
        e.oidToDer(t.pki.oids.data).getBytes()
      ),
      // ContentEncryptionAlgorithmIdentifier
      e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [
        // Algorithm
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OID,
          !1,
          e.oidToDer(p.algorithm).getBytes()
        ),
        // Parameters (IV)
        p.parameter ? e.create(
          e.Class.UNIVERSAL,
          e.Type.OCTETSTRING,
          !1,
          p.parameter.getBytes()
        ) : void 0
      ]),
      // [0] EncryptedContent
      e.create(e.Class.CONTEXT_SPECIFIC, 0, !0, [
        e.create(
          e.Class.UNIVERSAL,
          e.Type.OCTETSTRING,
          !1,
          p.content.getBytes()
        )
      ])
    ];
  }
  function y(p, S, A) {
    var I = {}, c = [];
    if (!e.validate(S, A, I, c)) {
      var E = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
      throw E.errors = E, E;
    }
    var v = e.derToOid(I.contentType);
    if (v !== t.pki.oids.data)
      throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
    if (I.encryptedContent) {
      var R = "";
      if (t.util.isArray(I.encryptedContent))
        for (var N = 0; N < I.encryptedContent.length; ++N) {
          if (I.encryptedContent[N].type !== e.Type.OCTETSTRING)
            throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
          R += I.encryptedContent[N].value;
        }
      else
        R = I.encryptedContent;
      p.encryptedContent = {
        algorithm: e.derToOid(I.encAlgorithm),
        parameter: t.util.createBuffer(I.encParameter.value),
        content: t.util.createBuffer(R)
      };
    }
    if (I.content) {
      var R = "";
      if (t.util.isArray(I.content))
        for (var N = 0; N < I.content.length; ++N) {
          if (I.content[N].type !== e.Type.OCTETSTRING)
            throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
          R += I.content[N].value;
        }
      else
        R = I.content;
      p.content = t.util.createBuffer(R);
    }
    return p.version = I.version.charCodeAt(0), p.rawCapture = I, I;
  }
  function m(p) {
    if (p.encryptedContent.key === void 0)
      throw new Error("Symmetric key not available.");
    if (p.content === void 0) {
      var S;
      switch (p.encryptedContent.algorithm) {
        case t.pki.oids["aes128-CBC"]:
        case t.pki.oids["aes192-CBC"]:
        case t.pki.oids["aes256-CBC"]:
          S = t.aes.createDecryptionCipher(p.encryptedContent.key);
          break;
        case t.pki.oids.desCBC:
        case t.pki.oids["des-EDE3-CBC"]:
          S = t.des.createDecryptionCipher(p.encryptedContent.key);
          break;
        default:
          throw new Error("Unsupported symmetric cipher, OID " + p.encryptedContent.algorithm);
      }
      if (S.start(p.encryptedContent.parameter), S.update(p.encryptedContent.content), !S.finish())
        throw new Error("Symmetric decryption failed.");
      p.content = S.output;
    }
  }
  return Tu.exports;
}
var Ru = { exports: {} }, Cp;
function ZI() {
  if (Cp) return Ru.exports;
  Cp = 1;
  var t = Pe();
  ni(), Oa(), wf(), Da(), $e();
  var e = Ru.exports = t.ssh = t.ssh || {};
  e.privateKeyToPutty = function(a, s, o) {
    o = o || "", s = s || "";
    var l = "ssh-rsa", u = s === "" ? "none" : "aes256-cbc", f = "PuTTY-User-Key-File-2: " + l + `\r
`;
    f += "Encryption: " + u + `\r
`, f += "Comment: " + o + `\r
`;
    var y = t.util.createBuffer();
    n(y, l), r(y, a.e), r(y, a.n);
    var m = t.util.encode64(y.bytes(), 64), p = Math.floor(m.length / 66) + 1;
    f += "Public-Lines: " + p + `\r
`, f += m;
    var S = t.util.createBuffer();
    r(S, a.d), r(S, a.p), r(S, a.q), r(S, a.qInv);
    var A;
    if (!s)
      A = t.util.encode64(S.bytes(), 64);
    else {
      var I = S.length() + 16 - 1;
      I -= I % 16;
      var c = i(S.bytes());
      c.truncate(c.length() - I + S.length()), S.putBuffer(c);
      var E = t.util.createBuffer();
      E.putBuffer(i("\0\0\0\0", s)), E.putBuffer(i("\0\0\0", s));
      var v = t.aes.createEncryptionCipher(E.truncate(8), "CBC");
      v.start(t.util.createBuffer().fillWithByte(0, 16)), v.update(S.copy()), v.finish();
      var R = v.output;
      R.truncate(16), A = t.util.encode64(R.bytes(), 64);
    }
    p = Math.floor(A.length / 66) + 1, f += `\r
Private-Lines: ` + p + `\r
`, f += A;
    var N = i("putty-private-key-file-mac-key", s), C = t.util.createBuffer();
    n(C, l), n(C, u), n(C, o), C.putInt32(y.length()), C.putBuffer(y), C.putInt32(S.length()), C.putBuffer(S);
    var h = t.hmac.create();
    return h.start("sha1", N), h.update(C.bytes()), f += `\r
Private-MAC: ` + h.digest().toHex() + `\r
`, f;
  }, e.publicKeyToOpenSSH = function(a, s) {
    var o = "ssh-rsa";
    s = s || "";
    var l = t.util.createBuffer();
    return n(l, o), r(l, a.e), r(l, a.n), o + " " + t.util.encode64(l.bytes()) + " " + s;
  }, e.privateKeyToOpenSSH = function(a, s) {
    return s ? t.pki.encryptRsaPrivateKey(
      a,
      s,
      { legacy: !0, algorithm: "aes128" }
    ) : t.pki.privateKeyToPem(a);
  }, e.getPublicKeyFingerprint = function(a, s) {
    s = s || {};
    var o = s.md || t.md.md5.create(), l = "ssh-rsa", u = t.util.createBuffer();
    n(u, l), r(u, a.e), r(u, a.n), o.start(), o.update(u.getBytes());
    var f = o.digest();
    if (s.encoding === "hex") {
      var y = f.toHex();
      return s.delimiter ? y.match(/.{2}/g).join(s.delimiter) : y;
    } else {
      if (s.encoding === "binary")
        return f.getBytes();
      if (s.encoding)
        throw new Error('Unknown encoding "' + s.encoding + '".');
    }
    return f;
  };
  function r(a, s) {
    var o = s.toString(16);
    o[0] >= "8" && (o = "00" + o);
    var l = t.util.hexToBytes(o);
    a.putInt32(l.length), a.putBytes(l);
  }
  function n(a, s) {
    a.putInt32(s.length), a.putString(s);
  }
  function i() {
    for (var a = t.md.sha1.create(), s = arguments.length, o = 0; o < s; ++o)
      a.update(arguments[o]);
    return a.digest();
  }
  return Ru.exports;
}
var Nu, _p;
function eb() {
  return _p || (_p = 1, Nu = Pe(), ni(), qI(), Wr(), bf(), Po(), JI(), Oa(), zI(), XI(), YI(), by(), Tf(), Vi(), Cy(), wy(), QI(), Ty(), _y(), vy(), Rf(), Pr(), Ay(), ZI(), Ry(), $e()), Nu;
}
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.ImpersonatedServiceAccountCredential = Lt.RefreshTokenCredential = Lt.ServiceAccountCredential = Lt.ApplicationDefaultCredential = void 0;
Lt.isApplicationDefault = nb;
Lt.getApplicationDefault = ib;
const xf = ge, Dl = rg, rt = Te, cr = Ue, xy = [
  "https://www.googleapis.com/auth/cloud-platform",
  "https://www.googleapis.com/auth/firebase.database",
  "https://www.googleapis.com/auth/firebase.messaging",
  "https://www.googleapis.com/auth/identitytoolkit",
  "https://www.googleapis.com/auth/userinfo.email"
];
class Of {
  constructor(e) {
    this.googleAuth = new Dl.GoogleAuth({
      scopes: xy,
      clientOptions: {
        transporterOptions: {
          agent: e
        }
      }
    });
  }
  async getAccessToken() {
    this.authClient || (this.authClient = await this.googleAuth.getClient()), await this.authClient.getAccessToken();
    const e = this.authClient.credentials;
    return this.quotaProjectId = this.authClient.quotaProjectId, Uo(e);
  }
  async getProjectId() {
    return this.projectId || (this.projectId = await this.googleAuth.getProjectId()), Promise.resolve(this.projectId);
  }
  getQuotaProjectId() {
    var e;
    return this.quotaProjectId || (this.quotaProjectId = (e = this.authClient) == null ? void 0 : e.quotaProjectId), this.quotaProjectId;
  }
  async isComputeEngineCredential() {
    return this.authClient || (this.authClient = await this.googleAuth.getClient()), Promise.resolve(this.authClient instanceof Dl.Compute);
  }
  /**
   * getIDToken returns a OIDC token from the compute metadata service
   * that can be used to make authenticated calls to audience
   * @param audience the URL the returned ID token will be used to call.
  */
  async getIDToken(e) {
    if (await this.isComputeEngineCredential())
      return this.authClient.fetchIdToken(e);
    throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Credentials type should be Compute Engine Credentials.");
  }
  async getServiceAccountEmail() {
    if (this.accountId)
      return Promise.resolve(this.accountId);
    const { client_email: e } = await this.googleAuth.getCredentials();
    return this.accountId = e ?? "", Promise.resolve(this.accountId);
  }
}
Lt.ApplicationDefaultCredential = Of;
class tb {
  /**
   * Creates a new ServiceAccountCredential from the given parameters.
   *
   * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.
   * @param httpAgent - Optional http.Agent to use when calling the remote token server.
   * @param implicit - An optional boolean indicating whether this credential was implicitly discovered from the
   *   environment, as opposed to being explicitly specified by the developer.
   *
   * @constructor
   */
  constructor(e, r, n = !1) {
    this.serviceAccountPathOrObject = e, this.httpAgent = r, this.implicit = n;
    const i = typeof e == "string" ? Os.fromPath(e) : new Os(e);
    this.projectId = i.projectId, this.privateKey = i.privateKey, this.clientEmail = i.clientEmail;
  }
  getGoogleAuth() {
    if (this.googleAuth)
      return this.googleAuth;
    const { auth: e, client: r } = Df(this.serviceAccountPathOrObject, this.httpAgent);
    return this.googleAuth = e, this.authClient = r, this.googleAuth;
  }
  async getAccessToken() {
    const e = this.getGoogleAuth();
    this.authClient === void 0 && (this.authClient = await e.getClient()), await this.authClient.getAccessToken();
    const r = this.authClient.credentials;
    return Uo(r);
  }
}
Lt.ServiceAccountCredential = tb;
class Os {
  static fromPath(e) {
    try {
      return new Os(JSON.parse(xf.readFileSync(e, "utf8")));
    } catch (r) {
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse service account json file: " + r);
    }
  }
  constructor(e) {
    if (!cr.isNonNullObject(e))
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Service account must be an object.");
    Gr(this, e, "projectId", "project_id"), Gr(this, e, "privateKey", "private_key"), Gr(this, e, "clientEmail", "client_email");
    let r;
    if (cr.isNonEmptyString(this.projectId) ? cr.isNonEmptyString(this.privateKey) ? cr.isNonEmptyString(this.clientEmail) || (r = 'Service account object must contain a string "client_email" property.') : r = 'Service account object must contain a string "private_key" property.' : r = 'Service account object must contain a string "project_id" property.', typeof r < "u")
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, r);
    const n = eb();
    try {
      n.pki.privateKeyFromPem(this.privateKey);
    } catch (i) {
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse private key: " + i);
    }
  }
}
class Oy {
  /**
   * Creates a new RefreshTokenCredential from the given parameters.
   *
   * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token
   *   (user credentials) json file.
   * @param httpAgent - Optional http.Agent to use when calling the remote token server.
   * @param implicit - An optinal boolean indicating whether this credential was implicitly
   *   discovered from the environment, as opposed to being explicitly specified by the developer.
   *
   * @constructor
   */
  constructor(e, r, n = !1) {
    this.refreshTokenPathOrObject = e, this.httpAgent = r, this.implicit = n, typeof e == "string" ? Ds.validateFromPath(e) : Ds.validateFromJSON(e);
  }
  getGoogleAuth() {
    if (this.googleAuth)
      return this.googleAuth;
    const { auth: e, client: r } = Df(this.refreshTokenPathOrObject, this.httpAgent);
    return this.googleAuth = e, this.authClient = r, this.googleAuth;
  }
  async getAccessToken() {
    const e = this.getGoogleAuth();
    this.authClient === void 0 && (this.authClient = await e.getClient()), await this.authClient.getAccessToken();
    const r = this.authClient.credentials;
    return Uo(r);
  }
}
Lt.RefreshTokenCredential = Oy;
class Ds {
  /*
   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the
   * data at the path is invalid.
   */
  static validateFromPath(e) {
    try {
      Ds.validateFromJSON(JSON.parse(xf.readFileSync(e, "utf8")));
    } catch (r) {
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse refresh token file: " + r);
    }
  }
  static validateFromJSON(e) {
    const r = { clientId: "", clientSecret: "", refreshToken: "", type: "" };
    Gr(r, e, "clientId", "client_id"), Gr(r, e, "clientSecret", "client_secret"), Gr(r, e, "refreshToken", "refresh_token"), Gr(r, e, "type", "type");
    let n;
    if (cr.isNonEmptyString(r.clientId) ? cr.isNonEmptyString(r.clientSecret) ? cr.isNonEmptyString(r.refreshToken) ? cr.isNonEmptyString(r.type) || (n = 'Refresh token must contain a "type" property.') : n = 'Refresh token must contain a "refresh_token" property.' : n = 'Refresh token must contain a "client_secret" property.' : n = 'Refresh token must contain a "client_id" property.', typeof n < "u")
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, n);
  }
}
class rb {
  /**
   * Creates a new ImpersonatedServiceAccountCredential from the given parameters.
   *
   * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or
   * path to a service account json file.
   * @param httpAgent - Optional http.Agent to use when calling the remote token server.
   * @param implicit - An optional boolean indicating whether this credential was implicitly
   *   discovered from the environment, as opposed to being explicitly specified by the developer.
   *
   * @constructor
   */
  constructor(e, r, n = !1) {
    this.impersonatedServiceAccountPathOrObject = e, this.httpAgent = r, this.implicit = n, typeof e == "string" ? Ls.validateFromPath(e) : Ls.validateFromJSON(e);
  }
  getGoogleAuth() {
    if (this.googleAuth)
      return this.googleAuth;
    const { auth: e, client: r } = Df(this.impersonatedServiceAccountPathOrObject, this.httpAgent);
    return this.googleAuth = e, this.authClient = r, this.googleAuth;
  }
  async getAccessToken() {
    const e = this.getGoogleAuth();
    this.authClient === void 0 && (this.authClient = await e.getClient()), await this.authClient.getAccessToken();
    const r = this.authClient.credentials;
    return Uo(r);
  }
}
Lt.ImpersonatedServiceAccountCredential = rb;
class Ls {
  /*
   * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the
   * data at the path is invalid.
   */
  static validateFromPath(e) {
    try {
      Ls.validateFromJSON(JSON.parse(xf.readFileSync(e, "utf8")));
    } catch (r) {
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse impersonated service account file: " + r);
    }
  }
  static validateFromJSON(e) {
    const { client_id: r, client_secret: n, refresh_token: i, type: a } = e.source_credentials;
    let s;
    if (cr.isNonEmptyString(r) ? cr.isNonEmptyString(n) ? cr.isNonEmptyString(i) ? cr.isNonEmptyString(a) || (s = 'Impersonated Service Account must contain a "source_credentials.type" property.') : s = 'Impersonated Service Account must contain a "source_credentials.refresh_token" property.' : s = 'Impersonated Service Account must contain a "source_credentials.client_secret" property.' : s = 'Impersonated Service Account must contain a "source_credentials.client_id" property.', typeof s < "u")
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, s);
  }
}
function nb(t) {
  return t instanceof Of || t instanceof Oy && t.implicit;
}
function ib(t) {
  return new Of(t);
}
function Gr(t, e, r, n) {
  const i = e[r] || e[n];
  typeof i < "u" && (t[r] = i);
}
function Df(t, e) {
  let r;
  const n = new Dl.GoogleAuth({
    scopes: xy,
    clientOptions: {
      transporterOptions: {
        agent: e
      }
    },
    keyFile: typeof t == "string" ? t : void 0
  });
  if (typeof t == "object") {
    if (!cr.isNonNullObject(t))
      throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Service account must be an object.");
    Gr(t, t, "project_id", "projectId"), Gr(t, t, "private_key", "privateKey"), Gr(t, t, "client_email", "clientEmail"), r = n.fromJSON(t);
  }
  return { auth: n, client: r };
}
function Uo(t) {
  const e = t == null ? void 0 : t.access_token, r = t == null ? void 0 : t.expiry_date;
  if (typeof e != "string")
    throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse Google auth credential: access_token must be a non empty string.");
  if (typeof r != "number")
    throw new rt.FirebaseAppError(rt.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse Google auth credential: Invalid expiry_date.");
  return {
    ...t,
    access_token: e,
    // inverse operation of following
    // https://github.com/googleapis/google-auth-library-nodejs/blob/5ed910513451c82e2551777a3e2212964799ef8e/src/auth/baseexternalclient.ts#L446-L446
    expires_in: Math.floor((r - (/* @__PURE__ */ new Date()).getTime()) / 1e3)
  };
}
const ab = "13.4.0", sb = {
  version: ab
};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(at, "__esModule", { value: !0 });
at.getSdkVersion = Dy;
at.getMetricsHeader = ob;
at.renameProperties = cb;
at.addReadonlyGetter = ub;
at.getExplicitProjectId = Ly;
at.findProjectId = lb;
at.getExplicitServiceAccountEmail = Py;
at.findServiceAccountEmail = fb;
at.toWebSafeBase64 = db;
at.formatString = hb;
at.generateUpdateMask = ky;
at.transformMillisecondsToSecondsString = pb;
at.parseResourceName = gb;
const Fo = Lt, Ps = Ue;
let xu;
function Dy() {
  if (!xu) {
    const { version: t } = sb;
    xu = t;
  }
  return xu;
}
function ob() {
  return `gl-node/${process.versions.node} fire-admin/${Dy()}`;
}
function cb(t, e) {
  Object.keys(e).forEach((r) => {
    if (r in t) {
      const n = e[r];
      t[n] = t[r], delete t[r];
    }
  });
}
function ub(t, e, r) {
  Object.defineProperty(t, e, {
    value: r,
    // Make this property read-only.
    writable: !1,
    // Include this property during enumeration of obj's properties.
    enumerable: !0
  });
}
function Ly(t) {
  const e = t.options;
  if (Ps.isNonEmptyString(e.projectId))
    return e.projectId;
  const r = t.options.credential;
  if (r instanceof Fo.ServiceAccountCredential)
    return r.projectId;
  const n = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;
  return Ps.isNonEmptyString(n) ? n : null;
}
function lb(t) {
  const e = Ly(t);
  if (e)
    return Promise.resolve(e);
  const r = t.options.credential;
  return r instanceof Fo.ApplicationDefaultCredential ? r.getProjectId() : Promise.resolve(null);
}
function Py(t) {
  const e = t.options;
  if (Ps.isNonEmptyString(e.serviceAccountId))
    return e.serviceAccountId;
  const r = t.options.credential;
  return r instanceof Fo.ServiceAccountCredential ? r.clientEmail : null;
}
function fb(t) {
  const e = Py(t);
  if (e)
    return Promise.resolve(e);
  const r = t.options.credential;
  return r instanceof Fo.ApplicationDefaultCredential ? r.getServiceAccountEmail() : Promise.resolve(null);
}
function db(t) {
  return t.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
}
function hb(t, e) {
  let r = t;
  return Object.keys(e || {}).forEach((n) => {
    r = r.replace(new RegExp("{" + n + "}", "g"), e[n]);
  }), r;
}
function ky(t, e = [], r = "") {
  const n = [];
  if (!Ps.isNonNullObject(t))
    return n;
  for (const i in t)
    if (typeof t[i] < "u") {
      const a = r ? `${r}.${i}` : i;
      if (e.indexOf(a) !== -1)
        n.push(i);
      else {
        const s = ky(t[i], e, a);
        s.length > 0 ? s.forEach((o) => {
          n.push(`${i}.${o}`);
        }) : n.push(i);
      }
    }
  return n;
}
function pb(t) {
  let e;
  const r = Math.floor(t / 1e3), n = Math.floor((t - r * 1e3) * 1e6);
  if (n > 0) {
    let i = n.toString();
    for (; i.length < 9; )
      i = "0" + i;
    e = `${r}.${i}s`;
  } else
    e = `${r}s`;
  return e;
}
function gb(t, e) {
  if (!t.includes("/"))
    return { resourceId: t };
  const n = new RegExp(`^(projects/([^/]+)/)?locations/([^/]+)/${e}/([^/]+)$`).exec(t);
  if (n === null)
    throw new Error("Invalid resource name format.");
  const i = n[2], a = n[3], s = n[4];
  return { projectId: i, locationId: a, resourceId: s };
}
var By = {}, xi = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.FirebaseApp = xi.FirebaseAppInternals = void 0;
const yb = Lt, Uy = Ue, Sp = vr, Hr = Te, mb = 5 * 60 * 1e3;
class Fy {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  constructor(e) {
    this.credential_ = e, this.tokenListeners_ = [], this.isRefreshing = !1;
  }
  getToken(e = !1) {
    return (e || this.shouldRefresh()) && (this.promiseToCachedToken_ = this.refreshToken()), this.promiseToCachedToken_;
  }
  getCachedToken() {
    return this.cachedToken_ || null;
  }
  refreshToken() {
    return this.isRefreshing = !0, Promise.resolve(this.credential_.getAccessToken()).then((e) => {
      if (!Uy.isNonNullObject(e) || typeof e.expires_in != "number" || typeof e.access_token != "string")
        throw new Hr.FirebaseAppError(Hr.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: "${JSON.stringify(e)}". Valid access tokens must be an object with the "expires_in" (number) and "access_token" (string) properties.`);
      const r = {
        accessToken: e.access_token,
        expirationTime: Date.now() + e.expires_in * 1e3
      };
      return (!this.cachedToken_ || this.cachedToken_.accessToken !== r.accessToken || this.cachedToken_.expirationTime !== r.expirationTime) && (this.cachedToken_ = r, this.tokenListeners_.forEach((n) => {
        n(r.accessToken);
      })), r;
    }).catch((e) => {
      let r = typeof e == "string" ? e : e.message;
      throw r = `Credential implementation provided to initializeApp() via the "credential" property failed to fetch a valid Google OAuth2 access token with the following error: "${r}".`, r.indexOf("invalid_grant") !== -1 && (r += " There are two likely causes: (1) your server time is not properly synced or (2) your certificate key file has been revoked. To solve (1), re-sync the time on your server. To solve (2), make sure the key ID for your key file is still present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If not, generate a new key file at https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk."), new Hr.FirebaseAppError(Hr.AppErrorCodes.INVALID_CREDENTIAL, r);
    }).finally(() => {
      this.isRefreshing = !1;
    });
  }
  shouldRefresh() {
    return (!this.cachedToken_ || this.cachedToken_.expirationTime - Date.now() <= mb) && !this.isRefreshing;
  }
  /**
   * Adds a listener that is called each time a token changes.
   *
   * @param listener - The listener that will be called with each new token.
   */
  addAuthTokenListener(e) {
    this.tokenListeners_.push(e), this.cachedToken_ && e(this.cachedToken_.accessToken);
  }
  /**
   * Removes a token listener.
   *
   * @param listener - The listener to remove.
   */
  removeAuthTokenListener(e) {
    this.tokenListeners_ = this.tokenListeners_.filter((r) => r !== e);
  }
}
xi.FirebaseAppInternals = Fy;
class Eb {
  constructor(e, r, n) {
    if (this.appStore = n, this.services_ = {}, this.isDeleted_ = !1, this.name_ = r, this.options_ = (0, Sp.deepCopy)(e), !Uy.isNonNullObject(this.options_))
      throw new Hr.FirebaseAppError(Hr.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". Options must be a non-null object.`);
    "credential" in this.options_ || (this.options_.credential = (0, yb.getApplicationDefault)(this.options_.httpAgent));
    const a = this.options_.credential;
    if (typeof a != "object" || a === null || typeof a.getAccessToken != "function")
      throw new Hr.FirebaseAppError(Hr.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". The "credential" property must be an object which implements the Credential interface.`);
    this.INTERNAL = new Fy(a);
  }
  /**
   * Returns the name of the FirebaseApp instance.
   *
   * @returns The name of the FirebaseApp instance.
   */
  get name() {
    return this.checkDestroyed_(), this.name_;
  }
  /**
   * Returns the options for the FirebaseApp instance.
   *
   * @returns The options for the FirebaseApp instance.
   */
  get options() {
    return this.checkDestroyed_(), (0, Sp.deepCopy)(this.options_);
  }
  /**
   * @internal
   */
  getOrInitService(e, r) {
    return this.ensureService_(e, () => r(this));
  }
  /**
   * Deletes the FirebaseApp instance.
   *
   * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.
   */
  delete() {
    var e;
    return this.checkDestroyed_(), (e = this.appStore) == null || e.removeApp(this.name), Promise.all(Object.keys(this.services_).map((r) => {
      const n = this.services_[r];
      return vb(n) ? n.delete() : Promise.resolve();
    })).then(() => {
      this.services_ = {}, this.isDeleted_ = !0;
    });
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  ensureService_(e, r) {
    return this.checkDestroyed_(), e in this.services_ || (this.services_[e] = r()), this.services_[e];
  }
  /**
   * Throws an Error if the FirebaseApp instance has already been deleted.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  checkDestroyed_() {
    if (this.isDeleted_)
      throw new Hr.FirebaseAppError(Hr.AppErrorCodes.APP_DELETED, `Firebase app named "${this.name_}" has already been deleted.`);
  }
}
xi.FirebaseApp = Eb;
function vb(t) {
  return typeof t.delete == "function";
}
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.FIREBASE_CONFIG_VAR = t.defaultAppStore = t.AppStore = void 0, t.initializeApp = l, t.getApp = u, t.getApps = f, t.deleteApp = y;
  const e = ge, r = Ue, n = Te, i = Lt, a = xi, s = "[DEFAULT]";
  class o {
    constructor() {
      this.appStore = /* @__PURE__ */ new Map();
    }
    initializeApp(S, A = s) {
      if (typeof S > "u" && (S = m(), S.credential = (0, i.getApplicationDefault)()), typeof A != "string" || A === "")
        throw new n.FirebaseAppError(n.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${A}" provided. App name must be a non-empty string.`);
      if (this.appStore.has(A))
        throw A === s ? new n.FirebaseAppError(n.AppErrorCodes.DUPLICATE_APP, "The default Firebase app already exists. This means you called initializeApp() more than once without providing an app name as the second argument. In most cases you only need to call initializeApp() once. But if you do want to initialize multiple apps, pass a second argument to initializeApp() to give each app a unique name.") : new n.FirebaseAppError(n.AppErrorCodes.DUPLICATE_APP, `Firebase app named "${A}" already exists. This means you called initializeApp() more than once with the same app name as the second argument. Make sure you provide a unique name every time you call initializeApp().`);
      const I = new a.FirebaseApp(S, A, this);
      return this.appStore.set(I.name, I), I;
    }
    getApp(S = s) {
      if (typeof S != "string" || S === "")
        throw new n.FirebaseAppError(n.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${S}" provided. App name must be a non-empty string.`);
      if (!this.appStore.has(S)) {
        let A = S === s ? "The default Firebase app does not exist. " : `Firebase app named "${S}" does not exist. `;
        throw A += "Make sure you call initializeApp() before using any of the Firebase services.", new n.FirebaseAppError(n.AppErrorCodes.NO_APP, A);
      }
      return this.appStore.get(S);
    }
    getApps() {
      return Array.from(this.appStore.values());
    }
    deleteApp(S) {
      if (typeof S != "object" || S === null || !("options" in S))
        throw new n.FirebaseAppError(n.AppErrorCodes.INVALID_ARGUMENT, "Invalid app argument.");
      return u(S.name).delete();
    }
    clearAllApps() {
      const S = [];
      return this.getApps().forEach((A) => {
        S.push(this.deleteApp(A));
      }), Promise.all(S).then();
    }
    /**
     * Removes the specified App instance from the store. This is currently called by the
     * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled
     * entirely by the {@link deleteApp} top-level function.
     */
    removeApp(S) {
      this.appStore.delete(S);
    }
  }
  t.AppStore = o, t.defaultAppStore = new o();
  function l(p, S = s) {
    return t.defaultAppStore.initializeApp(p, S);
  }
  function u(p = s) {
    return t.defaultAppStore.getApp(p);
  }
  function f() {
    return t.defaultAppStore.getApps();
  }
  function y(p) {
    return t.defaultAppStore.deleteApp(p);
  }
  t.FIREBASE_CONFIG_VAR = "FIREBASE_CONFIG";
  function m() {
    const p = process.env[t.FIREBASE_CONFIG_VAR];
    if (!r.isNonEmptyString(p))
      return {};
    try {
      const S = p.startsWith("{") ? p : e.readFileSync(p, "utf8");
      return JSON.parse(S);
    } catch (S) {
      throw new n.FirebaseAppError(n.AppErrorCodes.INVALID_APP_OPTIONS, "Failed to parse app options file: " + S);
    }
  }
})(By);
var $i = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty($i, "__esModule", { value: !0 });
$i.applicationDefault = Ab;
$i.cert = Cb;
$i.refreshToken = _b;
$i.clearGlobalAppDefaultCred = Sb;
const Lf = Lt;
let As;
const Ou = {}, Du = {};
function Ab(t) {
  return typeof As > "u" && (As = (0, Lf.getApplicationDefault)(t)), As;
}
function Cb(t, e) {
  const r = JSON.stringify(t);
  return r in Ou || (Ou[r] = new Lf.ServiceAccountCredential(t, e)), Ou[r];
}
function _b(t, e) {
  const r = JSON.stringify(t);
  return r in Du || (Du[r] = new Lf.RefreshTokenCredential(t, e)), Du[r];
}
function Sb() {
  As = void 0;
}
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SDK_VERSION = t.AppErrorCodes = t.FirebaseAppError = t.refreshToken = t.cert = t.applicationDefault = t.deleteApp = t.getApps = t.getApp = t.initializeApp = void 0;
  const e = at;
  var r = By;
  Object.defineProperty(t, "initializeApp", { enumerable: !0, get: function() {
    return r.initializeApp;
  } }), Object.defineProperty(t, "getApp", { enumerable: !0, get: function() {
    return r.getApp;
  } }), Object.defineProperty(t, "getApps", { enumerable: !0, get: function() {
    return r.getApps;
  } }), Object.defineProperty(t, "deleteApp", { enumerable: !0, get: function() {
    return r.deleteApp;
  } });
  var n = $i;
  Object.defineProperty(t, "applicationDefault", { enumerable: !0, get: function() {
    return n.applicationDefault;
  } }), Object.defineProperty(t, "cert", { enumerable: !0, get: function() {
    return n.cert;
  } }), Object.defineProperty(t, "refreshToken", { enumerable: !0, get: function() {
    return n.refreshToken;
  } });
  var i = Te;
  Object.defineProperty(t, "FirebaseAppError", { enumerable: !0, get: function() {
    return i.FirebaseAppError;
  } }), Object.defineProperty(t, "AppErrorCodes", { enumerable: !0, get: function() {
    return i.AppErrorCodes;
  } }), t.SDK_VERSION = (0, e.getSdkVersion)();
})(tg);
var ha = {}, La = {}, tt = {}, gi = { exports: {} }, Lu, Ip;
function My() {
  if (Ip) return Lu;
  Ip = 1;
  const { EventEmitter: t } = ge, { inherits: e } = ge;
  function r(n) {
    if (typeof n == "string" && (n = Buffer.from(n)), !Buffer.isBuffer(n))
      throw new TypeError("The needle has to be a String or a Buffer.");
    const i = n.length, a = i - 1;
    if (i === 0)
      throw new Error("The needle cannot be an empty String/Buffer.");
    if (i > 256)
      throw new Error("The needle cannot have a length bigger than 256.");
    this.maxMatches = 1 / 0, this.matches = 0, this._occ = new Uint8Array(256).fill(i), this._lookbehind_size = 0, this._needle = n, this._bufpos = 0, this._lookbehind = Buffer.alloc(a);
    for (var s = 0; s < a; ++s)
      this._occ[n[s]] = a - s;
  }
  return e(r, t), r.prototype.reset = function() {
    this._lookbehind_size = 0, this.matches = 0, this._bufpos = 0;
  }, r.prototype.push = function(n, i) {
    Buffer.isBuffer(n) || (n = Buffer.from(n, "binary"));
    const a = n.length;
    this._bufpos = i || 0;
    let s;
    for (; s !== a && this.matches < this.maxMatches; )
      s = this._sbmh_feed(n);
    return s;
  }, r.prototype._sbmh_feed = function(n) {
    const i = n.length, a = this._needle, s = a.length, o = s - 1, l = a[o];
    let u = -this._lookbehind_size, f;
    if (u < 0) {
      for (; u < 0 && u <= i - s; ) {
        if (f = n[u + o], f === l && this._sbmh_memcmp(n, u, o))
          return this._lookbehind_size = 0, ++this.matches, this.emit("info", !0), this._bufpos = u + s;
        u += this._occ[f];
      }
      for (; u < 0 && !this._sbmh_memcmp(n, u, i - u); )
        ++u;
      if (u >= 0)
        this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size), this._lookbehind_size = 0;
      else {
        const y = this._lookbehind_size + u;
        return y > 0 && this.emit("info", !1, this._lookbehind, 0, y), this._lookbehind_size -= y, this._lookbehind.copy(this._lookbehind, 0, y, this._lookbehind_size), n.copy(this._lookbehind, this._lookbehind_size), this._lookbehind_size += i, this._bufpos = i, i;
      }
    }
    if (u = n.indexOf(a, u + this._bufpos), u !== -1)
      return ++this.matches, u === 0 ? this.emit("info", !0) : this.emit("info", !0, n, this._bufpos, u), this._bufpos = u + s;
    for (u = i - o, u < 0 && (u = 0); u !== i && (n[u] !== a[0] || Buffer.compare(
      n.subarray(u + 1, i),
      a.subarray(1, i - u)
    ) !== 0); )
      ++u;
    return u !== i && (n.copy(this._lookbehind, 0, u, i), this._lookbehind_size = i - u), u !== 0 && this.emit("info", !1, n, this._bufpos, u), this._bufpos = i, i;
  }, r.prototype._sbmh_lookup_char = function(n, i) {
    return i < 0 ? this._lookbehind[this._lookbehind_size + i] : n[i];
  }, r.prototype._sbmh_memcmp = function(n, i, a) {
    for (var s = 0; s < a; ++s)
      if (this._sbmh_lookup_char(n, i + s) !== this._needle[s])
        return !1;
    return !0;
  }, Lu = r, Lu;
}
var Pu, bp;
function Ib() {
  if (bp) return Pu;
  bp = 1;
  const t = ge.inherits, e = ge.Readable;
  function r(n) {
    e.call(this, n);
  }
  return t(r, e), r.prototype._read = function(n) {
  }, Pu = r, Pu;
}
var ku, wp;
function Pf() {
  return wp || (wp = 1, ku = function(e, r, n) {
    if (!e || e[r] === void 0 || e[r] === null)
      return n;
    if (typeof e[r] != "number" || isNaN(e[r]))
      throw new TypeError("Limit " + r + " is not a valid number");
    return e[r];
  }), ku;
}
var Bu, Tp;
function bb() {
  if (Tp) return Bu;
  Tp = 1;
  const t = ge.EventEmitter, e = ge.inherits, r = Pf(), n = My(), i = Buffer.from(`\r
\r
`), a = /\r\n/g, s = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function o(l) {
    t.call(this), l = l || {};
    const u = this;
    this.nread = 0, this.maxed = !1, this.npairs = 0, this.maxHeaderPairs = r(l, "maxHeaderPairs", 2e3), this.maxHeaderSize = r(l, "maxHeaderSize", 80 * 1024), this.buffer = "", this.header = {}, this.finished = !1, this.ss = new n(i), this.ss.on("info", function(f, y, m, p) {
      y && !u.maxed && (u.nread + p - m >= u.maxHeaderSize ? (p = u.maxHeaderSize - u.nread + m, u.nread = u.maxHeaderSize, u.maxed = !0) : u.nread += p - m, u.buffer += y.toString("binary", m, p)), f && u._finish();
    });
  }
  return e(o, t), o.prototype.push = function(l) {
    const u = this.ss.push(l);
    if (this.finished)
      return u;
  }, o.prototype.reset = function() {
    this.finished = !1, this.buffer = "", this.header = {}, this.ss.reset();
  }, o.prototype._finish = function() {
    this.buffer && this._parseHeader(), this.ss.matches = this.ss.maxMatches;
    const l = this.header;
    this.header = {}, this.buffer = "", this.finished = !0, this.nread = this.npairs = 0, this.maxed = !1, this.emit("header", l);
  }, o.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs)
      return;
    const l = this.buffer.split(a), u = l.length;
    let f, y;
    for (var m = 0; m < u; ++m) {
      if (l[m].length === 0)
        continue;
      if ((l[m][0] === "	" || l[m][0] === " ") && y) {
        this.header[y][this.header[y].length - 1] += l[m];
        continue;
      }
      const p = l[m].indexOf(":");
      if (p === -1 || p === 0)
        return;
      if (f = s.exec(l[m]), y = f[1].toLowerCase(), this.header[y] = this.header[y] || [], this.header[y].push(f[2] || ""), ++this.npairs === this.maxHeaderPairs)
        break;
    }
  }, Bu = o, Bu;
}
var Uu, Rp;
function Vy() {
  if (Rp) return Uu;
  Rp = 1;
  const t = ge.Writable, e = ge.inherits, r = My(), n = Ib(), i = bb(), a = 45, s = Buffer.from("-"), o = Buffer.from(`\r
`), l = function() {
  };
  function u(f) {
    if (!(this instanceof u))
      return new u(f);
    if (t.call(this, f), !f || !f.headerFirst && typeof f.boundary != "string")
      throw new TypeError("Boundary required");
    typeof f.boundary == "string" ? this.setBoundary(f.boundary) : this._bparser = void 0, this._headerFirst = f.headerFirst, this._dashes = 0, this._parts = 0, this._finished = !1, this._realFinish = !1, this._isPreamble = !0, this._justMatched = !1, this._firstWrite = !0, this._inHeader = !0, this._part = void 0, this._cb = void 0, this._ignoreData = !1, this._partOpts = { highWaterMark: f.partHwm }, this._pause = !1;
    const y = this;
    this._hparser = new i(f), this._hparser.on("header", function(m) {
      y._inHeader = !1, y._part.emit("header", m);
    });
  }
  return e(u, t), u.prototype.emit = function(f) {
    if (f === "finish" && !this._realFinish) {
      if (!this._finished) {
        const y = this;
        process.nextTick(function() {
          if (y.emit("error", new Error("Unexpected end of multipart data")), y._part && !y._ignoreData) {
            const m = y._isPreamble ? "Preamble" : "Part";
            y._part.emit("error", new Error(m + " terminated early due to unexpected end of multipart data")), y._part.push(null), process.nextTick(function() {
              y._realFinish = !0, y.emit("finish"), y._realFinish = !1;
            });
            return;
          }
          y._realFinish = !0, y.emit("finish"), y._realFinish = !1;
        });
      }
    } else
      t.prototype.emit.apply(this, arguments);
  }, u.prototype._write = function(f, y, m) {
    if (!this._hparser && !this._bparser)
      return m();
    if (this._headerFirst && this._isPreamble) {
      this._part || (this._part = new n(this._partOpts), this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._ignore());
      const p = this._hparser.push(f);
      if (!this._inHeader && p !== void 0 && p < f.length)
        f = f.slice(p);
      else
        return m();
    }
    this._firstWrite && (this._bparser.push(o), this._firstWrite = !1), this._bparser.push(f), this._pause ? this._cb = m : m();
  }, u.prototype.reset = function() {
    this._part = void 0, this._bparser = void 0, this._hparser = void 0;
  }, u.prototype.setBoundary = function(f) {
    const y = this;
    this._bparser = new r(`\r
--` + f), this._bparser.on("info", function(m, p, S, A) {
      y._oninfo(m, p, S, A);
    });
  }, u.prototype._ignore = function() {
    this._part && !this._ignoreData && (this._ignoreData = !0, this._part.on("error", l), this._part.resume());
  }, u.prototype._oninfo = function(f, y, m, p) {
    let S;
    const A = this;
    let I = 0, c, E = !0;
    if (!this._part && this._justMatched && y) {
      for (; this._dashes < 2 && m + I < p; )
        if (y[m + I] === a)
          ++I, ++this._dashes;
        else {
          this._dashes && (S = s), this._dashes = 0;
          break;
        }
      if (this._dashes === 2 && (m + I < p && this.listenerCount("trailer") !== 0 && this.emit("trailer", y.slice(m + I, p)), this.reset(), this._finished = !0, A._parts === 0 && (A._realFinish = !0, A.emit("finish"), A._realFinish = !1)), this._dashes)
        return;
    }
    this._justMatched && (this._justMatched = !1), this._part || (this._part = new n(this._partOpts), this._part._read = function(v) {
      A._unpause();
    }, this._isPreamble && this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._isPreamble !== !0 && this.listenerCount("part") !== 0 ? this.emit("part", this._part) : this._ignore(), this._isPreamble || (this._inHeader = !0)), y && m < p && !this._ignoreData && (this._isPreamble || !this._inHeader ? (S && (E = this._part.push(S)), E = this._part.push(y.slice(m, p)), E || (this._pause = !0)) : !this._isPreamble && this._inHeader && (S && this._hparser.push(S), c = this._hparser.push(y.slice(m, p)), !this._inHeader && c !== void 0 && c < p && this._oninfo(!1, y, m + c, p))), f && (this._hparser.reset(), this._isPreamble ? this._isPreamble = !1 : m !== p && (++this._parts, this._part.on("end", function() {
      --A._parts === 0 && (A._finished ? (A._realFinish = !0, A.emit("finish"), A._realFinish = !1) : A._unpause());
    })), this._part.push(null), this._part = void 0, this._ignoreData = !1, this._justMatched = !0, this._dashes = 0);
  }, u.prototype._unpause = function() {
    if (this._pause && (this._pause = !1, this._cb)) {
      const f = this._cb;
      this._cb = void 0, f();
    }
  }, Uu = u, Uu;
}
var Fu, Np;
function kf() {
  if (Np) return Fu;
  Np = 1;
  const t = new TextDecoder("utf-8"), e = /* @__PURE__ */ new Map([
    ["utf-8", t],
    ["utf8", t]
  ]);
  function r(a) {
    let s;
    for (; ; )
      switch (a) {
        case "utf-8":
        case "utf8":
          return n.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return n.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return n.utf16le;
        case "base64":
          return n.base64;
        default:
          if (s === void 0) {
            s = !0, a = a.toLowerCase();
            continue;
          }
          return n.other.bind(a);
      }
  }
  const n = {
    utf8: (a, s) => a.length === 0 ? "" : (typeof a == "string" && (a = Buffer.from(a, s)), a.utf8Slice(0, a.length)),
    latin1: (a, s) => a.length === 0 ? "" : typeof a == "string" ? a : a.latin1Slice(0, a.length),
    utf16le: (a, s) => a.length === 0 ? "" : (typeof a == "string" && (a = Buffer.from(a, s)), a.ucs2Slice(0, a.length)),
    base64: (a, s) => a.length === 0 ? "" : (typeof a == "string" && (a = Buffer.from(a, s)), a.base64Slice(0, a.length)),
    other: (a, s) => {
      if (a.length === 0)
        return "";
      if (typeof a == "string" && (a = Buffer.from(a, s)), e.has(this.toString()))
        try {
          return e.get(this).decode(a);
        } catch {
        }
      return typeof a == "string" ? a : a.toString();
    }
  };
  function i(a, s, o) {
    return a && r(o)(a, s);
  }
  return Fu = i, Fu;
}
var Mu, xp;
function $y() {
  if (xp) return Mu;
  xp = 1;
  const t = kf(), e = /%[a-fA-F0-9][a-fA-F0-9]/g, r = {
    "%00": "\0",
    "%01": "",
    "%02": "",
    "%03": "",
    "%04": "",
    "%05": "",
    "%06": "",
    "%07": "\x07",
    "%08": "\b",
    "%09": "	",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "",
    "%0E": "",
    "%0f": "",
    "%0F": "",
    "%10": "",
    "%11": "",
    "%12": "",
    "%13": "",
    "%14": "",
    "%15": "",
    "%16": "",
    "%17": "",
    "%18": "",
    "%19": "",
    "%1a": "",
    "%1A": "",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "",
    "%1C": "",
    "%1d": "",
    "%1D": "",
    "%1e": "",
    "%1E": "",
    "%1f": "",
    "%1F": "",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": "",
    "%A0": "",
    "%a1": "",
    "%A1": "",
    "%a2": "",
    "%A2": "",
    "%a3": "",
    "%A3": "",
    "%a4": "",
    "%A4": "",
    "%a5": "",
    "%A5": "",
    "%a6": "",
    "%A6": "",
    "%a7": "",
    "%A7": "",
    "%a8": "",
    "%A8": "",
    "%a9": "",
    "%A9": "",
    "%aa": "",
    "%Aa": "",
    "%aA": "",
    "%AA": "",
    "%ab": "",
    "%Ab": "",
    "%aB": "",
    "%AB": "",
    "%ac": "",
    "%Ac": "",
    "%aC": "",
    "%AC": "",
    "%ad": "",
    "%Ad": "",
    "%aD": "",
    "%AD": "",
    "%ae": "",
    "%Ae": "",
    "%aE": "",
    "%AE": "",
    "%af": "",
    "%Af": "",
    "%aF": "",
    "%AF": "",
    "%b0": "",
    "%B0": "",
    "%b1": "",
    "%B1": "",
    "%b2": "",
    "%B2": "",
    "%b3": "",
    "%B3": "",
    "%b4": "",
    "%B4": "",
    "%b5": "",
    "%B5": "",
    "%b6": "",
    "%B6": "",
    "%b7": "",
    "%B7": "",
    "%b8": "",
    "%B8": "",
    "%b9": "",
    "%B9": "",
    "%ba": "",
    "%Ba": "",
    "%bA": "",
    "%BA": "",
    "%bb": "",
    "%Bb": "",
    "%bB": "",
    "%BB": "",
    "%bc": "",
    "%Bc": "",
    "%bC": "",
    "%BC": "",
    "%bd": "",
    "%Bd": "",
    "%bD": "",
    "%BD": "",
    "%be": "",
    "%Be": "",
    "%bE": "",
    "%BE": "",
    "%bf": "",
    "%Bf": "",
    "%bF": "",
    "%BF": "",
    "%c0": "",
    "%C0": "",
    "%c1": "",
    "%C1": "",
    "%c2": "",
    "%C2": "",
    "%c3": "",
    "%C3": "",
    "%c4": "",
    "%C4": "",
    "%c5": "",
    "%C5": "",
    "%c6": "",
    "%C6": "",
    "%c7": "",
    "%C7": "",
    "%c8": "",
    "%C8": "",
    "%c9": "",
    "%C9": "",
    "%ca": "",
    "%Ca": "",
    "%cA": "",
    "%CA": "",
    "%cb": "",
    "%Cb": "",
    "%cB": "",
    "%CB": "",
    "%cc": "",
    "%Cc": "",
    "%cC": "",
    "%CC": "",
    "%cd": "",
    "%Cd": "",
    "%cD": "",
    "%CD": "",
    "%ce": "",
    "%Ce": "",
    "%cE": "",
    "%CE": "",
    "%cf": "",
    "%Cf": "",
    "%cF": "",
    "%CF": "",
    "%d0": "",
    "%D0": "",
    "%d1": "",
    "%D1": "",
    "%d2": "",
    "%D2": "",
    "%d3": "",
    "%D3": "",
    "%d4": "",
    "%D4": "",
    "%d5": "",
    "%D5": "",
    "%d6": "",
    "%D6": "",
    "%d7": "",
    "%D7": "",
    "%d8": "",
    "%D8": "",
    "%d9": "",
    "%D9": "",
    "%da": "",
    "%Da": "",
    "%dA": "",
    "%DA": "",
    "%db": "",
    "%Db": "",
    "%dB": "",
    "%DB": "",
    "%dc": "",
    "%Dc": "",
    "%dC": "",
    "%DC": "",
    "%dd": "",
    "%Dd": "",
    "%dD": "",
    "%DD": "",
    "%de": "",
    "%De": "",
    "%dE": "",
    "%DE": "",
    "%df": "",
    "%Df": "",
    "%dF": "",
    "%DF": "",
    "%e0": "",
    "%E0": "",
    "%e1": "",
    "%E1": "",
    "%e2": "",
    "%E2": "",
    "%e3": "",
    "%E3": "",
    "%e4": "",
    "%E4": "",
    "%e5": "",
    "%E5": "",
    "%e6": "",
    "%E6": "",
    "%e7": "",
    "%E7": "",
    "%e8": "",
    "%E8": "",
    "%e9": "",
    "%E9": "",
    "%ea": "",
    "%Ea": "",
    "%eA": "",
    "%EA": "",
    "%eb": "",
    "%Eb": "",
    "%eB": "",
    "%EB": "",
    "%ec": "",
    "%Ec": "",
    "%eC": "",
    "%EC": "",
    "%ed": "",
    "%Ed": "",
    "%eD": "",
    "%ED": "",
    "%ee": "",
    "%Ee": "",
    "%eE": "",
    "%EE": "",
    "%ef": "",
    "%Ef": "",
    "%eF": "",
    "%EF": "",
    "%f0": "",
    "%F0": "",
    "%f1": "",
    "%F1": "",
    "%f2": "",
    "%F2": "",
    "%f3": "",
    "%F3": "",
    "%f4": "",
    "%F4": "",
    "%f5": "",
    "%F5": "",
    "%f6": "",
    "%F6": "",
    "%f7": "",
    "%F7": "",
    "%f8": "",
    "%F8": "",
    "%f9": "",
    "%F9": "",
    "%fa": "",
    "%Fa": "",
    "%fA": "",
    "%FA": "",
    "%fb": "",
    "%Fb": "",
    "%fB": "",
    "%FB": "",
    "%fc": "",
    "%Fc": "",
    "%fC": "",
    "%FC": "",
    "%fd": "",
    "%Fd": "",
    "%fD": "",
    "%FD": "",
    "%fe": "",
    "%Fe": "",
    "%fE": "",
    "%FE": "",
    "%ff": "",
    "%Ff": "",
    "%fF": "",
    "%FF": ""
  };
  function n(u) {
    return r[u];
  }
  const i = 0, a = 1, s = 2, o = 3;
  function l(u) {
    const f = [];
    let y = i, m = "", p = !1, S = !1, A = 0, I = "";
    const c = u.length;
    for (var E = 0; E < c; ++E) {
      const v = u[E];
      if (v === "\\" && p)
        if (S)
          S = !1;
        else {
          S = !0;
          continue;
        }
      else if (v === '"')
        if (S)
          S = !1;
        else {
          p ? (p = !1, y = i) : p = !0;
          continue;
        }
      else if (S && p && (I += "\\"), S = !1, (y === s || y === o) && v === "'") {
        y === s ? (y = o, m = I.substring(1)) : y = a, I = "";
        continue;
      } else if (y === i && (v === "*" || v === "=") && f.length) {
        y = v === "*" ? s : a, f[A] = [I, void 0], I = "";
        continue;
      } else if (!p && v === ";") {
        y = i, m ? (I.length && (I = t(
          I.replace(e, n),
          "binary",
          m
        )), m = "") : I.length && (I = t(I, "binary", "utf8")), f[A] === void 0 ? f[A] = I : f[A][1] = I, I = "", ++A;
        continue;
      } else if (!p && (v === " " || v === "	"))
        continue;
      I += v;
    }
    return m && I.length ? I = t(
      I.replace(e, n),
      "binary",
      m
    ) : I && (I = t(I, "binary", "utf8")), f[A] === void 0 ? I && (f[A] = I) : f[A][1] = I, f;
  }
  return Mu = l, Mu;
}
var Vu, Op;
function wb() {
  return Op || (Op = 1, Vu = function(e) {
    if (typeof e != "string")
      return "";
    for (var r = e.length - 1; r >= 0; --r)
      switch (e.charCodeAt(r)) {
        case 47:
        case 92:
          return e = e.slice(r + 1), e === ".." || e === "." ? "" : e;
      }
    return e === ".." || e === "." ? "" : e;
  }), Vu;
}
var $u, Dp;
function Tb() {
  if (Dp) return $u;
  Dp = 1;
  const { Readable: t } = ge, { inherits: e } = ge, r = Vy(), n = $y(), i = kf(), a = wb(), s = Pf(), o = /^boundary$/i, l = /^form-data$/i, u = /^charset$/i, f = /^filename$/i, y = /^name$/i;
  m.detect = /^multipart\/form-data/i;
  function m(A, I) {
    let c, E;
    const v = this;
    let R;
    const N = I.limits, C = I.isPartAFile || ((fe, De, _e) => De === "application/octet-stream" || _e !== void 0), h = I.parsedConType || [], d = I.defCharset || "utf8", O = I.preservePath, P = { highWaterMark: I.fileHwm };
    for (c = 0, E = h.length; c < E; ++c)
      if (Array.isArray(h[c]) && o.test(h[c][0])) {
        R = h[c][1];
        break;
      }
    function L() {
      me === 0 && te && !A._done && (te = !1, v.end());
    }
    if (typeof R != "string")
      throw new Error("Multipart: Boundary not found");
    const D = s(N, "fieldSize", 1 * 1024 * 1024), V = s(N, "fileSize", 1 / 0), $ = s(N, "files", 1 / 0), K = s(N, "fields", 1 / 0), Q = s(N, "parts", 1 / 0), ee = s(N, "headerPairs", 2e3), ne = s(N, "headerSize", 80 * 1024);
    let ae = 0, se = 0, me = 0, ye, Se, te = !1;
    this._needDrain = !1, this._pause = !1, this._cb = void 0, this._nparts = 0, this._boy = A;
    const Ce = {
      boundary: R,
      maxHeaderPairs: ee,
      maxHeaderSize: ne,
      partHwm: P.highWaterMark,
      highWaterMark: I.highWaterMark
    };
    this.parser = new r(Ce), this.parser.on("drain", function() {
      if (v._needDrain = !1, v._cb && !v._pause) {
        const fe = v._cb;
        v._cb = void 0, fe();
      }
    }).on("part", function fe(De) {
      if (++v._nparts > Q)
        return v.parser.removeListener("part", fe), v.parser.on("part", p), A.hitPartsLimit = !0, A.emit("partsLimit"), p(De);
      if (Se) {
        const _e = Se;
        _e.emit("end"), _e.removeAllListeners("end");
      }
      De.on("header", function(_e) {
        let w, b, T, g, x, U, k = 0;
        if (_e["content-type"] && (T = n(_e["content-type"][0]), T[0])) {
          for (w = T[0].toLowerCase(), c = 0, E = T.length; c < E; ++c)
            if (u.test(T[c][0])) {
              g = T[c][1].toLowerCase();
              break;
            }
        }
        if (w === void 0 && (w = "text/plain"), g === void 0 && (g = d), _e["content-disposition"]) {
          if (T = n(_e["content-disposition"][0]), !l.test(T[0]))
            return p(De);
          for (c = 0, E = T.length; c < E; ++c)
            y.test(T[c][0]) ? b = T[c][1] : f.test(T[c][0]) && (U = T[c][1], O || (U = a(U)));
        } else
          return p(De);
        _e["content-transfer-encoding"] ? x = _e["content-transfer-encoding"][0].toLowerCase() : x = "7bit";
        let W, q;
        if (C(b, w, U)) {
          if (ae === $)
            return A.hitFilesLimit || (A.hitFilesLimit = !0, A.emit("filesLimit")), p(De);
          if (++ae, A.listenerCount("file") === 0) {
            v.parser._ignore();
            return;
          }
          ++me;
          const z = new S(P);
          ye = z, z.on("end", function() {
            if (--me, v._pause = !1, L(), v._cb && !v._needDrain) {
              const j = v._cb;
              v._cb = void 0, j();
            }
          }), z._read = function(j) {
            if (v._pause && (v._pause = !1, v._cb && !v._needDrain)) {
              const Y = v._cb;
              v._cb = void 0, Y();
            }
          }, A.emit("file", b, z, U, x, w), W = function(j) {
            if ((k += j.length) > V) {
              const Y = V - k + j.length;
              Y > 0 && z.push(j.slice(0, Y)), z.truncated = !0, z.bytesRead = V, De.removeAllListeners("data"), z.emit("limit");
              return;
            } else z.push(j) || (v._pause = !0);
            z.bytesRead = k;
          }, q = function() {
            ye = void 0, z.push(null);
          };
        } else {
          if (se === K)
            return A.hitFieldsLimit || (A.hitFieldsLimit = !0, A.emit("fieldsLimit")), p(De);
          ++se, ++me;
          let z = "", j = !1;
          Se = De, W = function(Y) {
            if ((k += Y.length) > D) {
              const M = D - (k - Y.length);
              z += Y.toString("binary", 0, M), j = !0, De.removeAllListeners("data");
            } else
              z += Y.toString("binary");
          }, q = function() {
            Se = void 0, z.length && (z = i(z, "binary", g)), A.emit("field", b, z, !1, j, x, w), --me, L();
          };
        }
        De._readableState.sync = !1, De.on("data", W), De.on("end", q);
      }).on("error", function(_e) {
        ye && ye.emit("error", _e);
      });
    }).on("error", function(fe) {
      A.emit("error", fe);
    }).on("finish", function() {
      te = !0, L();
    });
  }
  m.prototype.write = function(A, I) {
    const c = this.parser.write(A);
    c && !this._pause ? I() : (this._needDrain = !c, this._cb = I);
  }, m.prototype.end = function() {
    const A = this;
    A.parser.writable ? A.parser.end() : A._boy._done || process.nextTick(function() {
      A._boy._done = !0, A._boy.emit("finish");
    });
  };
  function p(A) {
    A.resume();
  }
  function S(A) {
    t.call(this, A), this.bytesRead = 0, this.truncated = !1;
  }
  return e(S, t), S.prototype._read = function(A) {
  }, $u = m, $u;
}
var Hu, Lp;
function Rb() {
  if (Lp) return Hu;
  Lp = 1;
  const t = /\+/g, e = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function r() {
    this.buffer = void 0;
  }
  return r.prototype.write = function(n) {
    n = n.replace(t, " ");
    let i = "", a = 0, s = 0;
    const o = n.length;
    for (; a < o; ++a)
      this.buffer !== void 0 ? e[n.charCodeAt(a)] ? (this.buffer += n[a], ++s, this.buffer.length === 2 && (i += String.fromCharCode(parseInt(this.buffer, 16)), this.buffer = void 0)) : (i += "%" + this.buffer, this.buffer = void 0, --a) : n[a] === "%" && (a > s && (i += n.substring(s, a), s = a), this.buffer = "", ++s);
    return s < o && this.buffer === void 0 && (i += n.substring(s)), i;
  }, r.prototype.reset = function() {
    this.buffer = void 0;
  }, Hu = r, Hu;
}
var Ku, Pp;
function Nb() {
  if (Pp) return Ku;
  Pp = 1;
  const t = Rb(), e = kf(), r = Pf(), n = /^charset$/i;
  i.detect = /^application\/x-www-form-urlencoded/i;
  function i(a, s) {
    const o = s.limits, l = s.parsedConType;
    this.boy = a, this.fieldSizeLimit = r(o, "fieldSize", 1 * 1024 * 1024), this.fieldNameSizeLimit = r(o, "fieldNameSize", 100), this.fieldsLimit = r(o, "fields", 1 / 0);
    let u;
    for (var f = 0, y = l.length; f < y; ++f)
      if (Array.isArray(l[f]) && n.test(l[f][0])) {
        u = l[f][1].toLowerCase();
        break;
      }
    u === void 0 && (u = s.defCharset || "utf8"), this.decoder = new t(), this.charset = u, this._fields = 0, this._state = "key", this._checkingBytes = !0, this._bytesKey = 0, this._bytesVal = 0, this._key = "", this._val = "", this._keyTrunc = !1, this._valTrunc = !1, this._hitLimit = !1;
  }
  return i.prototype.write = function(a, s) {
    if (this._fields === this.fieldsLimit)
      return this.boy.hitFieldsLimit || (this.boy.hitFieldsLimit = !0, this.boy.emit("fieldsLimit")), s();
    let o, l, u, f = 0;
    const y = a.length;
    for (; f < y; )
      if (this._state === "key") {
        for (o = l = void 0, u = f; u < y; ++u) {
          if (this._checkingBytes || ++f, a[u] === 61) {
            o = u;
            break;
          } else if (a[u] === 38) {
            l = u;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = !0;
            break;
          } else this._checkingBytes && ++this._bytesKey;
        }
        if (o !== void 0)
          o > f && (this._key += this.decoder.write(a.toString("binary", f, o))), this._state = "val", this._hitLimit = !1, this._checkingBytes = !0, this._val = "", this._bytesVal = 0, this._valTrunc = !1, this.decoder.reset(), f = o + 1;
        else if (l !== void 0) {
          ++this._fields;
          let m;
          const p = this._keyTrunc;
          if (l > f ? m = this._key += this.decoder.write(a.toString("binary", f, l)) : m = this._key, this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), m.length && this.boy.emit(
            "field",
            e(m, "binary", this.charset),
            "",
            p,
            !1
          ), f = l + 1, this._fields === this.fieldsLimit)
            return s();
        } else this._hitLimit ? (u > f && (this._key += this.decoder.write(a.toString("binary", f, u))), f = u, (this._bytesKey = this._key.length) === this.fieldNameSizeLimit && (this._checkingBytes = !1, this._keyTrunc = !0)) : (f < y && (this._key += this.decoder.write(a.toString("binary", f))), f = y);
      } else {
        for (l = void 0, u = f; u < y; ++u) {
          if (this._checkingBytes || ++f, a[u] === 38) {
            l = u;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = !0;
            break;
          } else this._checkingBytes && ++this._bytesVal;
        }
        if (l !== void 0) {
          if (++this._fields, l > f && (this._val += this.decoder.write(a.toString("binary", f, l))), this.boy.emit(
            "field",
            e(this._key, "binary", this.charset),
            e(this._val, "binary", this.charset),
            this._keyTrunc,
            this._valTrunc
          ), this._state = "key", this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), f = l + 1, this._fields === this.fieldsLimit)
            return s();
        } else this._hitLimit ? (u > f && (this._val += this.decoder.write(a.toString("binary", f, u))), f = u, (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) && (this._checkingBytes = !1, this._valTrunc = !0)) : (f < y && (this._val += this.decoder.write(a.toString("binary", f))), f = y);
      }
    s();
  }, i.prototype.end = function() {
    this.boy._done || (this._state === "key" && this._key.length > 0 ? this.boy.emit(
      "field",
      e(this._key, "binary", this.charset),
      "",
      this._keyTrunc,
      !1
    ) : this._state === "val" && this.boy.emit(
      "field",
      e(this._key, "binary", this.charset),
      e(this._val, "binary", this.charset),
      this._keyTrunc,
      this._valTrunc
    ), this.boy._done = !0, this.boy.emit("finish"));
  }, Ku = i, Ku;
}
var kp;
function xb() {
  if (kp) return gi.exports;
  kp = 1;
  const t = ge.Writable, { inherits: e } = ge, r = Vy(), n = Tb(), i = Nb(), a = $y();
  function s(o) {
    if (!(this instanceof s))
      return new s(o);
    if (typeof o != "object")
      throw new TypeError("Busboy expected an options-Object.");
    if (typeof o.headers != "object")
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    if (typeof o.headers["content-type"] != "string")
      throw new TypeError("Missing Content-Type-header.");
    const {
      headers: l,
      ...u
    } = o;
    this.opts = {
      autoDestroy: !1,
      ...u
    }, t.call(this, this.opts), this._done = !1, this._parser = this.getParserByHeaders(l), this._finished = !1;
  }
  return e(s, t), s.prototype.emit = function(o) {
    var l;
    if (o === "finish") {
      if (this._done) {
        if (this._finished)
          return;
      } else {
        (l = this._parser) == null || l.end();
        return;
      }
      this._finished = !0;
    }
    t.prototype.emit.apply(this, arguments);
  }, s.prototype.getParserByHeaders = function(o) {
    const l = a(o["content-type"]), u = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers: o,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: l,
      preservePath: this.opts.preservePath
    };
    if (n.detect.test(l[0]))
      return new n(this, u);
    if (i.detect.test(l[0]))
      return new i(this, u);
    throw new Error("Unsupported Content-Type.");
  }, s.prototype._write = function(o, l, u) {
    this._parser.write(o, u);
  }, gi.exports = s, gi.exports.default = s, gi.exports.Busboy = s, gi.exports.Dicer = r, gi.exports;
}
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.Http2SessionHandler = tt.ExponentialBackoffPoller = tt.ApiSettings = tt.AuthorizedHttp2Client = tt.AuthorizedHttpClient = tt.Http2Client = tt.HttpClient = tt.RequestClient = tt.RequestResponseError = void 0;
tt.defaultRetryConfig = Bf;
tt.parseHttpResponse = Ub;
const Be = Te, or = Ue, Ob = ge, Db = ge, Lb = ge, Gu = ge, Pb = ge, Hy = Lt, Ky = at;
class Gy {
  /**
   * Constructs a new `RequestResponse` from the given `LowLevelResponse`.
   */
  constructor(e) {
    this.status = e.status, this.headers = e.headers, this.text = e.data;
    try {
      if (!e.data)
        throw new Be.FirebaseAppError(Be.AppErrorCodes.INTERNAL_ERROR, "HTTP response missing data.");
      this.parsedData = JSON.parse(e.data);
    } catch (r) {
      this.parsedData = void 0, this.parseError = r;
    }
    this.request = `${e.config.method} ${e.config.url}`;
  }
  get data() {
    if (this.isJson())
      return this.parsedData;
    throw new Be.FirebaseAppError(Be.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: "${this.parseError.toString()}". Raw server response: "${this.text}". Status code: "${this.status}". Outgoing request: "${this.request}."`);
  }
  isJson() {
    return typeof this.parsedData < "u";
  }
}
class kb {
  constructor(e) {
    this.status = e.status, this.headers = e.headers, this.multipart = e.multipart;
  }
  get text() {
    throw new Be.FirebaseAppError(Be.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as text");
  }
  get data() {
    throw new Be.FirebaseAppError(Be.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as JSON");
  }
  isJson() {
    return !1;
  }
}
class Pa extends Error {
  constructor(e) {
    super(`Server responded with status ${e.status}.`), this.response = e, Object.setPrototypeOf(this, Pa.prototype);
  }
}
tt.RequestResponseError = Pa;
function Bf() {
  return {
    maxRetries: 4,
    statusCodes: [503],
    ioErrorCodes: ["ECONNRESET", "ETIMEDOUT"],
    backOffFactor: 0.5,
    maxDelayInMillis: 60 * 1e3
  };
}
function Bb(t) {
  if (!or.isNumber(t.maxRetries) || t.maxRetries < 0)
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INVALID_ARGUMENT, "maxRetries must be a non-negative integer");
  if (typeof t.backOffFactor < "u" && (!or.isNumber(t.backOffFactor) || t.backOffFactor < 0))
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INVALID_ARGUMENT, "backOffFactor must be a non-negative number");
  if (!or.isNumber(t.maxDelayInMillis) || t.maxDelayInMillis < 0)
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INVALID_ARGUMENT, "maxDelayInMillis must be a non-negative integer");
  if (typeof t.statusCodes < "u" && !or.isArray(t.statusCodes))
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INVALID_ARGUMENT, "statusCodes must be an array");
  if (typeof t.ioErrorCodes < "u" && !or.isArray(t.ioErrorCodes))
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INVALID_ARGUMENT, "ioErrorCodes must be an array");
}
class Uf {
  constructor(e = Bf()) {
    e && (this.retry = e, Bb(this.retry));
  }
  createRequestResponse(e) {
    return e.multipart ? new kb(e) : new Gy(e);
  }
  waitForRetry(e) {
    return e > 0 ? new Promise((r) => {
      setTimeout(r, e);
    }) : Promise.resolve();
  }
  /**
   * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating
   * the retry.
   *
   * @param retryAttempts - Number of retries completed up to now.
   * @param err - The last encountered error.
   * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the
   *     2nd element is a boolean indicating whether the request is eligible for a retry or not.
   */
  getRetryDelayMillis(e, r) {
    if (!this.isRetryEligible(e, r))
      return [0, !1];
    const n = r.response;
    if (n && n.headers["retry-after"]) {
      const i = this.parseRetryAfterIntoMillis(n.headers["retry-after"]);
      if (i > 0)
        return [i, !0];
    }
    return [this.backOffDelayMillis(e), !0];
  }
  isRetryEligible(e, r) {
    return !this.retry || e >= this.retry.maxRetries ? !1 : r.response ? (this.retry.statusCodes || []).indexOf(r.response.status) !== -1 : r.code ? (this.retry.ioErrorCodes || []).indexOf(r.code) !== -1 : !1;
  }
  /**???
   * Parses the Retry-After header as a milliseconds value. Return value is negative if the Retry-After header
   * contains an expired timestamp or otherwise malformed.
   */
  parseRetryAfterIntoMillis(e) {
    const r = parseInt(e, 10);
    if (!isNaN(r))
      return r * 1e3;
    const n = new Date(e);
    return isNaN(n.getTime()) ? -1 : n.getTime() - Date.now();
  }
  backOffDelayMillis(e) {
    if (e === 0)
      return 0;
    if (!this.retry)
      throw new Be.FirebaseAppError(Be.AppErrorCodes.INTERNAL_ERROR, "Expected this.retry to exist.");
    const r = this.retry.backOffFactor || 0, n = 2 ** e * r;
    return Math.min(n * 1e3, this.retry.maxDelayInMillis);
  }
}
tt.RequestClient = Uf;
class jy extends Uf {
  constructor(e) {
    super(e);
  }
  /**
   * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned
   * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
   * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
   * If a request fails due to a low-level network error, the client transparently retries the request once before
   * rejecting the promise.
   *
   * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
   * content-type header will also be automatically set in this case. For all other payload types, the content-type
   * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
   * and pass as a string or a Buffer along with the appropriate content-type header.
   *
   * @param config - HTTP request to be sent.
   * @returns A promise that resolves with the response details.
   */
  send(e) {
    return this.sendWithRetry(e);
  }
  /**
   * Sends an HTTP request. In the event of an error, retries the HTTP request according to the
   * `RetryConfig` set on the `HttpClient`.
   *
   * @param config - HTTP request to be sent.
   * @param retryAttempts - Number of retries performed up to now.
   * @returns A promise that resolves with the response details.
   */
  sendWithRetry(e, r = 0) {
    return Ff.invoke(e).then((n) => this.createRequestResponse(n)).catch((n) => {
      const [i, a] = this.getRetryDelayMillis(r, n);
      if (a && this.retry && i <= this.retry.maxDelayInMillis)
        return this.waitForRetry(i).then(() => this.sendWithRetry(e, r + 1));
      throw n.response ? new Pa(this.createRequestResponse(n.response)) : n.code === "ETIMEDOUT" ? new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${n.message}.`) : new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${n.message}. Error code: ${n.code}`);
    });
  }
}
tt.HttpClient = jy;
class qy extends Uf {
  constructor(e = Bf()) {
    super(e);
  }
  /**
   * Sends an HTTP/2 request to a remote server. If the server responds with a successful response (2xx), the returned
   * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
   * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
   * If a request fails due to a low-level network error, the client transparently retries the request once before
   * rejecting the promise.
   *
   * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
   * content-type header will also be automatically set in this case. For all other payload types, the content-type
   * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
   * and pass as a string or a Buffer along with the appropriate content-type header.
   *
   * @param config - HTTP/2 request to be sent.
   * @returns A promise that resolves with the response details.
   */
  send(e) {
    return this.sendWithRetry(e);
  }
  /**
   * Sends an HTTP/2 request. In the event of an error, retries the HTTP/2 request according to the
   * `RetryConfig` set on the `Http2Client`.
   *
   * @param config - HTTP/2 request to be sent.
   * @param retryAttempts - Number of retries performed up to now.
   * @returns A promise that resolves with the response details.
   */
  sendWithRetry(e, r = 0) {
    return Mf.invoke(e).then((n) => this.createRequestResponse(n)).catch((n) => {
      const [i, a] = this.getRetryDelayMillis(r, n);
      if (a && this.retry && i <= this.retry.maxDelayInMillis)
        return this.waitForRetry(i).then(() => this.sendWithRetry(e, r + 1));
      throw n.response ? new Pa(this.createRequestResponse(n.response)) : n.code === "ETIMEDOUT" ? new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${n.message}.`) : new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${n.message}. Error code: ${n.code}`);
    });
  }
}
tt.Http2Client = qy;
function Ub(t, e) {
  const r = or.isBuffer(t) ? t.toString("utf-8") : t, n = r.indexOf(`\r
\r
`), i = r.substring(0, n).split(`\r
`), s = i[0].trim().split(/\s/)[1], o = {};
  i.slice(1).forEach((f) => {
    const y = f.indexOf(":"), m = f.substring(0, y).trim().toLowerCase(), p = f.substring(y + 1).trim();
    o[m] = p;
  });
  let l = r.substring(n + 4);
  l.endsWith(`
`) && (l = l.slice(0, -1)), l.endsWith("\r") && (l = l.slice(0, -1));
  const u = {
    status: parseInt(s, 10),
    headers: o,
    data: l,
    config: e,
    request: null
  };
  if (!or.isNumber(u.status))
    throw new Be.FirebaseAppError(Be.AppErrorCodes.INTERNAL_ERROR, "Malformed HTTP status line.");
  return new Gy(u);
}
class Wy {
  constructor(e) {
    this.configImpl = e;
  }
  /**
   * Extracts multipart boundary from the HTTP header. The content-type header of a multipart
   * response has the form 'multipart/subtype; boundary=string'.
   *
   * If the content-type header does not exist, or does not start with
   * 'multipart/', then null will be returned.
   */
  getMultipartBoundary(e) {
    const r = e["content-type"];
    if (!r || !r.startsWith("multipart/"))
      return null;
    const n = r.split(";"), i = {};
    return n.slice(1).map((s) => s.trim().split("=")).reduce((s, o) => {
      if (o.length === 2) {
        const l = {};
        return l[o[0]] = o[1], Object.assign(s, l);
      }
      return s;
    }, i).boundary;
  }
  handleMultipartResponse(e, r, n) {
    const i = xb(), a = new i.Dicer({ boundary: n }), s = [];
    a.on("part", (o) => {
      const l = [];
      o.on("data", (u) => {
        l.push(u);
      }), o.on("end", () => {
        s.push(Buffer.concat(l));
      });
    }), a.on("finish", () => {
      e.data = void 0, e.multipart = s, this.finalizeResponse(e);
    }), r.pipe(a);
  }
  handleRegularResponse(e, r) {
    const n = [];
    r.on("data", (i) => {
      n.push(i);
    }), r.on("error", (i) => {
      const a = e.request;
      a && a.destroyed || this.enhanceAndReject(i, null, a);
    }), r.on("end", () => {
      e.data = Buffer.concat(n).toString(), this.finalizeResponse(e);
    });
  }
  /**
   * Finalizes the current request call in-flight by either resolving or rejecting the associated
   * promise. In the event of an error, adds additional useful information to the returned error.
   */
  finalizeResponse(e) {
    e.status >= 200 && e.status < 300 ? this.resolve(e) : this.rejectWithError("Request failed with status code " + e.status, null, e.request, e);
  }
  /**
   * Creates a new error from the given message, and enhances it with other information available.
   * Then the promise associated with this request call is rejected with the resulting error.
   */
  rejectWithError(e, r, n, i) {
    const a = new Error(e);
    this.enhanceAndReject(a, r, n, i);
  }
  enhanceAndReject(e, r, n, i) {
    this.reject(this.enhanceError(e, r, n, i));
  }
  /**
   * Enhances the given error by adding more information to it. Specifically, the request config,
   * the underlying request and response will be attached to the error.
   */
  enhanceError(e, r, n, i) {
    return e.config = this.configImpl, r && (e.code = r), e.request = n, e.response = i, e;
  }
}
class Ff extends Wy {
  /**
   * Sends an HTTP request based on the provided configuration.
   */
  static invoke(e) {
    return new Ff(e).promise;
  }
  constructor(e) {
    const r = new Fb(e);
    super(r);
    try {
      this.httpConfigImpl = r, this.options = this.httpConfigImpl.buildRequestOptions(), this.entity = this.httpConfigImpl.buildEntity(this.options.headers), this.promise = new Promise((n, i) => {
        this.resolve = n, this.reject = i, this.execute();
      });
    } catch (n) {
      this.promise = Promise.reject(this.enhanceError(n, null));
    }
  }
  execute() {
    const r = (this.options.protocol === "https:" ? Db : Ob).request(this.options, (a) => {
      this.handleResponse(a, r);
    });
    r.on("error", (a) => {
      r.aborted || this.enhanceAndReject(a, null, r);
    });
    const n = this.httpConfigImpl.timeout, i = () => {
      r.destroy(), this.rejectWithError(`timeout of ${n}ms exceeded`, "ETIMEDOUT", r);
    };
    n && r.setTimeout(n, i), r.end(this.entity);
  }
  handleResponse(e, r) {
    if (r.aborted)
      return;
    if (!e.statusCode)
      throw new Be.FirebaseAppError(Be.AppErrorCodes.INTERNAL_ERROR, "Expected a statusCode on the response from a ClientRequest");
    const n = {
      status: e.statusCode,
      headers: e.headers,
      request: r,
      data: void 0,
      config: this.httpConfigImpl
    }, i = this.getMultipartBoundary(e.headers), a = this.uncompressResponse(e);
    i ? this.handleMultipartResponse(n, a, i) : this.handleRegularResponse(n, a);
  }
  uncompressResponse(e) {
    let r = e;
    const n = ["gzip", "compress", "deflate"];
    if (e.headers["content-encoding"] && n.indexOf(e.headers["content-encoding"]) !== -1) {
      const i = ge;
      r = r.pipe(i.createUnzip()), delete e.headers["content-encoding"];
    }
    return r;
  }
}
class Mf extends Wy {
  /**
   * Sends an HTTP2 request based on the provided configuration.
   */
  static invoke(e) {
    return new Mf(e).promise;
  }
  constructor(e) {
    const r = new Mb(e);
    super(r);
    try {
      this.http2ConfigImpl = r, this.options = this.http2ConfigImpl.buildRequestOptions(), this.entity = this.http2ConfigImpl.buildEntity(this.options.headers), this.promise = new Promise((n, i) => {
        this.resolve = n, this.reject = i, this.execute();
      });
    } catch (n) {
      this.promise = Promise.reject(this.enhanceError(n, null));
    }
  }
  execute() {
    const e = this.http2ConfigImpl.http2SessionHandler.session.request({
      ":method": this.options.method,
      ":scheme": this.options.protocol,
      ":path": this.options.path,
      ...this.options.headers
    });
    e.on("response", (i) => {
      this.handleHttp2Response(i, e);
    }), e.on("error", (i) => {
      e.aborted || this.enhanceAndReject(i, null, e);
    });
    const r = this.http2ConfigImpl.timeout, n = () => {
      e.destroy(), this.rejectWithError(`timeout of ${r}ms exceeded`, "ETIMEDOUT", e);
    };
    r && e.setTimeout(r, n), e.end(this.entity);
  }
  handleHttp2Response(e, r) {
    if (r.aborted)
      return;
    if (!e[":status"])
      throw new Be.FirebaseAppError(Be.AppErrorCodes.INTERNAL_ERROR, "Expected a statusCode on the response from a ClientRequest");
    const n = {
      status: e[":status"],
      headers: e,
      request: r,
      data: void 0,
      config: this.http2ConfigImpl
    }, i = this.getMultipartBoundary(e), a = this.uncompressResponse(e, r);
    i ? this.handleMultipartResponse(n, a, i) : this.handleRegularResponse(n, a);
  }
  uncompressResponse(e, r) {
    let n = r;
    const i = ["gzip", "compress", "deflate"];
    if (e["content-encoding"] && i.indexOf(e["content-encoding"]) !== -1) {
      const a = ge;
      n = n.pipe(a.createUnzip()), delete e["content-encoding"];
    }
    return n;
  }
}
class Jy {
  constructor(e) {
    this.config = e, this.config = e;
  }
  get method() {
    return this.config.method;
  }
  get url() {
    return this.config.url;
  }
  get headers() {
    return this.config.headers;
  }
  get data() {
    return this.config.data;
  }
  get timeout() {
    return this.config.timeout;
  }
  buildEntity(e) {
    let r;
    if (!this.hasEntity() || !this.isEntityEnclosingRequest())
      return r;
    if (or.isBuffer(this.data))
      r = this.data;
    else if (or.isObject(this.data))
      r = Buffer.from(JSON.stringify(this.data), "utf-8"), typeof e["content-type"] > "u" && (e["content-type"] = "application/json;charset=utf-8");
    else if (or.isString(this.data))
      r = Buffer.from(this.data, "utf-8");
    else
      throw new Error("Request data must be a string, a Buffer or a json serializable object");
    return e["Content-Length"] = r.length.toString(), r;
  }
  buildUrl() {
    const e = this.urlWithProtocol();
    if (!this.hasEntity() || this.isEntityEnclosingRequest())
      return Gu.parse(e);
    if (!or.isObject(this.data))
      throw new Error(`${this.method} requests cannot have a body`);
    const r = new Gu.URL(e), n = this.data;
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && r.searchParams.append(i, n[i]);
    return Gu.parse(r.toString());
  }
  urlWithProtocol() {
    const e = this.url;
    return e.startsWith("http://") || e.startsWith("https://") ? e : `https://${e}`;
  }
  hasEntity() {
    return !!this.data;
  }
  isEntityEnclosingRequest() {
    return this.method !== "GET" && this.method !== "HEAD";
  }
}
class Fb extends Jy {
  constructor(e) {
    super(e), this.httpConfig = e;
  }
  get httpAgent() {
    return this.httpConfig.httpAgent;
  }
  buildRequestOptions() {
    const e = this.buildUrl(), r = e.protocol;
    let n = e.port;
    return n || (n = r === "https:" ? "443" : "80"), {
      protocol: r,
      hostname: e.hostname,
      port: n,
      path: e.path,
      method: this.method,
      agent: this.httpAgent,
      headers: Object.assign({}, this.headers)
    };
  }
}
class Mb extends Jy {
  constructor(e) {
    super(e), this.http2Config = e;
  }
  get http2SessionHandler() {
    return this.http2Config.http2SessionHandler;
  }
  buildRequestOptions() {
    const e = this.buildUrl();
    return {
      protocol: e.protocol,
      path: e.path,
      method: this.method,
      headers: Object.assign({}, this.headers)
    };
  }
}
class Vb extends jy {
  constructor(e) {
    super(), this.app = e;
  }
  send(e) {
    return this.getToken().then((r) => {
      const n = Object.assign({}, e);
      n.headers = Object.assign({}, e.headers);
      const i = "Authorization";
      n.headers[i] = `Bearer ${r}`;
      let a;
      return this.app.options.credential instanceof Hy.ApplicationDefaultCredential && (a = this.app.options.credential.getQuotaProjectId()), a = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || a, !n.headers["x-goog-user-project"] && or.isNonEmptyString(a) && (n.headers["x-goog-user-project"] = a), !n.httpAgent && this.app.options.httpAgent && (n.httpAgent = this.app.options.httpAgent), n.headers["X-Goog-Api-Client"] = (0, Ky.getMetricsHeader)(), super.send(n);
    });
  }
  getToken() {
    return this.app.INTERNAL.getToken().then((e) => e.accessToken);
  }
}
tt.AuthorizedHttpClient = Vb;
class $b extends qy {
  constructor(e) {
    super(), this.app = e;
  }
  send(e) {
    return this.getToken().then((r) => {
      const n = Object.assign({}, e);
      n.headers = Object.assign({}, e.headers);
      const i = "Authorization";
      n.headers[i] = `Bearer ${r}`;
      let a;
      return this.app.options.credential instanceof Hy.ApplicationDefaultCredential && (a = this.app.options.credential.getQuotaProjectId()), a = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || a, !n.headers["x-goog-user-project"] && or.isNonEmptyString(a) && (n.headers["x-goog-user-project"] = a), n.headers["X-Goog-Api-Client"] = (0, Ky.getMetricsHeader)(), super.send(n);
    });
  }
  getToken() {
    return this.app.INTERNAL.getToken().then((e) => e.accessToken);
  }
}
tt.AuthorizedHttp2Client = $b;
class Hb {
  constructor(e, r = "POST") {
    this.endpoint = e, this.httpMethod = r, this.setRequestValidator(null).setResponseValidator(null);
  }
  /** @returns The backend API endpoint. */
  getEndpoint() {
    return this.endpoint;
  }
  /** @returns The request HTTP method. */
  getHttpMethod() {
    return this.httpMethod;
  }
  /**
   * @param requestValidator - The request validator.
   * @returns The current API settings instance.
   */
  setRequestValidator(e) {
    const r = () => {
    };
    return this.requestValidator = e || r, this;
  }
  /** @returns The request validator. */
  getRequestValidator() {
    return this.requestValidator;
  }
  /**
   * @param responseValidator - The response validator.
   * @returns The current API settings instance.
   */
  setResponseValidator(e) {
    const r = () => {
    };
    return this.responseValidator = e || r, this;
  }
  /** @returns The response validator. */
  getResponseValidator() {
    return this.responseValidator;
  }
}
tt.ApiSettings = Hb;
class Kb extends Pb.EventEmitter {
  constructor(e = 1e3, r = 1e4, n = 6e4) {
    super(), this.initialPollingDelayMillis = e, this.maxPollingDelayMillis = r, this.masterTimeoutMillis = n, this.numTries = 0, this.completed = !1;
  }
  /**
   * Poll the provided callback with exponential backoff.
   *
   * @param callback - The callback to be called for each poll. If the
   *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy
   *     resolution will be used to resolve the promise returned by this method.
   * @returns A Promise which resolves to the truthy value returned by the provided
   *     callback when polling is complete.
   */
  poll(e) {
    if (this.pollCallback)
      throw new Error("poll() can only be called once per instance of ExponentialBackoffPoller");
    return this.pollCallback = e, this.on("poll", this.repoll), this.masterTimer = setTimeout(() => {
      this.completed || (this.markCompleted(), this.reject(new Error("ExponentialBackoffPoller deadline exceeded - Master timeout reached")));
    }, this.masterTimeoutMillis), new Promise((r, n) => {
      this.resolve = r, this.reject = n, this.repoll();
    });
  }
  repoll() {
    this.pollCallback().then((e) => {
      if (!this.completed) {
        if (!e) {
          this.repollTimer = setTimeout(() => this.emit("poll"), this.getPollingDelayMillis()), this.numTries++;
          return;
        }
        this.markCompleted(), this.resolve(e);
      }
    }).catch((e) => {
      this.completed || (this.markCompleted(), this.reject(e));
    });
  }
  getPollingDelayMillis() {
    const e = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;
    return Math.min(e, this.maxPollingDelayMillis);
  }
  markCompleted() {
    this.completed = !0, this.masterTimer && clearTimeout(this.masterTimer), this.repollTimer && clearTimeout(this.repollTimer);
  }
}
tt.ExponentialBackoffPoller = Kb;
class Gb {
  constructor(e) {
    this.promise = new Promise((r, n) => {
      this.resolve = r, this.reject = n, this.http2Session = this.createSession(e);
    });
  }
  createSession(e) {
    if (!this.http2Session || this.isClosed) {
      const r = {
        // Set local max concurrent stream limit to respect backend limit
        peerMaxConcurrentStreams: 100,
        ALPNProtocols: ["h2"]
      }, n = Lb.connect(e, r);
      return n.on("goaway", (i, a, s) => {
        this.reject(new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_ERROR, `Error while making requests: GOAWAY - ${s == null ? void 0 : s.toString()}, Error code: ${i}`));
      }), n.on("error", (i) => {
        let a;
        i.name == "AggregateError" && i.errors ? a = `Session error while making requests: ${i.code} - ${i.name}: [${i.errors.map((s) => s.message).join(", ")}]` : a = `Session error while making requests: ${i.code} - ${i.message} `, this.reject(new Be.FirebaseAppError(Be.AppErrorCodes.NETWORK_ERROR, a));
      }), n.on("close", () => {
        this.resolve();
      }), n;
    }
    return this.http2Session;
  }
  invoke() {
    return this.promise;
  }
  get session() {
    return this.http2Session;
  }
  get isClosed() {
    return this.http2Session.closed;
  }
  close() {
    this.http2Session.close();
  }
}
tt.Http2SessionHandler = Gb;
var ka = {};
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.UserImportBuilder = void 0;
ka.convertMultiFactorInfoToServerFormat = zy;
const rs = vr, ua = at, jt = Ue, Oe = Te;
function zy(t) {
  let e;
  if (typeof t.enrollmentTime < "u")
    if (jt.isUTCDateString(t.enrollmentTime))
      e = new Date(t.enrollmentTime).toISOString();
    else
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${t.uid}" must be a valid UTC date string.`);
  if (jb(t)) {
    const r = {
      mfaEnrollmentId: t.uid,
      displayName: t.displayName,
      // Required for all phone second factors.
      phoneInfo: t.phoneNumber,
      enrolledAt: e
    };
    for (const n in r)
      typeof r[n] > "u" && delete r[n];
    return r;
  } else
    throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor "${JSON.stringify(t)}" provided.`);
}
function jb(t) {
  return t.factorId === "phone";
}
function yn(t, e) {
  return typeof t[e] < "u" && t[e] !== null ? parseInt(t[e].toString(), 10) : NaN;
}
function qb(t, e) {
  const r = {
    localId: t.uid,
    email: t.email,
    emailVerified: t.emailVerified,
    displayName: t.displayName,
    disabled: t.disabled,
    photoUrl: t.photoURL,
    phoneNumber: t.phoneNumber,
    providerUserInfo: [],
    mfaInfo: [],
    tenantId: t.tenantId,
    customAttributes: t.customClaims && JSON.stringify(t.customClaims)
  };
  if (typeof t.passwordHash < "u") {
    if (!jt.isBuffer(t.passwordHash))
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_PASSWORD_HASH);
    r.passwordHash = ua.toWebSafeBase64(t.passwordHash);
  }
  if (typeof t.passwordSalt < "u") {
    if (!jt.isBuffer(t.passwordSalt))
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_PASSWORD_SALT);
    r.salt = ua.toWebSafeBase64(t.passwordSalt);
  }
  jt.isNonNullObject(t.metadata) && (jt.isNonEmptyString(t.metadata.creationTime) && (r.createdAt = new Date(t.metadata.creationTime).getTime()), jt.isNonEmptyString(t.metadata.lastSignInTime) && (r.lastLoginAt = new Date(t.metadata.lastSignInTime).getTime())), jt.isArray(t.providerData) && t.providerData.forEach((i) => {
    r.providerUserInfo.push({
      providerId: i.providerId,
      rawId: i.uid,
      email: i.email,
      displayName: i.displayName,
      photoUrl: i.photoURL
    });
  }), jt.isNonNullObject(t.multiFactor) && jt.isNonEmptyArray(t.multiFactor.enrolledFactors) && t.multiFactor.enrolledFactors.forEach((i) => {
    r.mfaInfo.push(zy(i));
  });
  let n;
  for (n in r)
    typeof r[n] > "u" && delete r[n];
  return r.providerUserInfo.length === 0 && delete r.providerUserInfo, r.mfaInfo.length === 0 && delete r.mfaInfo, typeof e == "function" && e(r), r;
}
class Wb {
  /**
   * @param {UserImportRecord[]} users The list of user records to import.
   * @param {UserImportOptions=} options The import options which includes hashing
   *     algorithm details.
   * @param {ValidatorFunction=} userRequestValidator The user request validator function.
   * @constructor
   */
  constructor(e, r, n) {
    this.requiresHashOptions = !1, this.validatedUsers = [], this.userImportResultErrors = [], this.indexMap = {}, this.validatedUsers = this.populateUsers(e, n), this.validatedOptions = this.populateOptions(r, this.requiresHashOptions);
  }
  /**
   * Returns the corresponding constructed uploadAccount request.
   * @returns {UploadAccountRequest} The constructed uploadAccount request.
   */
  buildRequest() {
    const e = this.validatedUsers.map((r) => (0, rs.deepCopy)(r));
    return (0, rs.deepExtend)({ users: e }, (0, rs.deepCopy)(this.validatedOptions));
  }
  /**
   * Populates the UserImportResult using the client side detected errors and the server
   * side returned errors.
   * @returns {UserImportResult} The user import result based on the returned failed
   *     uploadAccount response.
   */
  buildResponse(e) {
    const r = {
      successCount: this.validatedUsers.length,
      failureCount: this.userImportResultErrors.length,
      errors: (0, rs.deepCopy)(this.userImportResultErrors)
    };
    return r.failureCount += e.length, r.successCount -= e.length, e.forEach((n) => {
      r.errors.push({
        // Map backend request index to original developer provided array index.
        index: this.indexMap[n.index],
        error: new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_USER_IMPORT, n.message)
      });
    }), r.errors.sort((n, i) => n.index - i.index), r;
  }
  /**
   * Validates and returns the hashing options of the uploadAccount request.
   * Throws an error whenever an invalid or missing options is detected.
   * @param {UserImportOptions} options The UserImportOptions.
   * @param {boolean} requiresHashOptions Whether to require hash options.
   * @returns {UploadAccountOptions} The populated UploadAccount options.
   */
  populateOptions(e, r) {
    let n;
    if (!r)
      return {};
    if (!jt.isNonNullObject(e))
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_ARGUMENT, '"UserImportOptions" are required when importing users with passwords.');
    if (!jt.isNonNullObject(e.hash))
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '"hash.algorithm" is missing from the provided "UserImportOptions".');
    if (typeof e.hash.algorithm > "u" || !jt.isNonEmptyString(e.hash.algorithm))
      throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '"hash.algorithm" must be a string matching the list of supported algorithms.');
    let i;
    switch (e.hash.algorithm) {
      case "HMAC_SHA512":
      case "HMAC_SHA256":
      case "HMAC_SHA1":
      case "HMAC_MD5":
        if (!jt.isBuffer(e.hash.key))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_KEY, `A non-empty "hash.key" byte buffer must be provided for hash algorithm ${e.hash.algorithm}.`);
        n = {
          hashAlgorithm: e.hash.algorithm,
          signerKey: ua.toWebSafeBase64(e.hash.key)
        };
        break;
      case "MD5":
      case "SHA1":
      case "SHA256":
      case "SHA512": {
        i = yn(e.hash, "rounds");
        const a = e.hash.algorithm === "MD5" ? 0 : 1;
        if (isNaN(i) || i < a || i > 8192)
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between ${a} and 8192 must be provided for hash algorithm ${e.hash.algorithm}.`);
        n = {
          hashAlgorithm: e.hash.algorithm,
          rounds: i
        };
        break;
      }
      case "PBKDF_SHA1":
      case "PBKDF2_SHA256":
        if (i = yn(e.hash, "rounds"), isNaN(i) || i < 0 || i > 12e4)
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 0 and 120000 must be provided for hash algorithm ${e.hash.algorithm}.`);
        n = {
          hashAlgorithm: e.hash.algorithm,
          rounds: i
        };
        break;
      case "SCRYPT": {
        if (!jt.isBuffer(e.hash.key))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_KEY, `A "hash.key" byte buffer must be provided for hash algorithm ${e.hash.algorithm}.`);
        if (i = yn(e.hash, "rounds"), isNaN(i) || i <= 0 || i > 8)
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 1 and 8 must be provided for hash algorithm ${e.hash.algorithm}.`);
        const a = yn(e.hash, "memoryCost");
        if (isNaN(a) || a <= 0 || a > 14)
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number between 1 and 14 must be provided for hash algorithm ${e.hash.algorithm}.`);
        if (typeof e.hash.saltSeparator < "u" && !jt.isBuffer(e.hash.saltSeparator))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '"hash.saltSeparator" must be a byte buffer.');
        n = {
          hashAlgorithm: e.hash.algorithm,
          signerKey: ua.toWebSafeBase64(e.hash.key),
          rounds: i,
          memoryCost: a,
          saltSeparator: ua.toWebSafeBase64(e.hash.saltSeparator || Buffer.from(""))
        };
        break;
      }
      case "BCRYPT":
        n = {
          hashAlgorithm: e.hash.algorithm
        };
        break;
      case "STANDARD_SCRYPT": {
        const a = yn(e.hash, "memoryCost");
        if (isNaN(a))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number must be provided for hash algorithm ${e.hash.algorithm}.`);
        const s = yn(e.hash, "parallelization");
        if (isNaN(s))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, `A valid "hash.parallelization" number must be provided for hash algorithm ${e.hash.algorithm}.`);
        const o = yn(e.hash, "blockSize");
        if (isNaN(o))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, `A valid "hash.blockSize" number must be provided for hash algorithm ${e.hash.algorithm}.`);
        const l = yn(e.hash, "derivedKeyLength");
        if (isNaN(l))
          throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, `A valid "hash.derivedKeyLength" number must be provided for hash algorithm ${e.hash.algorithm}.`);
        n = {
          hashAlgorithm: e.hash.algorithm,
          cpuMemCost: a,
          parallelization: s,
          blockSize: o,
          dkLen: l
        };
        break;
      }
      default:
        throw new Oe.FirebaseAuthError(Oe.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider "${e.hash.algorithm}".`);
    }
    return n;
  }
  /**
   * Validates and returns the users list of the uploadAccount request.
   * Whenever a user with an error is detected, the error is cached and will later be
   * merged into the user import result. This allows the processing of valid users without
   * failing early on the first error detected.
   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser
   *     objects.
   * @param {ValidatorFunction=} userValidator The user validator function.
   * @returns {UploadAccountUser[]} The populated uploadAccount users.
   */
  populateUsers(e, r) {
    const n = [];
    return e.forEach((i, a) => {
      try {
        const s = qb(i, r);
        typeof s.passwordHash < "u" && (this.requiresHashOptions = !0), n.push(s), this.indexMap[n.length - 1] = a;
      } catch (s) {
        this.userImportResultErrors.push({
          index: a,
          error: s
        });
      }
    }), n;
  }
}
ka.UserImportBuilder = Wb;
var Mo = {};
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.ActionCodeSettingsBuilder = void 0;
const Ir = Ue, Je = Te;
class Jb {
  /**
   * ActionCodeSettingsBuilder constructor.
   *
   * @param {ActionCodeSettings} actionCodeSettings The ActionCodeSettings
   *     object used to initiliaze this server request builder.
   * @constructor
   */
  constructor(e) {
    if (!Ir.isNonNullObject(e))
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings" must be a non-null object.');
    if (typeof e.url > "u")
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.MISSING_CONTINUE_URI);
    if (!Ir.isURL(e.url))
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_CONTINUE_URI);
    if (this.continueUrl = e.url, typeof e.handleCodeInApp < "u" && !Ir.isBoolean(e.handleCodeInApp))
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.handleCodeInApp" must be a boolean.');
    if (this.canHandleCodeInApp = e.handleCodeInApp || !1, typeof e.dynamicLinkDomain < "u" && !Ir.isNonEmptyString(e.dynamicLinkDomain))
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN);
    if (this.dynamicLinkDomain = e.dynamicLinkDomain, typeof e.linkDomain < "u" && !Ir.isNonEmptyString(e.linkDomain))
      throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_HOSTING_LINK_DOMAIN);
    if (this.linkDomain = e.linkDomain, typeof e.iOS < "u") {
      if (Ir.isNonNullObject(e.iOS)) {
        if (typeof e.iOS.bundleId > "u")
          throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.MISSING_IOS_BUNDLE_ID);
        if (!Ir.isNonEmptyString(e.iOS.bundleId))
          throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS.bundleId" must be a valid non-empty string.');
      } else throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS" must be a valid non-null object.');
      this.ibi = e.iOS.bundleId;
    }
    if (typeof e.android < "u") {
      if (Ir.isNonNullObject(e.android)) {
        if (typeof e.android.packageName > "u")
          throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME);
        if (Ir.isNonEmptyString(e.android.packageName)) {
          if (typeof e.android.minimumVersion < "u" && !Ir.isNonEmptyString(e.android.minimumVersion))
            throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.minimumVersion" must be a valid non-empty string.');
          if (typeof e.android.installApp < "u" && !Ir.isBoolean(e.android.installApp))
            throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.installApp" must be a valid boolean.');
        } else throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.packageName" must be a valid non-empty string.');
      } else throw new Je.FirebaseAuthError(Je.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android" must be a valid non-null object.');
      this.apn = e.android.packageName, this.amv = e.android.minimumVersion, this.installApp = e.android.installApp || !1;
    }
  }
  /**
   * Returns the corresponding constructed server request corresponding to the
   * current ActionCodeSettings.
   *
   * @returns The constructed EmailActionCodeRequest request.
   */
  buildRequest() {
    const e = {
      continueUrl: this.continueUrl,
      canHandleCodeInApp: this.canHandleCodeInApp,
      dynamicLinkDomain: this.dynamicLinkDomain,
      linkDomain: this.linkDomain,
      androidPackageName: this.apn,
      androidMinimumVersion: this.amv,
      androidInstallApp: this.installApp,
      iOSBundleId: this.ibi
    };
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (typeof e[r] > "u" || e[r] === null) && delete e[r];
    return e;
  }
}
Mo.ActionCodeSettingsBuilder = Jb;
var Hi = {}, Ba = {};
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EmailPrivacyAuthConfig = t.PasswordPolicyAuthConfig = t.MobileLinksAuthConfig = t.RecaptchaAuthConfig = t.SmsRegionsAuthConfig = t.OIDCConfig = t.SAMLConfig = t.EmailSignInConfig = t.MultiFactorAuthConfig = t.MAXIMUM_TEST_PHONE_NUMBERS = void 0, t.validateTestPhoneNumbers = o;
  const e = Ue, r = vr, n = Te;
  t.MAXIMUM_TEST_PHONE_NUMBERS = 10;
  const i = {
    phone: "PHONE_SMS"
  }, a = Object.keys(i).reduce((I, c) => (I[i[c]] = c, I), {});
  class s {
    /**
     * Static method to convert a client side request to a MultiFactorAuthServerConfig.
     * Throws an error if validation fails.
     *
     * @param options - The options object to convert to a server request.
     * @returns The resulting server request.
     * @internal
     */
    static buildServerRequest(c) {
      const E = {};
      return s.validate(c), Object.prototype.hasOwnProperty.call(c, "state") && (E.state = c.state), Object.prototype.hasOwnProperty.call(c, "factorIds") && ((c.factorIds || []).forEach((v) => {
        typeof E.enabledProviders > "u" && (E.enabledProviders = []), E.enabledProviders.push(i[v]);
      }), c.factorIds && c.factorIds.length === 0 && (E.enabledProviders = [])), Object.prototype.hasOwnProperty.call(c, "providerConfigs") && (E.providerConfigs = c.providerConfigs), E;
    }
    /**
     * Validates the MultiFactorConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     */
    static validate(c) {
      const E = {
        state: !0,
        factorIds: !0,
        providerConfigs: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid MultiFactorConfig parameter.`);
      if (typeof c.state < "u" && c.state !== "ENABLED" && c.state !== "DISABLED")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.state" must be either "ENABLED" or "DISABLED".');
      if (typeof c.factorIds < "u") {
        if (!e.isArray(c.factorIds))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.factorIds" must be an array of valid "AuthFactorTypes".');
        c.factorIds.forEach((v) => {
          if (typeof i[v] > "u")
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid "AuthFactorType".`);
        });
      }
      if (typeof c.providerConfigs < "u") {
        if (!e.isArray(c.providerConfigs))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs" must be an array of valid "MultiFactorProviderConfig."');
        c.providerConfigs.forEach((v) => {
          if (typeof v > "u" || !e.isObject(v))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid "MultiFactorProviderConfig" type.`);
          const R = {
            state: !0,
            totpProviderConfig: !0
          };
          for (const h in v)
            if (!(h in R))
              throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${h}" is not a valid ProviderConfig parameter.`);
          if (typeof v.state > "u" || v.state !== "ENABLED" && v.state !== "DISABLED")
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.state" must be either "ENABLED" or "DISABLED".');
          if (typeof v.totpProviderConfig > "u")
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.totpProviderConfig" must be defined.');
          const N = {
            adjacentIntervals: !0
          };
          for (const h in v.totpProviderConfig)
            if (!(h in N))
              throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${h}" is not a valid TotpProviderConfig parameter.`);
          const C = v.totpProviderConfig.adjacentIntervals;
          if (typeof C < "u" && (!Number.isInteger(C) || C < 0 || C > 10))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals" must be a valid number between 0 and 10 (both inclusive).');
        });
      }
    }
    /**
     * The MultiFactorAuthConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     MultiFactorAuthConfig object.
     * @constructor
     * @internal
     */
    constructor(c) {
      if (typeof c.state > "u")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
      this.state = c.state, this.factorIds = [], (c.enabledProviders || []).forEach((E) => {
        typeof a[E] < "u" && this.factorIds.push(a[E]);
      }), this.providerConfigs = [], (c.providerConfigs || []).forEach((E) => {
        if (typeof E < "u") {
          if (typeof E.state > "u" || typeof E.totpProviderConfig > "u" || typeof E.totpProviderConfig.adjacentIntervals < "u" && typeof E.totpProviderConfig.adjacentIntervals != "number")
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
          this.providerConfigs.push(E);
        }
      });
    }
    /** Converts MultiFactorConfig to JSON object
     * @returns The plain object representation of the multi-factor config instance. */
    toJSON() {
      return {
        state: this.state,
        factorIds: this.factorIds,
        providerConfigs: this.providerConfigs
      };
    }
  }
  t.MultiFactorAuthConfig = s;
  function o(I) {
    if (!e.isObject(I))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"testPhoneNumbers" must be a map of phone number / code pairs.');
    if (Object.keys(I).length > t.MAXIMUM_TEST_PHONE_NUMBERS)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);
    for (const c in I) {
      if (!e.isPhoneNumber(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${c}" is not a valid E.164 standard compliant phone number.`);
      if (!e.isString(I[c]) || !/^[\d]{6}$/.test(I[c]))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${I[c]}" is not a valid 6 digit code string.`);
    }
  }
  class l {
    /**
     * Static method to convert a client side request to a EmailSignInConfigServerRequest.
     * Throws an error if validation fails.
     *
     * @param options - The options object to convert to a server request.
     * @returns The resulting server request.
     * @internal
     */
    static buildServerRequest(c) {
      const E = {};
      return l.validate(c), Object.prototype.hasOwnProperty.call(c, "enabled") && (E.allowPasswordSignup = c.enabled), Object.prototype.hasOwnProperty.call(c, "passwordRequired") && (E.enableEmailLinkSignin = !c.passwordRequired), E;
    }
    /**
     * Validates the EmailSignInConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     */
    static validate(c) {
      const E = {
        enabled: !0,
        passwordRequired: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `"${v}" is not a valid EmailSignInConfig parameter.`);
      if (typeof c.enabled < "u" && !e.isBoolean(c.enabled))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.enabled" must be a boolean.');
      if (typeof c.passwordRequired < "u" && !e.isBoolean(c.passwordRequired))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.passwordRequired" must be a boolean.');
    }
    /**
     * The EmailSignInConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     EmailSignInConfig object.
     * @constructor
     */
    constructor(c) {
      if (typeof c.allowPasswordSignup > "u")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid email sign-in configuration response");
      this.enabled = c.allowPasswordSignup, this.passwordRequired = !c.enableEmailLinkSignin;
    }
    /** @returns The plain object representation of the email sign-in config. */
    toJSON() {
      return {
        enabled: this.enabled,
        passwordRequired: this.passwordRequired
      };
    }
  }
  t.EmailSignInConfig = l;
  class u {
    /**
     * Converts a client side request to a SAMLConfigServerRequest which is the format
     * accepted by the backend server.
     * Throws an error if validation fails. If the request is not a SAMLConfig request,
     * returns null.
     *
     * @param options - The options object to convert to a server request.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     * @returns The resulting server request or null if not valid.
     */
    static buildServerRequest(c, E = !1) {
      if (!(e.isNonNullObject(c) && (c.providerId || E)))
        return null;
      const R = {};
      if (u.validate(c, E), R.enabled = c.enabled, R.displayName = c.displayName, (c.idpEntityId || c.ssoURL || c.x509Certificates) && (R.idpConfig = {
        idpEntityId: c.idpEntityId,
        ssoUrl: c.ssoURL,
        signRequest: c.enableRequestSigning,
        idpCertificates: typeof c.x509Certificates > "u" ? void 0 : []
      }, c.x509Certificates))
        for (const N of c.x509Certificates || [])
          R.idpConfig.idpCertificates.push({ x509Certificate: N });
      return (c.callbackURL || c.rpEntityId) && (R.spConfig = {
        spEntityId: c.rpEntityId,
        callbackUri: c.callbackURL
      }), R;
    }
    /**
     * Returns the provider ID corresponding to the resource name if available.
     *
     * @param resourceName - The server side resource name.
     * @returns The provider ID corresponding to the resource, null otherwise.
     */
    static getProviderIdFromResourceName(c) {
      const E = c.match(/\/inboundSamlConfigs\/(saml\..*)$/);
      return !E || E.length < 2 ? null : E[1];
    }
    /**
     * @param providerId - The provider ID to check.
     * @returns Whether the provider ID corresponds to a SAML provider.
     */
    static isProviderId(c) {
      return e.isNonEmptyString(c) && c.indexOf("saml.") === 0;
    }
    /**
     * Validates the SAMLConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     */
    static validate(c, E = !1) {
      const v = {
        enabled: !0,
        displayName: !0,
        providerId: !0,
        idpEntityId: !0,
        ssoURL: !0,
        x509Certificates: !0,
        rpEntityId: !0,
        callbackURL: !0,
        enableRequestSigning: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig" must be a valid non-null object.');
      for (const R in c)
        if (!(R in v))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${R}" is not a valid SAML config parameter.`);
      if (e.isNonEmptyString(c.providerId)) {
        if (c.providerId.indexOf("saml.") !== 0)
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
      } else if (!E)
        throw new n.FirebaseAuthError(c.providerId ? n.AuthClientErrorCode.INVALID_PROVIDER_ID : n.AuthClientErrorCode.MISSING_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
      if (!(E && typeof c.idpEntityId > "u") && !e.isNonEmptyString(c.idpEntityId))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.idpEntityId" must be a valid non-empty string.');
      if (!(E && typeof c.ssoURL > "u") && !e.isURL(c.ssoURL))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.ssoURL" must be a valid URL string.');
      if (!(E && typeof c.rpEntityId > "u") && !e.isNonEmptyString(c.rpEntityId))
        throw new n.FirebaseAuthError(c.rpEntityId ? n.AuthClientErrorCode.INVALID_CONFIG : n.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG, '"SAMLAuthProviderConfig.rpEntityId" must be a valid non-empty string.');
      if (!(E && typeof c.callbackURL > "u") && !e.isURL(c.callbackURL))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.callbackURL" must be a valid URL string.');
      if (!(E && typeof c.x509Certificates > "u") && !e.isArray(c.x509Certificates))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
      if ((c.x509Certificates || []).forEach((R) => {
        if (!e.isNonEmptyString(R))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
      }), typeof c.enableRequestSigning < "u" && !e.isBoolean(c.enableRequestSigning))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enableRequestSigning" must be a boolean.');
      if (typeof c.enabled < "u" && !e.isBoolean(c.enabled))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enabled" must be a boolean.');
      if (typeof c.displayName < "u" && !e.isString(c.displayName))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.displayName" must be a valid string.');
    }
    /**
     * The SAMLConfig constructor.
     *
     * @param response - The server side response used to initialize the SAMLConfig object.
     * @constructor
     */
    constructor(c) {
      if (!c || !c.idpConfig || !c.idpConfig.idpEntityId || !c.idpConfig.ssoUrl || !c.spConfig || !c.spConfig.spEntityId || !c.name || !(e.isString(c.name) && u.getProviderIdFromResourceName(c.name)))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
      const E = u.getProviderIdFromResourceName(c.name);
      if (!E)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
      this.providerId = E, this.rpEntityId = c.spConfig.spEntityId, this.callbackURL = c.spConfig.callbackUri, this.idpEntityId = c.idpConfig.idpEntityId, this.ssoURL = c.idpConfig.ssoUrl, this.enableRequestSigning = !!c.idpConfig.signRequest;
      const v = [];
      for (const R of c.idpConfig.idpCertificates || [])
        R.x509Certificate && v.push(R.x509Certificate);
      this.x509Certificates = v, this.enabled = !!c.enabled, this.displayName = c.displayName;
    }
    /** @returns The plain object representation of the SAMLConfig. */
    toJSON() {
      return {
        enabled: this.enabled,
        displayName: this.displayName,
        providerId: this.providerId,
        idpEntityId: this.idpEntityId,
        ssoURL: this.ssoURL,
        x509Certificates: (0, r.deepCopy)(this.x509Certificates),
        rpEntityId: this.rpEntityId,
        callbackURL: this.callbackURL,
        enableRequestSigning: this.enableRequestSigning
      };
    }
  }
  t.SAMLConfig = u;
  class f {
    /**
     * Converts a client side request to a OIDCConfigServerRequest which is the format
     * accepted by the backend server.
     * Throws an error if validation fails. If the request is not a OIDCConfig request,
     * returns null.
     *
     * @param options - The options object to convert to a server request.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     * @returns The resulting server request or null if not valid.
     */
    static buildServerRequest(c, E = !1) {
      if (!(e.isNonNullObject(c) && (c.providerId || E)))
        return null;
      const R = {};
      return f.validate(c, E), R.enabled = c.enabled, R.displayName = c.displayName, R.issuer = c.issuer, R.clientId = c.clientId, typeof c.clientSecret < "u" && (R.clientSecret = c.clientSecret), typeof c.responseType < "u" && (R.responseType = c.responseType), R;
    }
    /**
     * Returns the provider ID corresponding to the resource name if available.
     *
     * @param resourceName - The server side resource name
     * @returns The provider ID corresponding to the resource, null otherwise.
     */
    static getProviderIdFromResourceName(c) {
      const E = c.match(/\/oauthIdpConfigs\/(oidc\..*)$/);
      return !E || E.length < 2 ? null : E[1];
    }
    /**
     * @param providerId - The provider ID to check.
     * @returns Whether the provider ID corresponds to an OIDC provider.
     */
    static isProviderId(c) {
      return e.isNonEmptyString(c) && c.indexOf("oidc.") === 0;
    }
    /**
     * Validates the OIDCConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     */
    static validate(c, E = !1) {
      const v = {
        enabled: !0,
        displayName: !0,
        providerId: !0,
        clientId: !0,
        issuer: !0,
        clientSecret: !0,
        responseType: !0
      }, R = {
        idToken: !0,
        code: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig" must be a valid non-null object.');
      for (const N in c)
        if (!(N in v))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${N}" is not a valid OIDC config parameter.`);
      if (e.isNonEmptyString(c.providerId)) {
        if (c.providerId.indexOf("oidc.") !== 0)
          throw new n.FirebaseAuthError(c.providerId ? n.AuthClientErrorCode.INVALID_PROVIDER_ID : n.AuthClientErrorCode.MISSING_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
      } else if (!E)
        throw new n.FirebaseAuthError(c.providerId ? n.AuthClientErrorCode.INVALID_PROVIDER_ID : n.AuthClientErrorCode.MISSING_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
      if (!(E && typeof c.clientId > "u") && !e.isNonEmptyString(c.clientId))
        throw new n.FirebaseAuthError(c.clientId ? n.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID : n.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID, '"OIDCAuthProviderConfig.clientId" must be a valid non-empty string.');
      if (!(E && typeof c.issuer > "u") && !e.isURL(c.issuer))
        throw new n.FirebaseAuthError(c.issuer ? n.AuthClientErrorCode.INVALID_CONFIG : n.AuthClientErrorCode.MISSING_ISSUER, '"OIDCAuthProviderConfig.issuer" must be a valid URL string.');
      if (typeof c.enabled < "u" && !e.isBoolean(c.enabled))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.enabled" must be a boolean.');
      if (typeof c.displayName < "u" && !e.isString(c.displayName))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.displayName" must be a valid string.');
      if (typeof c.clientSecret < "u" && !e.isNonEmptyString(c.clientSecret))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.clientSecret" must be a valid string.');
      if (e.isNonNullObject(c.responseType) && typeof c.responseType < "u") {
        Object.keys(c.responseType).forEach((O) => {
          if (!(O in R))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${O}" is not a valid OAuthResponseType parameter.`);
        });
        const N = c.responseType.idToken;
        if (typeof N < "u" && !e.isBoolean(N))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.idToken" must be a boolean.');
        const C = c.responseType.code;
        if (typeof C < "u") {
          if (!e.isBoolean(C))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.code" must be a boolean.');
          if (C && typeof c.clientSecret > "u")
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, "The OAuth configuration client secret is required to enable OIDC code flow.");
        }
        const h = Object.keys(c.responseType).length, d = Object.values(c.responseType).filter(Boolean).length;
        if (h > 1 && d !== 1)
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, "Only exactly one OAuth responseType should be set to true.");
      }
    }
    /**
     * The OIDCConfig constructor.
     *
     * @param response - The server side response used to initialize the OIDCConfig object.
     * @constructor
     */
    constructor(c) {
      if (!c || !c.issuer || !c.clientId || !c.name || !(e.isString(c.name) && f.getProviderIdFromResourceName(c.name)))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid OIDC configuration response");
      const E = f.getProviderIdFromResourceName(c.name);
      if (!E)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
      this.providerId = E, this.clientId = c.clientId, this.issuer = c.issuer, this.enabled = !!c.enabled, this.displayName = c.displayName, typeof c.clientSecret < "u" && (this.clientSecret = c.clientSecret), typeof c.responseType < "u" && (this.responseType = c.responseType);
    }
    /** @returns The plain object representation of the OIDCConfig. */
    toJSON() {
      return {
        enabled: this.enabled,
        displayName: this.displayName,
        providerId: this.providerId,
        issuer: this.issuer,
        clientId: this.clientId,
        clientSecret: (0, r.deepCopy)(this.clientSecret),
        responseType: (0, r.deepCopy)(this.responseType)
      };
    }
  }
  t.OIDCConfig = f;
  class y {
    static validate(c) {
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig" must be a non-null object.');
      const E = {
        allowlistOnly: !0,
        allowByDefault: !0
      };
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid SmsRegionConfig parameter.`);
      if (typeof c.allowByDefault < "u" && typeof c.allowlistOnly < "u")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both "allowByDefault" and "allowlistOnly" parameters.');
      if (typeof c.allowByDefault < "u") {
        const v = {
          disallowedRegions: !0
        };
        for (const R in c.allowByDefault)
          if (!(R in v))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${R}" is not a valid SmsRegionConfig.allowByDefault parameter.`);
        if (typeof c.allowByDefault.disallowedRegions < "u" && !e.isArray(c.allowByDefault.disallowedRegions))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowByDefault.disallowedRegions" must be a valid string array.');
      }
      if (typeof c.allowlistOnly < "u") {
        const v = {
          allowedRegions: !0
        };
        for (const R in c.allowlistOnly)
          if (!(R in v))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${R}" is not a valid SmsRegionConfig.allowlistOnly parameter.`);
        if (typeof c.allowlistOnly.allowedRegions < "u" && !e.isArray(c.allowlistOnly.allowedRegions))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowlistOnly.allowedRegions" must be a valid string array.');
      }
    }
  }
  t.SmsRegionsAuthConfig = y;
  class m {
    /**
     * The RecaptchaAuthConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     RecaptchaAuthConfig object.
     * @constructor
     * @internal
     */
    constructor(c) {
      const E = Object.fromEntries(Object.entries(c).filter(([, v]) => v !== void 0));
      E.tollFraudManagedRules !== void 0 && (this.smsTollFraudManagedRules = E.tollFraudManagedRules, delete E.tollFraudManagedRules), Object.assign(this, E);
    }
    /**
     * Builds a server request object from the client-side RecaptchaConfig.
     * Converts client-side fields to their server-side equivalents.
     *
     * @param options - The client-side RecaptchaConfig object.
     * @returns The server-side RecaptchaAuthServerConfig object.
     */
    static buildServerRequest(c) {
      m.validate(c);
      const E = {};
      return typeof c.emailPasswordEnforcementState < "u" && (E.emailPasswordEnforcementState = c.emailPasswordEnforcementState), typeof c.phoneEnforcementState < "u" && (E.phoneEnforcementState = c.phoneEnforcementState), typeof c.managedRules < "u" && (E.managedRules = c.managedRules), typeof c.recaptchaKeys < "u" && (E.recaptchaKeys = c.recaptchaKeys), typeof c.useAccountDefender < "u" && (E.useAccountDefender = c.useAccountDefender), typeof c.useSmsBotScore < "u" && (E.useSmsBotScore = c.useSmsBotScore), typeof c.useSmsTollFraudProtection < "u" && (E.useSmsTollFraudProtection = c.useSmsTollFraudProtection), typeof c.smsTollFraudManagedRules < "u" && (E.tollFraudManagedRules = c.smsTollFraudManagedRules), E;
    }
    /**
     * Validates the RecaptchaConfig options object. Throws an error on failure.
     * @param options - The options object to validate.
     */
    static validate(c) {
      const E = {
        emailPasswordEnforcementState: !0,
        phoneEnforcementState: !0,
        managedRules: !0,
        recaptchaKeys: !0,
        useAccountDefender: !0,
        useSmsBotScore: !0,
        useSmsTollFraudProtection: !0,
        smsTollFraudManagedRules: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid RecaptchaConfig parameter.`);
      if (typeof c.emailPasswordEnforcementState < "u") {
        if (!e.isNonEmptyString(c.emailPasswordEnforcementState))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.emailPasswordEnforcementState" must be a valid non-empty string.');
        if (c.emailPasswordEnforcementState !== "OFF" && c.emailPasswordEnforcementState !== "AUDIT" && c.emailPasswordEnforcementState !== "ENFORCE")
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.emailPasswordEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
      }
      if (typeof c.phoneEnforcementState < "u") {
        if (!e.isNonEmptyString(c.phoneEnforcementState))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.phoneEnforcementState" must be a valid non-empty string.');
        if (c.phoneEnforcementState !== "OFF" && c.phoneEnforcementState !== "AUDIT" && c.phoneEnforcementState !== "ENFORCE")
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.phoneEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
      }
      if (typeof c.managedRules < "u") {
        if (!e.isArray(c.managedRules))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.managedRules" must be an array of valid "RecaptchaManagedRule".');
        c.managedRules.forEach((v) => {
          m.validateManagedRule(v);
        });
      }
      if (typeof c.useAccountDefender < "u" && !e.isBoolean(c.useAccountDefender))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useAccountDefender" must be a boolean value".');
      if (typeof c.useSmsBotScore < "u" && !e.isBoolean(c.useSmsBotScore))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsBotScore" must be a boolean value".');
      if (typeof c.useSmsTollFraudProtection < "u" && !e.isBoolean(c.useSmsTollFraudProtection))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsTollFraudProtection" must be a boolean value".');
      if (typeof c.smsTollFraudManagedRules < "u") {
        if (!e.isArray(c.smsTollFraudManagedRules))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.smsTollFraudManagedRules" must be an array of valid "RecaptchaTollFraudManagedRule".');
        c.smsTollFraudManagedRules.forEach((v) => {
          m.validateTollFraudManagedRule(v);
        });
      }
    }
    /**
     * Validate each element in ManagedRule array
     * @param options - The options object to validate.
     */
    static validateManagedRule(c) {
      const E = {
        endScore: !0,
        action: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid RecaptchaManagedRule parameter.`);
      if (typeof c.action < "u" && c.action !== "BLOCK")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule.action" must be "BLOCK".');
    }
    /**
     * Validate each element in TollFraudManagedRule array
     * @param options - The options object to validate.
     */
    static validateTollFraudManagedRule(c) {
      const E = {
        startScore: !0,
        action: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid RecaptchaTollFraudManagedRule parameter.`);
      if (typeof c.action < "u" && c.action !== "BLOCK")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule.action" must be "BLOCK".');
    }
  }
  t.RecaptchaAuthConfig = m;
  class p {
    static validate(c) {
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MobileLinksConfig" must be a non-null object.');
      const E = {
        domain: !0
      };
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid "MobileLinksConfig" parameter.`);
      if (typeof c.domain < "u" && c.domain !== "HOSTING_DOMAIN" && c.domain !== "FIREBASE_DYNAMIC_LINK_DOMAIN")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"MobileLinksConfig.domain" must be either "HOSTING_DOMAIN" or "FIREBASE_DYNAMIC_LINK_DOMAIN".');
    }
  }
  t.MobileLinksAuthConfig = p;
  class S {
    /**
     * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.
     * Throws an error if validation fails.
     *
     * @param options - The options object to convert to a server request.
     * @returns The resulting server request.
     * @internal
     */
    static buildServerRequest(c) {
      var R, N, C, h, d, O;
      const E = {};
      S.validate(c), Object.prototype.hasOwnProperty.call(c, "enforcementState") && (E.passwordPolicyEnforcementState = c.enforcementState), E.forceUpgradeOnSignin = !1, Object.prototype.hasOwnProperty.call(c, "forceUpgradeOnSignin") && (E.forceUpgradeOnSignin = c.forceUpgradeOnSignin);
      const v = {
        containsUppercaseCharacter: !1,
        containsLowercaseCharacter: !1,
        containsNonAlphanumericCharacter: !1,
        containsNumericCharacter: !1,
        minPasswordLength: 6,
        maxPasswordLength: 4096
      };
      return E.passwordPolicyVersions = [], Object.prototype.hasOwnProperty.call(c, "constraints") && c && (((R = c.constraints) == null ? void 0 : R.requireUppercase) !== void 0 && (v.containsUppercaseCharacter = c.constraints.requireUppercase), ((N = c.constraints) == null ? void 0 : N.requireLowercase) !== void 0 && (v.containsLowercaseCharacter = c.constraints.requireLowercase), ((C = c.constraints) == null ? void 0 : C.requireNonAlphanumeric) !== void 0 && (v.containsNonAlphanumericCharacter = c.constraints.requireNonAlphanumeric), ((h = c.constraints) == null ? void 0 : h.requireNumeric) !== void 0 && (v.containsNumericCharacter = c.constraints.requireNumeric), ((d = c.constraints) == null ? void 0 : d.minLength) !== void 0 && (v.minPasswordLength = c.constraints.minLength), ((O = c.constraints) == null ? void 0 : O.maxLength) !== void 0 && (v.maxPasswordLength = c.constraints.maxLength)), E.passwordPolicyVersions.push({ customStrengthOptions: v }), E;
    }
    /**
     * Validates the PasswordPolicyConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     * @internal
     */
    static validate(c) {
      const E = {
        enforcementState: !0,
        forceUpgradeOnSignin: !0,
        constraints: !0
      };
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig" must be a non-null object.');
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid PasswordPolicyConfig parameter.`);
      if (typeof c.enforcementState > "u" || !(c.enforcementState === "ENFORCE" || c.enforcementState === "OFF"))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.enforcementState" must be either "ENFORCE" or "OFF".');
      if (typeof c.forceUpgradeOnSignin < "u" && !e.isBoolean(c.forceUpgradeOnSignin))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.forceUpgradeOnSignin" must be a boolean.');
      if (typeof c.constraints < "u") {
        if (c.enforcementState === "ENFORCE" && !e.isNonNullObject(c.constraints))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be a non-empty object.');
        const v = {
          requireUppercase: !0,
          requireLowercase: !0,
          requireNumeric: !0,
          requireNonAlphanumeric: !0,
          minLength: !0,
          maxLength: !0
        };
        for (const R in c.constraints)
          if (!(R in v))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${R}" is not a valid PasswordPolicyConfig.constraints parameter.`);
        if (typeof c.constraints.requireUppercase < "u" && !e.isBoolean(c.constraints.requireUppercase))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireUppercase" must be a boolean.');
        if (typeof c.constraints.requireLowercase < "u" && !e.isBoolean(c.constraints.requireLowercase))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireLowercase" must be a boolean.');
        if (typeof c.constraints.requireNonAlphanumeric < "u" && !e.isBoolean(c.constraints.requireNonAlphanumeric))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNonAlphanumeric" must be a boolean.');
        if (typeof c.constraints.requireNumeric < "u" && !e.isBoolean(c.constraints.requireNumeric))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNumeric" must be a boolean.');
        if (typeof c.constraints.minLength > "u")
          c.constraints.minLength = 6;
        else if (e.isNumber(c.constraints.minLength)) {
          if (!(c.constraints.minLength >= 6 && c.constraints.minLength <= 30))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be an integer between 6 and 30, inclusive.');
        } else
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be a number.');
        if (typeof c.constraints.maxLength > "u")
          c.constraints.maxLength = 4096;
        else if (e.isNumber(c.constraints.maxLength)) {
          if (!(c.constraints.maxLength >= c.constraints.minLength && c.constraints.maxLength <= 4096))
            throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be greater than or equal to minLength and at max 4096.');
        } else
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be a number.');
      } else if (c.enforcementState === "ENFORCE")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be defined.');
    }
    /**
     * The PasswordPolicyAuthConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     PasswordPolicyAuthConfig object.
     * @constructor
     * @internal
     */
    constructor(c) {
      if (typeof c.passwordPolicyEnforcementState > "u")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid password policy configuration response");
      this.enforcementState = c.passwordPolicyEnforcementState;
      let E = {};
      typeof c.passwordPolicyVersions < "u" && (c.passwordPolicyVersions || []).forEach((v) => {
        var R, N, C, h, d, O;
        E = {
          requireLowercase: (R = v.customStrengthOptions) == null ? void 0 : R.containsLowercaseCharacter,
          requireUppercase: (N = v.customStrengthOptions) == null ? void 0 : N.containsUppercaseCharacter,
          requireNonAlphanumeric: (C = v.customStrengthOptions) == null ? void 0 : C.containsNonAlphanumericCharacter,
          requireNumeric: (h = v.customStrengthOptions) == null ? void 0 : h.containsNumericCharacter,
          minLength: (d = v.customStrengthOptions) == null ? void 0 : d.minPasswordLength,
          maxLength: (O = v.customStrengthOptions) == null ? void 0 : O.maxPasswordLength
        };
      }), this.constraints = E, this.forceUpgradeOnSignin = !!c.forceUpgradeOnSignin;
    }
  }
  t.PasswordPolicyAuthConfig = S;
  class A {
    static validate(c) {
      if (!e.isNonNullObject(c))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig" must be a non-null object.');
      const E = {
        enableImprovedEmailPrivacy: !0
      };
      for (const v in c)
        if (!(v in E))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, `"${v}" is not a valid "EmailPrivacyConfig" parameter.`);
      if (typeof c.enableImprovedEmailPrivacy < "u" && !e.isBoolean(c.enableImprovedEmailPrivacy))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig.enableImprovedEmailPrivacy" must be a valid boolean value.');
    }
  }
  t.EmailPrivacyAuthConfig = A;
})(Ba);
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.Tenant = void 0;
const Bp = Ue, kn = vr, Fr = Te, Mt = Ba;
class ks {
  /**
   * Builds the corresponding server request for a TenantOptions object.
   *
   * @param tenantOptions - The properties to convert to a server request.
   * @param createRequest - Whether this is a create request.
   * @returns The equivalent server request.
   *
   * @internal
   */
  static buildServerRequest(e, r) {
    ks.validate(e, r);
    let n = {};
    return typeof e.emailSignInConfig < "u" && (n = Mt.EmailSignInConfig.buildServerRequest(e.emailSignInConfig)), typeof e.displayName < "u" && (n.displayName = e.displayName), typeof e.anonymousSignInEnabled < "u" && (n.enableAnonymousUser = e.anonymousSignInEnabled), typeof e.multiFactorConfig < "u" && (n.mfaConfig = Mt.MultiFactorAuthConfig.buildServerRequest(e.multiFactorConfig)), typeof e.testPhoneNumbers < "u" && (n.testPhoneNumbers = e.testPhoneNumbers ?? {}), typeof e.smsRegionConfig < "u" && (n.smsRegionConfig = e.smsRegionConfig), typeof e.recaptchaConfig < "u" && (n.recaptchaConfig = Mt.RecaptchaAuthConfig.buildServerRequest(e.recaptchaConfig)), typeof e.passwordPolicyConfig < "u" && (n.passwordPolicyConfig = Mt.PasswordPolicyAuthConfig.buildServerRequest(e.passwordPolicyConfig)), typeof e.emailPrivacyConfig < "u" && (n.emailPrivacyConfig = e.emailPrivacyConfig), n;
  }
  /**
   * Returns the tenant ID corresponding to the resource name if available.
   *
   * @param resourceName - The server side resource name
   * @returns The tenant ID corresponding to the resource, null otherwise.
   *
   * @internal
   */
  static getTenantIdFromResourceName(e) {
    const r = e.match(/\/tenants\/(.*)$/);
    return !r || r.length < 2 ? null : r[1];
  }
  /**
   * Validates a tenant options object. Throws an error on failure.
   *
   * @param request - The tenant options object to validate.
   * @param createRequest - Whether this is a create request.
   */
  static validate(e, r) {
    const n = {
      displayName: !0,
      emailSignInConfig: !0,
      anonymousSignInEnabled: !0,
      multiFactorConfig: !0,
      testPhoneNumbers: !0,
      smsRegionConfig: !0,
      recaptchaConfig: !0,
      passwordPolicyConfig: !0,
      emailPrivacyConfig: !0
    }, i = r ? "CreateTenantRequest" : "UpdateTenantRequest";
    if (!Bp.isNonNullObject(e))
      throw new Fr.FirebaseAuthError(Fr.AuthClientErrorCode.INVALID_ARGUMENT, `"${i}" must be a valid non-null object.`);
    for (const a in e)
      if (!(a in n))
        throw new Fr.FirebaseAuthError(Fr.AuthClientErrorCode.INVALID_ARGUMENT, `"${a}" is not a valid ${i} parameter.`);
    if (typeof e.displayName < "u" && !Bp.isNonEmptyString(e.displayName))
      throw new Fr.FirebaseAuthError(Fr.AuthClientErrorCode.INVALID_ARGUMENT, `"${i}.displayName" must be a valid non-empty string.`);
    if (typeof e.emailSignInConfig < "u" && Mt.EmailSignInConfig.buildServerRequest(e.emailSignInConfig), typeof e.testPhoneNumbers < "u" && e.testPhoneNumbers !== null)
      (0, Mt.validateTestPhoneNumbers)(e.testPhoneNumbers);
    else if (e.testPhoneNumbers === null && r)
      throw new Fr.FirebaseAuthError(Fr.AuthClientErrorCode.INVALID_ARGUMENT, `"${i}.testPhoneNumbers" must be a non-null object.`);
    typeof e.multiFactorConfig < "u" && Mt.MultiFactorAuthConfig.buildServerRequest(e.multiFactorConfig), typeof e.smsRegionConfig < "u" && Mt.SmsRegionsAuthConfig.validate(e.smsRegionConfig), typeof e.recaptchaConfig < "u" && Mt.RecaptchaAuthConfig.buildServerRequest(e.recaptchaConfig), typeof e.passwordPolicyConfig < "u" && Mt.PasswordPolicyAuthConfig.buildServerRequest(e.passwordPolicyConfig), typeof e.emailPrivacyConfig < "u" && Mt.EmailPrivacyAuthConfig.validate(e.emailPrivacyConfig);
  }
  /**
   * The Tenant object constructor.
   *
   * @param response - The server side response used to initialize the Tenant object.
   * @constructor
   * @internal
   */
  constructor(e) {
    const r = ks.getTenantIdFromResourceName(e.name);
    if (!r)
      throw new Fr.FirebaseAuthError(Fr.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid tenant response");
    this.tenantId = r, this.displayName = e.displayName;
    try {
      this.emailSignInConfig_ = new Mt.EmailSignInConfig(e);
    } catch {
      this.emailSignInConfig_ = new Mt.EmailSignInConfig({
        allowPasswordSignup: !1
      });
    }
    this.anonymousSignInEnabled = !!e.enableAnonymousUser, typeof e.mfaConfig < "u" && (this.multiFactorConfig_ = new Mt.MultiFactorAuthConfig(e.mfaConfig)), typeof e.testPhoneNumbers < "u" && (this.testPhoneNumbers = (0, kn.deepCopy)(e.testPhoneNumbers || {})), typeof e.smsRegionConfig < "u" && (this.smsRegionConfig = (0, kn.deepCopy)(e.smsRegionConfig)), typeof e.recaptchaConfig < "u" && (this.recaptchaConfig_ = new Mt.RecaptchaAuthConfig(e.recaptchaConfig)), typeof e.passwordPolicyConfig < "u" && (this.passwordPolicyConfig = new Mt.PasswordPolicyAuthConfig(e.passwordPolicyConfig)), typeof e.emailPrivacyConfig < "u" && (this.emailPrivacyConfig = (0, kn.deepCopy)(e.emailPrivacyConfig));
  }
  /**
   * The email sign in provider configuration.
   */
  get emailSignInConfig() {
    return this.emailSignInConfig_;
  }
  /**
   * The multi-factor auth configuration on the current tenant.
   */
  get multiFactorConfig() {
    return this.multiFactorConfig_;
  }
  /**
   * The recaptcha config auth configuration of the current tenant.
   */
  get recaptchaConfig() {
    return this.recaptchaConfig_;
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    var r, n;
    const e = {
      tenantId: this.tenantId,
      displayName: this.displayName,
      emailSignInConfig: (r = this.emailSignInConfig_) == null ? void 0 : r.toJSON(),
      multiFactorConfig: (n = this.multiFactorConfig_) == null ? void 0 : n.toJSON(),
      anonymousSignInEnabled: this.anonymousSignInEnabled,
      testPhoneNumbers: this.testPhoneNumbers,
      smsRegionConfig: (0, kn.deepCopy)(this.smsRegionConfig),
      recaptchaConfig: (0, kn.deepCopy)(this.recaptchaConfig),
      passwordPolicyConfig: (0, kn.deepCopy)(this.passwordPolicyConfig),
      emailPrivacyConfig: (0, kn.deepCopy)(this.emailPrivacyConfig)
    };
    return typeof e.multiFactorConfig > "u" && delete e.multiFactorConfig, typeof e.testPhoneNumbers > "u" && delete e.testPhoneNumbers, typeof e.smsRegionConfig > "u" && delete e.smsRegionConfig, typeof e.recaptchaConfig > "u" && delete e.recaptchaConfig, typeof e.passwordPolicyConfig > "u" && delete e.passwordPolicyConfig, typeof e.emailPrivacyConfig > "u" && delete e.emailPrivacyConfig, e;
  }
}
Hi.Tenant = ks;
var ai = {};
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.isUidIdentifier = zb;
ai.isEmailIdentifier = Xb;
ai.isPhoneIdentifier = Yb;
ai.isProviderIdentifier = Qb;
function zb(t) {
  return t.uid !== void 0;
}
function Xb(t) {
  return t.email !== void 0;
}
function Yb(t) {
  return t.phoneNumber !== void 0;
}
function Qb(t) {
  const e = t;
  return e.providerId !== void 0 && e.providerUid !== void 0;
}
var Ki = {};
/*! firebase-admin v13.4.0 */
Object.defineProperty(Ki, "__esModule", { value: !0 });
Ki.ProjectConfig = void 0;
/*!
 * Copyright 2022 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zb = Ue, ns = Te, fr = Ba, yi = vr;
class Vf {
  /**
   * The multi-factor auth configuration.
   */
  get multiFactorConfig() {
    return this.multiFactorConfig_;
  }
  /**
   * The reCAPTCHA configuration.
   */
  get recaptchaConfig() {
    return this.recaptchaConfig_;
  }
  /**
   * Validates a project config options object. Throws an error on failure.
   *
   * @param request - The project config options object to validate.
   */
  static validate(e) {
    if (!Zb.isNonNullObject(e))
      throw new ns.FirebaseAuthError(ns.AuthClientErrorCode.INVALID_ARGUMENT, '"UpdateProjectConfigRequest" must be a valid non-null object.');
    const r = {
      smsRegionConfig: !0,
      multiFactorConfig: !0,
      recaptchaConfig: !0,
      passwordPolicyConfig: !0,
      emailPrivacyConfig: !0,
      mobileLinksConfig: !0
    };
    for (const n in e)
      if (!(n in r))
        throw new ns.FirebaseAuthError(ns.AuthClientErrorCode.INVALID_ARGUMENT, `"${n}" is not a valid UpdateProjectConfigRequest parameter.`);
    typeof e.smsRegionConfig < "u" && fr.SmsRegionsAuthConfig.validate(e.smsRegionConfig), typeof e.multiFactorConfig < "u" && fr.MultiFactorAuthConfig.validate(e.multiFactorConfig), typeof e.recaptchaConfig < "u" && fr.RecaptchaAuthConfig.validate(e.recaptchaConfig), typeof e.passwordPolicyConfig < "u" && fr.PasswordPolicyAuthConfig.validate(e.passwordPolicyConfig), typeof e.emailPrivacyConfig < "u" && fr.EmailPrivacyAuthConfig.validate(e.emailPrivacyConfig), typeof e.mobileLinksConfig < "u" && fr.MobileLinksAuthConfig.validate(e.mobileLinksConfig);
  }
  /**
   * Build the corresponding server request for a UpdateProjectConfigRequest object.
   * @param configOptions - The properties to convert to a server request.
   * @returns  The equivalent server request.
   *
   * @internal
   */
  static buildServerRequest(e) {
    Vf.validate(e);
    const r = {};
    return typeof e.smsRegionConfig < "u" && (r.smsRegionConfig = e.smsRegionConfig), typeof e.multiFactorConfig < "u" && (r.mfa = fr.MultiFactorAuthConfig.buildServerRequest(e.multiFactorConfig)), typeof e.recaptchaConfig < "u" && (r.recaptchaConfig = fr.RecaptchaAuthConfig.buildServerRequest(e.recaptchaConfig)), typeof e.passwordPolicyConfig < "u" && (r.passwordPolicyConfig = fr.PasswordPolicyAuthConfig.buildServerRequest(e.passwordPolicyConfig)), typeof e.emailPrivacyConfig < "u" && (r.emailPrivacyConfig = e.emailPrivacyConfig), typeof e.mobileLinksConfig < "u" && (r.mobileLinksConfig = e.mobileLinksConfig), r;
  }
  /**
   * The Project Config object constructor.
   *
   * @param response - The server side response used to initialize the Project Config object.
   * @constructor
   * @internal
   */
  constructor(e) {
    typeof e.smsRegionConfig < "u" && (this.smsRegionConfig = e.smsRegionConfig), typeof e.mfa < "u" && (this.multiFactorConfig_ = new fr.MultiFactorAuthConfig(e.mfa)), typeof e.recaptchaConfig < "u" && (this.recaptchaConfig_ = new fr.RecaptchaAuthConfig(e.recaptchaConfig)), typeof e.passwordPolicyConfig < "u" && (this.passwordPolicyConfig = new fr.PasswordPolicyAuthConfig(e.passwordPolicyConfig)), typeof e.emailPrivacyConfig < "u" && (this.emailPrivacyConfig = e.emailPrivacyConfig), typeof e.mobileLinksConfig < "u" && (this.mobileLinksConfig = e.mobileLinksConfig);
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    const e = {
      smsRegionConfig: (0, yi.deepCopy)(this.smsRegionConfig),
      multiFactorConfig: (0, yi.deepCopy)(this.multiFactorConfig),
      recaptchaConfig: (0, yi.deepCopy)(this.recaptchaConfig),
      passwordPolicyConfig: (0, yi.deepCopy)(this.passwordPolicyConfig),
      emailPrivacyConfig: (0, yi.deepCopy)(this.emailPrivacyConfig),
      mobileLinksConfig: (0, yi.deepCopy)(this.mobileLinksConfig)
    };
    return typeof e.smsRegionConfig > "u" && delete e.smsRegionConfig, typeof e.multiFactorConfig > "u" && delete e.multiFactorConfig, typeof e.recaptchaConfig > "u" && delete e.recaptchaConfig, typeof e.passwordPolicyConfig > "u" && delete e.passwordPolicyConfig, typeof e.emailPrivacyConfig > "u" && delete e.emailPrivacyConfig, typeof e.mobileLinksConfig > "u" && delete e.mobileLinksConfig, e;
  }
}
Ki.ProjectConfig = Vf;
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.TenantAwareAuthRequestHandler = t.AuthRequestHandler = t.AbstractAuthRequestHandler = t.FIREBASE_AUTH_SIGN_UP_NEW_USER = t.FIREBASE_AUTH_SET_ACCOUNT_INFO = t.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = t.FIREBASE_AUTH_DELETE_ACCOUNT = t.FIREBASE_AUTH_GET_ACCOUNTS_INFO = t.FIREBASE_AUTH_GET_ACCOUNT_INFO = t.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = t.FIREBASE_AUTH_UPLOAD_ACCOUNT = t.FIREBASE_AUTH_CREATE_SESSION_COOKIE = t.EMAIL_ACTION_REQUEST_TYPES = t.RESERVED_CLAIMS = void 0, t.useEmulator = Y;
  const e = Ue, r = vr, n = Te, i = tt, a = at, s = ka, o = Mo, l = Hi, u = ai, f = Ba, y = Ki, m = {
    "X-Client-Version": `Node/Admin/${a.getSdkVersion()}`
  }, p = 25e3;
  t.RESERVED_CLAIMS = [
    "acr",
    "amr",
    "at_hash",
    "aud",
    "auth_time",
    "azp",
    "cnf",
    "c_hash",
    "exp",
    "iat",
    "iss",
    "jti",
    "nbf",
    "nonce",
    "sub",
    "firebase"
  ], t.EMAIL_ACTION_REQUEST_TYPES = [
    "PASSWORD_RESET",
    "VERIFY_EMAIL",
    "EMAIL_SIGNIN",
    "VERIFY_AND_CHANGE_EMAIL"
  ];
  const S = 1e3, A = 1e3, I = 1e3, c = 100, E = 1e3, v = 5 * 60, R = 14 * 24 * 60 * 60, N = 100, C = "https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}", h = "http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}", d = C.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}"), O = h.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}"), P = 1e3;
  var L;
  (function(M) {
    M.Create = "create", M.Update = "update", M.Upload = "upload";
  })(L || (L = {}));
  class D {
    /**
     * The resource URL builder constructor.
     *
     * @param projectId - The resource project ID.
     * @param version - The endpoint API version.
     * @constructor
     */
    constructor(X, J = "v1") {
      this.app = X, this.version = J, Y() ? this.urlFormat = a.formatString(h, {
        host: j()
      }) : this.urlFormat = C;
    }
    /**
     * Returns the resource URL corresponding to the provided parameters.
     *
     * @param api - The backend API name.
     * @param params - The optional additional parameters to substitute in the
     *     URL path.
     * @returns The corresponding resource URL.
     */
    getUrl(X, J) {
      return this.getProjectId().then((Z) => {
        const oe = {
          version: this.version,
          projectId: Z,
          api: X || ""
        }, he = a.formatString(this.urlFormat, oe);
        return a.formatString(he, J || {});
      });
    }
    getProjectId() {
      return this.projectId ? Promise.resolve(this.projectId) : a.findProjectId(this.app).then((X) => {
        if (!e.isNonEmptyString(X))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CREDENTIAL, "Failed to determine project ID for Auth. Initialize the SDK with service account credentials or set project ID as an app option. Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.");
        return this.projectId = X, X;
      });
    }
  }
  class V extends D {
    /**
     * The tenant aware resource URL builder constructor.
     *
     * @param projectId - The resource project ID.
     * @param version - The endpoint API version.
     * @param tenantId - The tenant ID.
     * @constructor
     */
    constructor(X, J, Z) {
      super(X, J), this.app = X, this.version = J, this.tenantId = Z, Y() ? this.urlFormat = a.formatString(O, {
        host: j()
      }) : this.urlFormat = d;
    }
    /**
     * Returns the resource URL corresponding to the provided parameters.
     *
     * @param api - The backend API name.
     * @param params - The optional additional parameters to substitute in the
     *     URL path.
     * @returns The corresponding resource URL.
     */
    getUrl(X, J) {
      return super.getUrl(X, J).then((Z) => a.formatString(Z, { tenantId: this.tenantId }));
    }
  }
  class $ extends i.AuthorizedHttpClient {
    getToken() {
      return Y() ? Promise.resolve("owner") : super.getToken();
    }
  }
  function K(M) {
    const X = {
      mfaEnrollmentId: !0,
      displayName: !0,
      phoneInfo: !0,
      enrolledAt: !0
    };
    for (const Z in M)
      Z in X || delete M[Z];
    const J = M.mfaEnrollmentId || M.phoneInfo || JSON.stringify(M);
    if (typeof M.mfaEnrollmentId < "u" && !e.isNonEmptyString(M.mfaEnrollmentId))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID, 'The second factor "uid" must be a valid non-empty string.');
    if (typeof M.displayName < "u" && !e.isString(M.displayName))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor "displayName" for "${J}" must be a valid string.`);
    if (typeof M.enrolledAt < "u" && !e.isISODateString(M.enrolledAt))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${J}" must be a valid UTC date string.`);
    if (typeof M.phoneInfo < "u") {
      if (!e.isPhoneNumber(M.phoneInfo))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor "phoneNumber" for "${J}" must be a non-empty E.164 standard compliant identifier string.`);
    } else
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, "MFAInfo object provided is invalid.");
  }
  function Q(M) {
    const X = {
      rawId: !0,
      providerId: !0,
      email: !0,
      displayName: !0,
      photoUrl: !0
    };
    for (const J in M)
      J in X || delete M[J];
    if (!e.isNonEmptyString(M.providerId))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID);
    if (typeof M.displayName < "u" && typeof M.displayName != "string")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider "displayName" for "${M.providerId}" must be a valid string.`);
    if (!e.isNonEmptyString(M.rawId))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID, `The provider "uid" for "${M.providerId}" must be a valid non-empty string.`);
    if (typeof M.email < "u" && !e.isEmail(M.email))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL, `The provider "email" for "${M.providerId}" must be a valid email string.`);
    if (typeof M.photoUrl < "u" && !e.isURL(M.photoUrl))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider "photoURL" for "${M.providerId}" must be a valid URL string.`);
  }
  function ee(M, X) {
    const J = X === L.Upload, Z = {
      displayName: !0,
      localId: !0,
      email: !0,
      password: !0,
      rawPassword: !0,
      emailVerified: !0,
      photoUrl: !0,
      disabled: !0,
      disableUser: !0,
      deleteAttribute: !0,
      deleteProvider: !0,
      sanityCheck: !0,
      phoneNumber: !0,
      customAttributes: !0,
      validSince: !0,
      // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)
      linkProviderUserInfo: !J,
      // Pass tenantId only for uploadAccount requests.
      tenantId: J,
      passwordHash: J,
      salt: J,
      createdAt: J,
      lastLoginAt: J,
      providerUserInfo: J,
      mfaInfo: J,
      // Only for non-uploadAccount requests.
      mfa: !J
    };
    for (const he in M)
      he in Z || delete M[he];
    if (typeof M.tenantId < "u" && !e.isNonEmptyString(M.tenantId))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TENANT_ID);
    if (typeof M.displayName < "u" && !e.isString(M.displayName))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_DISPLAY_NAME);
    if ((typeof M.localId < "u" || J) && !e.isUid(M.localId))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID);
    if (typeof M.email < "u" && !e.isEmail(M.email))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL);
    if (typeof M.phoneNumber < "u" && !e.isPhoneNumber(M.phoneNumber))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHONE_NUMBER);
    if (typeof M.password < "u" && !e.isPassword(M.password))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PASSWORD);
    if (typeof M.rawPassword < "u" && !e.isPassword(M.rawPassword))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PASSWORD);
    if (typeof M.emailVerified < "u" && typeof M.emailVerified != "boolean")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);
    if (typeof M.photoUrl < "u" && !e.isURL(M.photoUrl))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHOTO_URL);
    if (typeof M.disabled < "u" && typeof M.disabled != "boolean")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_DISABLED_FIELD);
    if (typeof M.validSince < "u" && !e.isNumber(M.validSince))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);
    if (typeof M.createdAt < "u" && !e.isNumber(M.createdAt))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CREATION_TIME);
    if (typeof M.lastLoginAt < "u" && !e.isNumber(M.lastLoginAt))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);
    if (typeof M.disableUser < "u" && typeof M.disableUser != "boolean")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_DISABLED_FIELD);
    if (typeof M.customAttributes < "u") {
      let he;
      try {
        he = JSON.parse(M.customAttributes);
      } catch (be) {
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_CLAIMS, be.message);
      }
      const Ee = [];
      if (t.RESERVED_CLAIMS.forEach((be) => {
        Object.prototype.hasOwnProperty.call(he, be) && Ee.push(be);
      }), Ee.length > 0)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.FORBIDDEN_CLAIM, Ee.length > 1 ? `Developer claims "${Ee.join('", "')}" are reserved and cannot be specified.` : `Developer claim "${Ee[0]}" is reserved and cannot be specified.`);
      if (M.customAttributes.length > S)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${S} characters.`);
    }
    if (typeof M.passwordHash < "u" && !e.isString(M.passwordHash))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PASSWORD_HASH);
    if (typeof M.salt < "u" && !e.isString(M.salt))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PASSWORD_SALT);
    if (typeof M.providerUserInfo < "u" && !e.isArray(M.providerUserInfo))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_DATA);
    e.isArray(M.providerUserInfo) && M.providerUserInfo.forEach((he) => {
      Q(he);
    }), typeof M.linkProviderUserInfo < "u" && Q(M.linkProviderUserInfo);
    let oe = null;
    if (M.mfaInfo ? oe = M.mfaInfo : M.mfa && M.mfa.enrollments && (oe = M.mfa.enrollments), oe) {
      if (!e.isArray(oe))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);
      oe.forEach((he) => {
        K(he);
      });
    }
  }
  t.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new i.ApiSettings(":createSessionCookie", "POST").setRequestValidator((M) => {
    if (!e.isNonEmptyString(M.idToken))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ID_TOKEN);
    if (!e.isNumber(M.validDuration) || M.validDuration < v || M.validDuration > R)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);
  }).setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.sessionCookie))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR);
  }), t.FIREBASE_AUTH_UPLOAD_ACCOUNT = new i.ApiSettings("/accounts:batchCreate", "POST"), t.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new i.ApiSettings("/accounts:batchGet", "GET").setRequestValidator((M) => {
    if (typeof M.nextPageToken < "u" && !e.isNonEmptyString(M.nextPageToken))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PAGE_TOKEN);
    if (!e.isNumber(M.maxResults) || M.maxResults <= 0 || M.maxResults > A)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${A}.`);
  }), t.FIREBASE_AUTH_GET_ACCOUNT_INFO = new i.ApiSettings("/accounts:lookup", "POST").setRequestValidator((M) => {
    if (!M.localId && !M.email && !M.phoneNumber && !M.federatedUserId)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
  }).setResponseValidator((M) => {
    if (!M.users || !M.users.length)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.USER_NOT_FOUND);
  }), t.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new i.ApiSettings("/accounts:lookup", "POST").setRequestValidator((M) => {
    if (!M.localId && !M.email && !M.phoneNumber && !M.federatedUserId)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
  }), t.FIREBASE_AUTH_DELETE_ACCOUNT = new i.ApiSettings("/accounts:delete", "POST").setRequestValidator((M) => {
    if (!M.localId)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
  }), t.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new i.ApiSettings("/accounts:batchDelete", "POST").setRequestValidator((M) => {
    if (!M.localIds)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifiers");
    if (typeof M.force > "u" || M.force !== !0)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing force=true field");
  }).setResponseValidator((M) => {
    (M.errors || []).forEach((J) => {
      if (typeof J.index > "u")
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field");
      if (!J.localId)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field");
    });
  }), t.FIREBASE_AUTH_SET_ACCOUNT_INFO = new i.ApiSettings("/accounts:update", "POST").setRequestValidator((M) => {
    if (typeof M.localId > "u")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
    if (typeof M.tenantId < "u")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "UpdateRequest" property.');
    ee(M, L.Update);
  }).setResponseValidator((M) => {
    if (!M.localId)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.USER_NOT_FOUND);
  }), t.FIREBASE_AUTH_SIGN_UP_NEW_USER = new i.ApiSettings("/accounts", "POST").setRequestValidator((M) => {
    if (typeof M.customAttributes < "u")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"customAttributes" cannot be set when creating a new user.');
    if (typeof M.validSince < "u")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"validSince" cannot be set when creating a new user.');
    if (typeof M.tenantId < "u")
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "CreateRequest" property.');
    ee(M, L.Create);
  }).setResponseValidator((M) => {
    if (!M.localId)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new user");
  });
  const ne = new i.ApiSettings("/accounts:sendOobCode", "POST").setRequestValidator((M) => {
    if (!e.isEmail(M.email))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL);
    if (typeof M.newEmail < "u" && !e.isEmail(M.newEmail))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_NEW_EMAIL);
    if (t.EMAIL_ACTION_REQUEST_TYPES.indexOf(M.requestType) === -1)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `"${M.requestType}" is not a supported email action request type.`);
  }).setResponseValidator((M) => {
    if (!M.oobLink)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create the email action link");
  }), ae = new i.ApiSettings("/oauthIdpConfigs/{providerId}", "GET").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get OIDC configuration");
  }), se = new i.ApiSettings("/oauthIdpConfigs/{providerId}", "DELETE"), me = new i.ApiSettings("/oauthIdpConfigs?oauthIdpConfigId={providerId}", "POST").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC configuration");
  }), ye = new i.ApiSettings("/oauthIdpConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC configuration");
  }), Se = new i.ApiSettings("/oauthIdpConfigs", "GET").setRequestValidator((M) => {
    if (typeof M.pageToken < "u" && !e.isNonEmptyString(M.pageToken))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PAGE_TOKEN);
    if (!e.isNumber(M.pageSize) || M.pageSize <= 0 || M.pageSize > N)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${N}.`);
  }), te = new i.ApiSettings("/inboundSamlConfigs/{providerId}", "GET").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get SAML configuration");
  }), Ce = new i.ApiSettings("/inboundSamlConfigs/{providerId}", "DELETE"), fe = new i.ApiSettings("/inboundSamlConfigs?inboundSamlConfigId={providerId}", "POST").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML configuration");
  }), De = new i.ApiSettings("/inboundSamlConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML configuration");
  }), _e = new i.ApiSettings("/inboundSamlConfigs", "GET").setRequestValidator((M) => {
    if (typeof M.pageToken < "u" && !e.isNonEmptyString(M.pageToken))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PAGE_TOKEN);
    if (!e.isNumber(M.pageSize) || M.pageSize <= 0 || M.pageSize > N)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${N}.`);
  });
  class w {
    /**
     * @param response - The response to check for errors.
     * @returns The error code if present; null otherwise.
     */
    static getErrorCode(X) {
      return e.isNonNullObject(X) && X.error && X.error.message || null;
    }
    static addUidToRequest(X, J) {
      if (!e.isUid(X.uid))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID);
      return J.localId ? J.localId.push(X.uid) : J.localId = [X.uid], J;
    }
    static addEmailToRequest(X, J) {
      if (!e.isEmail(X.email))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL);
      return J.email ? J.email.push(X.email) : J.email = [X.email], J;
    }
    static addPhoneToRequest(X, J) {
      if (!e.isPhoneNumber(X.phoneNumber))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHONE_NUMBER);
      return J.phoneNumber ? J.phoneNumber.push(X.phoneNumber) : J.phoneNumber = [X.phoneNumber], J;
    }
    static addProviderToRequest(X, J) {
      if (!e.isNonEmptyString(X.providerId))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID);
      if (!e.isNonEmptyString(X.providerUid))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_UID);
      const Z = {
        providerId: X.providerId,
        rawId: X.providerUid
      };
      return J.federatedUserId ? J.federatedUserId.push(Z) : J.federatedUserId = [Z], J;
    }
    /**
     * @param app - The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    constructor(X) {
      if (this.app = X, typeof X != "object" || X === null || !("options" in X))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "First argument passed to admin.auth() must be a valid Firebase app instance.");
      this.httpClient = new $(X);
    }
    /**
     * Creates a new Firebase session cookie with the specified duration that can be used for
     * session management (set as a server side session cookie with custom cookie policy).
     * The session cookie JWT will have the same payload claims as the provided ID token.
     *
     * @param idToken - The Firebase ID token to exchange for a session cookie.
     * @param expiresIn - The session cookie duration in milliseconds.
     *
     * @returns A promise that resolves on success with the created session cookie.
     */
    createSessionCookie(X, J) {
      const Z = {
        idToken: X,
        // Convert to seconds.
        validDuration: Math.floor(J / 1e3)
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_CREATE_SESSION_COOKIE, Z).then((oe) => oe.sessionCookie);
    }
    /**
     * Looks up a user by uid.
     *
     * @param uid - The uid of the user to lookup.
     * @returns A promise that resolves with the user information.
     */
    getAccountInfoByUid(X) {
      if (!e.isUid(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID));
      const J = {
        localId: [X]
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_GET_ACCOUNT_INFO, J);
    }
    /**
     * Looks up a user by email.
     *
     * @param email - The email of the user to lookup.
     * @returns A promise that resolves with the user information.
     */
    getAccountInfoByEmail(X) {
      if (!e.isEmail(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_EMAIL));
      const J = {
        email: [X]
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_GET_ACCOUNT_INFO, J);
    }
    /**
     * Looks up a user by phone number.
     *
     * @param phoneNumber - The phone number of the user to lookup.
     * @returns A promise that resolves with the user information.
     */
    getAccountInfoByPhoneNumber(X) {
      if (!e.isPhoneNumber(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PHONE_NUMBER));
      const J = {
        phoneNumber: [X]
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_GET_ACCOUNT_INFO, J);
    }
    getAccountInfoByFederatedUid(X, J) {
      if (!e.isNonEmptyString(X) || !e.isNonEmptyString(J))
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID);
      const Z = {
        federatedUserId: [{
          providerId: X,
          rawId: J
        }]
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_GET_ACCOUNT_INFO, Z);
    }
    /**
     * Looks up multiple users by their identifiers (uid, email, etc).
     *
     * @param identifiers - The identifiers indicating the users
     *     to be looked up. Must have <= 100 entries.
     * @param A - promise that resolves with the set of successfully
     *     looked up users. Possibly empty if no users were looked up.
     */
    getAccountInfoByIdentifiers(X) {
      if (X.length === 0)
        return Promise.resolve({ users: [] });
      if (X.length > c)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`identifiers` parameter must have <= " + c + " entries.");
      let J = {};
      for (const Z of X)
        if ((0, u.isUidIdentifier)(Z))
          J = w.addUidToRequest(Z, J);
        else if ((0, u.isEmailIdentifier)(Z))
          J = w.addEmailToRequest(Z, J);
        else if ((0, u.isPhoneIdentifier)(Z))
          J = w.addPhoneToRequest(Z, J);
        else if ((0, u.isProviderIdentifier)(Z))
          J = w.addProviderToRequest(Z, J);
        else
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "Unrecognized identifier: " + Z);
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_GET_ACCOUNTS_INFO, J);
    }
    /**
     * Exports the users (single batch only) with a size of maxResults and starting from
     * the offset as specified by pageToken.
     *
     * @param maxResults - The page size, 1000 if undefined. This is also the maximum
     *     allowed limit.
     * @param pageToken - The next page token. If not specified, returns users starting
     *     without any offset. Users are returned in the order they were created from oldest to
     *     newest, relative to the page token offset.
     * @returns A promise that resolves with the current batch of downloaded
     *     users and the next page token if available. For the last page, an empty list of users
     *     and no page token are returned.
     */
    downloadAccount(X = A, J) {
      const Z = {
        maxResults: X,
        nextPageToken: J
      };
      return typeof Z.nextPageToken > "u" && delete Z.nextPageToken, this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, Z).then((oe) => (oe.users || (oe.users = []), oe));
    }
    /**
     * Imports the list of users provided to Firebase Auth. This is useful when
     * migrating from an external authentication system without having to use the Firebase CLI SDK.
     * At most, 1000 users are allowed to be imported one at a time.
     * When importing a list of password users, UserImportOptions are required to be specified.
     *
     * @param users - The list of user records to import to Firebase Auth.
     * @param options - The user import options, required when the users provided
     *     include password credentials.
     * @returns A promise that resolves when the operation completes
     *     with the result of the import. This includes the number of successful imports, the number
     *     of failed uploads and their corresponding errors.
     */
    uploadAccount(X, J) {
      const Z = new s.UserImportBuilder(X, J, (he) => {
        ee(he, L.Upload);
      }), oe = Z.buildRequest();
      if (e.isArray(X) && X.length > I)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${I} users can be imported at once.`);
      return !oe.users || oe.users.length === 0 ? Promise.resolve(Z.buildResponse([])) : this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_UPLOAD_ACCOUNT, oe).then((he) => {
        const Ee = he.error || [];
        return Z.buildResponse(Ee);
      });
    }
    /**
     * Deletes an account identified by a uid.
     *
     * @param uid - The uid of the user to delete.
     * @returns A promise that resolves when the user is deleted.
     */
    deleteAccount(X) {
      if (!e.isUid(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID));
      const J = {
        localId: X
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_DELETE_ACCOUNT, J);
    }
    deleteAccounts(X, J) {
      if (X.length === 0)
        return Promise.resolve({});
      if (X.length > E)
        throw new n.FirebaseAuthError(n.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`uids` parameter must have <= " + E + " entries.");
      const Z = {
        localIds: [],
        force: J
      };
      return X.forEach((oe) => {
        if (!e.isUid(oe))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID);
        Z.localIds.push(oe);
      }), this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, Z);
    }
    /**
     * Sets additional developer claims on an existing user identified by provided UID.
     *
     * @param uid - The user to edit.
     * @param customUserClaims - The developer claims to set.
     * @returns A promise that resolves when the operation completes
     *     with the user id that was edited.
     */
    setCustomUserClaims(X, J) {
      if (e.isUid(X)) {
        if (!e.isObject(J))
          return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "CustomUserClaims argument must be an object or null."));
      } else return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID));
      J === null && (J = {});
      const Z = {
        localId: X,
        customAttributes: JSON.stringify(J)
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_SET_ACCOUNT_INFO, Z).then((oe) => oe.localId);
    }
    /**
     * Edits an existing user.
     *
     * @param uid - The user to edit.
     * @param properties - The properties to set on the user.
     * @returns A promise that resolves when the operation completes
     *     with the user id that was edited.
     */
    updateExistingAccount(X, J) {
      if (e.isUid(X))
        if (e.isNonNullObject(J)) {
          if (e.isNonNullObject(J.providerToLink)) {
            if (!e.isNonEmptyString(J.providerToLink.providerId))
              throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.providerId of properties argument must be a non-empty string.");
            if (!e.isNonEmptyString(J.providerToLink.uid))
              throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.uid of properties argument must be a non-empty string.");
          } else if (typeof J.providersToUnlink < "u") {
            if (!e.isArray(J.providersToUnlink))
              throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
            J.providersToUnlink.forEach((he) => {
              if (!e.isNonEmptyString(he))
                throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
            });
          }
        } else return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
      else return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID));
      const Z = (0, r.deepCopy)(J);
      Z.localId = X;
      const oe = {
        displayName: "DISPLAY_NAME",
        photoURL: "PHOTO_URL"
      };
      Z.deleteAttribute = [];
      for (const he in oe)
        Z[he] === null && (Z.deleteAttribute.push(oe[he]), delete Z[he]);
      if (Z.deleteAttribute.length === 0 && delete Z.deleteAttribute, Z.phoneNumber === null && (Z.deleteProvider ? Z.deleteProvider.push("phone") : Z.deleteProvider = ["phone"], delete Z.phoneNumber), typeof Z.providerToLink < "u" && (Z.linkProviderUserInfo = (0, r.deepCopy)(Z.providerToLink), delete Z.providerToLink, Z.linkProviderUserInfo.rawId = Z.linkProviderUserInfo.uid, delete Z.linkProviderUserInfo.uid), typeof Z.providersToUnlink < "u" && (e.isArray(Z.deleteProvider) || (Z.deleteProvider = []), Z.deleteProvider = Z.deleteProvider.concat(Z.providersToUnlink), delete Z.providersToUnlink), typeof Z.photoURL < "u" && (Z.photoUrl = Z.photoURL, delete Z.photoURL), typeof Z.disabled < "u" && (Z.disableUser = Z.disabled, delete Z.disabled), e.isNonNullObject(Z.multiFactor)) {
        if (Z.multiFactor.enrolledFactors === null)
          Z.mfa = {};
        else if (e.isArray(Z.multiFactor.enrolledFactors)) {
          Z.mfa = {
            enrollments: []
          };
          try {
            Z.multiFactor.enrolledFactors.forEach((he) => {
              Z.mfa.enrollments.push((0, s.convertMultiFactorInfoToServerFormat)(he));
            });
          } catch (he) {
            return Promise.reject(he);
          }
          Z.mfa.enrollments.length === 0 && delete Z.mfa.enrollments;
        }
        delete Z.multiFactor;
      }
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_SET_ACCOUNT_INFO, Z).then((he) => he.localId);
    }
    /**
     * Revokes all refresh tokens for the specified user identified by the uid provided.
     * In addition to revoking all refresh tokens for a user, all ID tokens issued
     * before revocation will also be revoked on the Auth backend. Any request with an
     * ID token generated before revocation will be rejected with a token expired error.
     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in
     * the same second as the revocation will still be valid. If there is a chance that a token
     * was minted in the last second, delay for 1 second before revoking.
     *
     * @param uid - The user whose tokens are to be revoked.
     * @returns A promise that resolves when the operation completes
     *     successfully with the user id of the corresponding user.
     */
    revokeRefreshTokens(X) {
      if (!e.isUid(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_UID));
      const J = {
        localId: X,
        // validSince is in UTC seconds.
        validSince: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3)
      };
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_SET_ACCOUNT_INFO, J).then((Z) => Z.localId);
    }
    /**
     * Create a new user with the properties supplied.
     *
     * @param properties - The properties to set on the user.
     * @returns A promise that resolves when the operation completes
     *     with the user id that was created.
     */
    createNewAccount(X) {
      if (!e.isNonNullObject(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
      const J = (0, r.deepCopy)(X);
      if (typeof J.photoURL < "u" && (J.photoUrl = J.photoURL, delete J.photoURL), typeof J.uid < "u" && (J.localId = J.uid, delete J.uid), e.isNonNullObject(J.multiFactor)) {
        if (e.isNonEmptyArray(J.multiFactor.enrolledFactors)) {
          const Z = [];
          try {
            J.multiFactor.enrolledFactors.forEach((oe) => {
              if ("enrollmentTime" in oe)
                throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"enrollmentTime" is not supported when adding second factors via "createUser()"');
              if ("uid" in oe)
                throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, '"uid" is not supported when adding second factors via "createUser()"');
              Z.push((0, s.convertMultiFactorInfoToServerFormat)(oe));
            });
          } catch (oe) {
            return Promise.reject(oe);
          }
          J.mfaInfo = Z;
        }
        delete J.multiFactor;
      }
      return this.invokeRequestHandler(this.getAuthUrlBuilder(), t.FIREBASE_AUTH_SIGN_UP_NEW_USER, J).then((Z) => Z.localId);
    }
    /**
     * Generates the out of band email action link for the email specified using the action code settings provided.
     * Returns a promise that resolves with the generated link.
     *
     * @param requestType - The request type. This could be either used for password reset,
     *     email verification, email link sign-in.
     * @param email - The email of the user the link is being sent to.
     * @param actionCodeSettings - The optional action code setings which defines whether
     *     the link is to be handled by a mobile app and the additional state information to be passed in the
     *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'
     * @param newEmail - The email address the account is being updated to.
     *     Required only for VERIFY_AND_CHANGE_EMAIL requests.
     * @returns A promise that resolves with the email action link.
     */
    getEmailActionLink(X, J, Z, oe) {
      let he = {
        requestType: X,
        email: J,
        returnOobLink: !0,
        ...typeof oe < "u" && { newEmail: oe }
      };
      if (typeof Z > "u" && X === "EMAIL_SIGNIN")
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'"));
      if (typeof Z < "u" || X === "EMAIL_SIGNIN")
        try {
          const Ee = new o.ActionCodeSettingsBuilder(Z);
          he = (0, r.deepExtend)(he, Ee.buildRequest());
        } catch (Ee) {
          return Promise.reject(Ee);
        }
      return X === "VERIFY_AND_CHANGE_EMAIL" && typeof oe > "u" ? Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, "`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'")) : this.invokeRequestHandler(this.getAuthUrlBuilder(), ne, he).then((Ee) => Ee.oobLink);
    }
    /**
     * Looks up an OIDC provider configuration by provider ID.
     *
     * @param providerId - The provider identifier of the configuration to lookup.
     * @returns A promise that resolves with the provider configuration information.
     */
    getOAuthIdpConfig(X) {
      return f.OIDCConfig.isProviderId(X) ? this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), ae, {}, { providerId: X }) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
    }
    /**
     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from
     * the offset as specified by pageToken.
     *
     * @param maxResults - The page size, 100 if undefined. This is also the maximum
     *     allowed limit.
     * @param pageToken - The next page token. If not specified, returns OIDC configurations
     *     without any offset. Configurations are returned in the order they were created from oldest to
     *     newest, relative to the page token offset.
     * @returns A promise that resolves with the current batch of downloaded
     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider
     *     configuration and no page token are returned.
     */
    listOAuthIdpConfigs(X = N, J) {
      const Z = {
        pageSize: X
      };
      return typeof J < "u" && (Z.pageToken = J), this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), Se, Z).then((oe) => (oe.oauthIdpConfigs || (oe.oauthIdpConfigs = [], delete oe.nextPageToken), oe));
    }
    /**
     * Deletes an OIDC configuration identified by a providerId.
     *
     * @param providerId - The identifier of the OIDC configuration to delete.
     * @returns A promise that resolves when the OIDC provider is deleted.
     */
    deleteOAuthIdpConfig(X) {
      return f.OIDCConfig.isProviderId(X) ? this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), se, {}, { providerId: X }).then(() => {
      }) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
    }
    /**
     * Creates a new OIDC provider configuration with the properties provided.
     *
     * @param options - The properties to set on the new OIDC provider configuration to be created.
     * @returns A promise that resolves with the newly created OIDC
     *     configuration.
     */
    createOAuthIdpConfig(X) {
      let J;
      try {
        J = f.OIDCConfig.buildServerRequest(X) || {};
      } catch (oe) {
        return Promise.reject(oe);
      }
      const Z = X.providerId;
      return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), me, J, { providerId: Z }).then((oe) => {
        if (!f.OIDCConfig.getProviderIdFromResourceName(oe.name))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration");
        return oe;
      });
    }
    /**
     * Updates an existing OIDC provider configuration with the properties provided.
     *
     * @param providerId - The provider identifier of the OIDC configuration to update.
     * @param options - The properties to update on the existing configuration.
     * @returns A promise that resolves with the modified provider
     *     configuration.
     */
    updateOAuthIdpConfig(X, J) {
      if (!f.OIDCConfig.isProviderId(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
      let Z;
      try {
        Z = f.OIDCConfig.buildServerRequest(J, !0) || {};
      } catch (he) {
        return Promise.reject(he);
      }
      const oe = a.generateUpdateMask(Z);
      return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), ye, Z, { providerId: X, updateMask: oe.join(",") }).then((he) => {
        if (!f.OIDCConfig.getProviderIdFromResourceName(he.name))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration");
        return he;
      });
    }
    /**
     * Looks up an SAML provider configuration by provider ID.
     *
     * @param providerId - The provider identifier of the configuration to lookup.
     * @returns A promise that resolves with the provider configuration information.
     */
    getInboundSamlConfig(X) {
      return f.SAMLConfig.isProviderId(X) ? this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), te, {}, { providerId: X }) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
    }
    /**
     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from
     * the offset as specified by pageToken.
     *
     * @param maxResults - The page size, 100 if undefined. This is also the maximum
     *     allowed limit.
     * @param pageToken - The next page token. If not specified, returns SAML configurations starting
     *     without any offset. Configurations are returned in the order they were created from oldest to
     *     newest, relative to the page token offset.
     * @returns A promise that resolves with the current batch of downloaded
     *     SAML configurations and the next page token if available. For the last page, an empty list of provider
     *     configuration and no page token are returned.
     */
    listInboundSamlConfigs(X = N, J) {
      const Z = {
        pageSize: X
      };
      return typeof J < "u" && (Z.pageToken = J), this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), _e, Z).then((oe) => (oe.inboundSamlConfigs || (oe.inboundSamlConfigs = [], delete oe.nextPageToken), oe));
    }
    /**
     * Deletes a SAML configuration identified by a providerId.
     *
     * @param providerId - The identifier of the SAML configuration to delete.
     * @returns A promise that resolves when the SAML provider is deleted.
     */
    deleteInboundSamlConfig(X) {
      return f.SAMLConfig.isProviderId(X) ? this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), Ce, {}, { providerId: X }).then(() => {
      }) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
    }
    /**
     * Creates a new SAML provider configuration with the properties provided.
     *
     * @param options - The properties to set on the new SAML provider configuration to be created.
     * @returns A promise that resolves with the newly created SAML
     *     configuration.
     */
    createInboundSamlConfig(X) {
      let J;
      try {
        J = f.SAMLConfig.buildServerRequest(X) || {};
      } catch (oe) {
        return Promise.reject(oe);
      }
      const Z = X.providerId;
      return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), fe, J, { providerId: Z }).then((oe) => {
        if (!f.SAMLConfig.getProviderIdFromResourceName(oe.name))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration");
        return oe;
      });
    }
    /**
     * Updates an existing SAML provider configuration with the properties provided.
     *
     * @param providerId - The provider identifier of the SAML configuration to update.
     * @param options - The properties to update on the existing configuration.
     * @returns A promise that resolves with the modified provider
     *     configuration.
     */
    updateInboundSamlConfig(X, J) {
      if (!f.SAMLConfig.isProviderId(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PROVIDER_ID));
      let Z;
      try {
        Z = f.SAMLConfig.buildServerRequest(J, !0) || {};
      } catch (he) {
        return Promise.reject(he);
      }
      const oe = a.generateUpdateMask(Z);
      return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), De, Z, { providerId: X, updateMask: oe.join(",") }).then((he) => {
        if (!f.SAMLConfig.getProviderIdFromResourceName(he.name))
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML provider configuration");
        return he;
      });
    }
    /**
     * Invokes the request handler based on the API settings object passed.
     *
     * @param urlBuilder - The URL builder for Auth endpoints.
     * @param apiSettings - The API endpoint settings to apply to request and response.
     * @param requestData - The request data.
     * @param additionalResourceParams - Additional resource related params if needed.
     * @returns A promise that resolves with the response.
     */
    invokeRequestHandler(X, J, Z, oe) {
      return X.getUrl(J.getEndpoint(), oe).then((he) => {
        Z && J.getRequestValidator()(Z);
        const Ee = {
          method: J.getHttpMethod(),
          url: he,
          headers: m,
          data: Z,
          timeout: p
        };
        return this.httpClient.send(Ee);
      }).then((he) => (J.getResponseValidator()(he.data), he.data)).catch((he) => {
        if (he instanceof i.RequestResponseError) {
          const Ee = he.response.data, be = w.getErrorCode(Ee);
          throw be ? n.FirebaseAuthError.fromServerError(
            be,
            /* message */
            void 0,
            Ee
          ) : new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + Ee + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
        }
        throw he;
      });
    }
    /**
     * @returns The current Auth user management resource URL builder.
     */
    getAuthUrlBuilder() {
      return this.authUrlBuilder || (this.authUrlBuilder = this.newAuthUrlBuilder()), this.authUrlBuilder;
    }
    /**
     * @returns The current project config resource URL builder.
     */
    getProjectConfigUrlBuilder() {
      return this.projectConfigUrlBuilder || (this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder()), this.projectConfigUrlBuilder;
    }
  }
  t.AbstractAuthRequestHandler = w;
  const b = new i.ApiSettings("/config", "GET").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get project config");
  }), T = new i.ApiSettings("/config?updateMask={updateMask}", "PATCH").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update project config");
  }), g = new i.ApiSettings("/tenants/{tenantId}", "GET").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get tenant");
  }), x = new i.ApiSettings("/tenants/{tenantId}", "DELETE"), U = new i.ApiSettings("/tenants/{tenantId}?updateMask={updateMask}", "PATCH").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name) || !l.Tenant.getTenantIdFromResourceName(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update tenant");
  }), k = new i.ApiSettings("/tenants", "GET").setRequestValidator((M) => {
    if (typeof M.pageToken < "u" && !e.isNonEmptyString(M.pageToken))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_PAGE_TOKEN);
    if (!e.isNumber(M.pageSize) || M.pageSize <= 0 || M.pageSize > P)
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive non-zero number that does not exceed the allowed ${P}.`);
  }), W = new i.ApiSettings("/tenants", "POST").setResponseValidator((M) => {
    if (!e.isNonEmptyString(M.name) || !l.Tenant.getTenantIdFromResourceName(M.name))
      throw new n.FirebaseAuthError(n.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new tenant");
  });
  class q extends w {
    /**
     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.
     *
     * @param app - The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    constructor(X) {
      super(X), this.authResourceUrlBuilder = new D(X, "v2");
    }
    /**
     * @returns A new Auth user management resource URL builder instance.
     */
    newAuthUrlBuilder() {
      return new D(this.app, "v1");
    }
    /**
     * @returns A new project config resource URL builder instance.
     */
    newProjectConfigUrlBuilder() {
      return new D(this.app, "v2");
    }
    /**
     * Get the current project's config
     * @returns A promise that resolves with the project config information.
     */
    getProjectConfig() {
      return this.invokeRequestHandler(this.authResourceUrlBuilder, b, {}, {}).then((X) => X);
    }
    /**
     * Update the current project's config.
     * @returns A promise that resolves with the project config information.
     */
    updateProjectConfig(X) {
      try {
        const J = y.ProjectConfig.buildServerRequest(X), Z = a.generateUpdateMask(J);
        return this.invokeRequestHandler(this.authResourceUrlBuilder, T, J, { updateMask: Z.join(",") }).then((oe) => oe);
      } catch (J) {
        return Promise.reject(J);
      }
    }
    /**
     * Looks up a tenant by tenant ID.
     *
     * @param tenantId - The tenant identifier of the tenant to lookup.
     * @returns A promise that resolves with the tenant information.
     */
    getTenant(X) {
      return e.isNonEmptyString(X) ? this.invokeRequestHandler(this.authResourceUrlBuilder, g, {}, { tenantId: X }).then((J) => J) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TENANT_ID));
    }
    /**
     * Exports the tenants (single batch only) with a size of maxResults and starting from
     * the offset as specified by pageToken.
     *
     * @param maxResults - The page size, 1000 if undefined. This is also the maximum
     *     allowed limit.
     * @param pageToken - The next page token. If not specified, returns tenants starting
     *     without any offset. Tenants are returned in the order they were created from oldest to
     *     newest, relative to the page token offset.
     * @returns A promise that resolves with the current batch of downloaded
     *     tenants and the next page token if available. For the last page, an empty list of tenants
     *     and no page token are returned.
     */
    listTenants(X = P, J) {
      const Z = {
        pageSize: X,
        pageToken: J
      };
      return typeof Z.pageToken > "u" && delete Z.pageToken, this.invokeRequestHandler(this.authResourceUrlBuilder, k, Z).then((oe) => (oe.tenants || (oe.tenants = [], delete oe.nextPageToken), oe));
    }
    /**
     * Deletes a tenant identified by a tenantId.
     *
     * @param tenantId - The identifier of the tenant to delete.
     * @returns A promise that resolves when the tenant is deleted.
     */
    deleteTenant(X) {
      return e.isNonEmptyString(X) ? this.invokeRequestHandler(this.authResourceUrlBuilder, x, void 0, { tenantId: X }).then(() => {
      }) : Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TENANT_ID));
    }
    /**
     * Creates a new tenant with the properties provided.
     *
     * @param tenantOptions - The properties to set on the new tenant to be created.
     * @returns A promise that resolves with the newly created tenant object.
     */
    createTenant(X) {
      try {
        const J = l.Tenant.buildServerRequest(X, !0);
        return this.invokeRequestHandler(this.authResourceUrlBuilder, W, J).then((Z) => Z);
      } catch (J) {
        return Promise.reject(J);
      }
    }
    /**
     * Updates an existing tenant with the properties provided.
     *
     * @param tenantId - The tenant identifier of the tenant to update.
     * @param tenantOptions - The properties to update on the existing tenant.
     * @returns A promise that resolves with the modified tenant object.
     */
    updateTenant(X, J) {
      if (!e.isNonEmptyString(X))
        return Promise.reject(new n.FirebaseAuthError(n.AuthClientErrorCode.INVALID_TENANT_ID));
      try {
        const Z = l.Tenant.buildServerRequest(J, !1), oe = a.generateUpdateMask(Z, ["testPhoneNumbers"]);
        return this.invokeRequestHandler(this.authResourceUrlBuilder, U, Z, { tenantId: X, updateMask: oe.join(",") }).then((he) => he);
      } catch (Z) {
        return Promise.reject(Z);
      }
    }
  }
  t.AuthRequestHandler = q;
  class z extends w {
    /**
     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a
     * FirebaseApp and a tenant ID.
     *
     * @param app - The app used to fetch access tokens to sign API requests.
     * @param tenantId - The request handler's tenant ID.
     * @constructor
     */
    constructor(X, J) {
      super(X), this.tenantId = J;
    }
    /**
     * @returns A new Auth user management resource URL builder instance.
     */
    newAuthUrlBuilder() {
      return new V(this.app, "v1", this.tenantId);
    }
    /**
     * @returns A new project config resource URL builder instance.
     */
    newProjectConfigUrlBuilder() {
      return new V(this.app, "v2", this.tenantId);
    }
    /**
     * Imports the list of users provided to Firebase Auth. This is useful when
     * migrating from an external authentication system without having to use the Firebase CLI SDK.
     * At most, 1000 users are allowed to be imported one at a time.
     * When importing a list of password users, UserImportOptions are required to be specified.
     *
     * Overrides the superclass methods by adding an additional check to match tenant IDs of
     * imported user records if present.
     *
     * @param users - The list of user records to import to Firebase Auth.
     * @param options - The user import options, required when the users provided
     *     include password credentials.
     * @returns A promise that resolves when the operation completes
     *     with the result of the import. This includes the number of successful imports, the number
     *     of failed uploads and their corresponding errors.
     */
    uploadAccount(X, J) {
      return X.forEach((Z, oe) => {
        if (e.isNonEmptyString(Z.tenantId) && Z.tenantId !== this.tenantId)
          throw new n.FirebaseAuthError(n.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index "${oe}" has mismatching tenant ID "${Z.tenantId}"`);
      }), super.uploadAccount(X, J);
    }
  }
  t.TenantAwareAuthRequestHandler = z;
  function j() {
    return process.env.FIREBASE_AUTH_EMULATOR_HOST;
  }
  function Y() {
    return !!j();
  }
})(La);
var qn = {}, si = {}, Xy = {}, hr = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.CryptoSignerErrorCode = hr.CryptoSignerError = hr.IAMSigner = hr.ServiceAccountSigner = void 0;
hr.cryptoSignerFromApp = nw;
const ew = Lt, Ll = tt, tw = at, rw = Ue, Yy = "RS256";
class Qy {
  /**
   * Creates a new CryptoSigner instance from the given service account credential.
   *
   * @param credential - A service account credential.
   */
  constructor(e) {
    if (this.credential = e, this.algorithm = Yy, !e)
      throw new on({
        code: Or.INVALID_CREDENTIAL,
        message: "INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner."
      });
  }
  /**
   * @inheritDoc
   */
  sign(e) {
    const n = ge.createSign("RSA-SHA256");
    return n.update(e), Promise.resolve(n.sign(this.credential.privateKey));
  }
  /**
   * @inheritDoc
   */
  getAccountId() {
    return Promise.resolve(this.credential.clientEmail);
  }
}
hr.ServiceAccountSigner = Qy;
class Zy {
  constructor(e, r) {
    if (this.algorithm = Yy, !e)
      throw new on({
        code: Or.INVALID_ARGUMENT,
        message: "INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner."
      });
    if (r && (typeof r != "object" || r === null || !("options" in r)))
      throw new on({
        code: Or.INVALID_ARGUMENT,
        message: "INTERNAL ASSERT: Must provide a valid Firebase app instance."
      });
    this.httpClient = e, this.app = r;
  }
  /**
   * @inheritDoc
   */
  sign(e) {
    return this.getAccountId().then((r) => {
      const n = {
        method: "POST",
        url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${r}:signBlob`,
        data: { payload: e.toString("base64") }
      };
      return this.httpClient.send(n);
    }).then((r) => Buffer.from(r.data.signedBlob, "base64")).catch((r) => {
      throw r instanceof Ll.RequestResponseError ? new on({
        code: Or.SERVER_ERROR,
        message: r.message,
        cause: r
      }) : r;
    });
  }
  /**
   * @inheritDoc
   */
  async getAccountId() {
    if (rw.isNonEmptyString(this.serviceAccountId))
      return this.serviceAccountId;
    if (this.app) {
      const n = await tw.findServiceAccountEmail(this.app);
      if (n)
        return this.serviceAccountId = n, n;
    }
    const e = {
      method: "GET",
      url: "http://metadata/computeMetadata/v1/instance/service-accounts/default/email",
      headers: {
        "Metadata-Flavor": "Google"
      }
    };
    return new Ll.HttpClient().send(e).then((n) => {
      if (!n.text)
        throw new on({
          code: Or.INTERNAL_ERROR,
          message: "HTTP Response missing payload"
        });
      return this.serviceAccountId = n.text, n.text;
    }).catch((n) => {
      throw new on({
        code: Or.INVALID_CREDENTIAL,
        message: `Failed to determine service account. Make sure to initialize the SDK with a service account credential. Alternatively specify a service account with iam.serviceAccounts.signBlob permission. Original error: ${n}`
      });
    });
  }
}
hr.IAMSigner = Zy;
function nw(t) {
  const e = t.options.credential;
  return e instanceof ew.ServiceAccountCredential ? new Qy(e) : new Zy(new Ll.AuthorizedHttpClient(t), t);
}
class on extends Error {
  constructor(e) {
    super(e.message), this.errorInfo = e, this.__proto__ = on.prototype;
  }
  /** @returns The error code. */
  get code() {
    return this.errorInfo.code;
  }
  /** @returns The error message. */
  get message() {
    return this.errorInfo.message;
  }
  /** @returns The error data. */
  get cause() {
    return this.errorInfo.cause;
  }
}
hr.CryptoSignerError = on;
class Or {
}
hr.CryptoSignerErrorCode = Or;
Or.INVALID_ARGUMENT = "invalid-argument";
Or.INTERNAL_ERROR = "internal-error";
Or.INVALID_CREDENTIAL = "invalid-credential";
Or.SERVER_ERROR = "server-error";
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.FirebaseTokenGenerator = t.EmulatedSigner = t.BLACKLISTED_CLAIMS = void 0, t.handleCryptoSignerError = f;
  const e = Te, r = hr, n = Ue, i = at, a = "none", s = 60 * 60;
  t.BLACKLISTED_CLAIMS = [
    "acr",
    "amr",
    "at_hash",
    "aud",
    "auth_time",
    "azp",
    "cnf",
    "c_hash",
    "exp",
    "iat",
    "iss",
    "jti",
    "nbf",
    "nonce"
  ];
  const o = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit";
  class l {
    constructor() {
      this.algorithm = a;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign(p) {
      return Promise.resolve(Buffer.from(""));
    }
    /**
     * @inheritDoc
     */
    getAccountId() {
      return Promise.resolve("firebase-auth-emulator@example.com");
    }
  }
  t.EmulatedSigner = l;
  class u {
    /**
     * @param tenantId - The tenant ID to use for the generated Firebase Auth
     *     Custom token. If absent, then no tenant ID claim will be set in the
     *     resulting JWT.
     */
    constructor(p, S) {
      if (this.tenantId = S, !n.isNonNullObject(p))
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_CREDENTIAL, "INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.");
      if (typeof this.tenantId < "u" && !n.isNonEmptyString(this.tenantId))
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "`tenantId` argument must be a non-empty string.");
      this.signer = p;
    }
    /**
     * Creates a new Firebase Auth Custom token.
     *
     * @param uid - The user ID to use for the generated Firebase Auth Custom token.
     * @param developerClaims - Optional developer claims to include in the generated Firebase
     *     Auth Custom token.
     * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a
     *     service account key and containing the provided payload.
     */
    createCustomToken(p, S) {
      let A;
      if (n.isNonEmptyString(p) ? p.length > 128 ? A = "`uid` argument must a uid with less than or equal to 128 characters." : this.isDeveloperClaimsValid_(S) || (A = "`developerClaims` argument must be a valid, non-null object containing the developer claims.") : A = "`uid` argument must be a non-empty string uid.", A)
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, A);
      const I = {};
      if (typeof S < "u") {
        for (const c in S)
          if (Object.prototype.hasOwnProperty.call(S, c)) {
            if (t.BLACKLISTED_CLAIMS.indexOf(c) !== -1)
              throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim "${c}" is reserved and cannot be specified.`);
            I[c] = S[c];
          }
      }
      return this.signer.getAccountId().then((c) => {
        const E = {
          alg: this.signer.algorithm,
          typ: "JWT"
        }, v = Math.floor(Date.now() / 1e3), R = {
          aud: o,
          iat: v,
          exp: v + s,
          iss: c,
          sub: c,
          uid: p
        };
        this.tenantId && (R.tenant_id = this.tenantId), Object.keys(I).length > 0 && (R.claims = I);
        const N = `${this.encodeSegment(E)}.${this.encodeSegment(R)}`, C = this.signer.sign(Buffer.from(N));
        return Promise.all([N, C]);
      }).then(([c, E]) => `${c}.${this.encodeSegment(E)}`).catch((c) => {
        throw f(c);
      });
    }
    encodeSegment(p) {
      const S = p instanceof Buffer ? p : Buffer.from(JSON.stringify(p));
      return (0, i.toWebSafeBase64)(S).replace(/=+$/, "");
    }
    /**
     * Returns whether or not the provided developer claims are valid.
     *
     * @param developerClaims - Optional developer claims to validate.
     * @returns True if the provided claims are valid; otherwise, false.
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    isDeveloperClaimsValid_(p) {
      return typeof p > "u" ? !0 : n.isNonNullObject(p);
    }
  }
  t.FirebaseTokenGenerator = u;
  function f(m) {
    if (!(m instanceof r.CryptoSignerError))
      return m;
    if (m.code === r.CryptoSignerErrorCode.SERVER_ERROR && n.isNonNullObject(m.cause)) {
      const S = m.cause.response.data;
      if (n.isNonNullObject(S) && S.error) {
        const A = S.error.status, c = `${S.error.message}; Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens for more details on how to use and troubleshoot this feature.`;
        return e.FirebaseAuthError.fromServerError(A, c, S);
      }
      return new e.FirebaseAuthError(e.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + S + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
    }
    return new e.FirebaseAuthError(y(m.code), m.message);
  }
  function y(m) {
    switch (m) {
      case r.CryptoSignerErrorCode.INVALID_CREDENTIAL:
        return e.AuthClientErrorCode.INVALID_CREDENTIAL;
      case r.CryptoSignerErrorCode.INVALID_ARGUMENT:
        return e.AuthClientErrorCode.INVALID_ARGUMENT;
      default:
        return e.AuthClientErrorCode.INTERNAL_ERROR;
    }
  }
})(Xy);
var em = {}, tm = {}, Jr = {}, Bs = ln.Buffer, iw = ge, aw = ge;
function Vo(t) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !t)
    return this.buffer = Bs.alloc(0), this;
  if (typeof t.pipe == "function")
    return this.buffer = Bs.alloc(0), t.pipe(this), this;
  if (t.length || typeof t == "object")
    return this.buffer = t, this.writable = !1, process.nextTick((function() {
      this.emit("end", t), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof t + ")");
}
aw.inherits(Vo, iw);
Vo.prototype.write = function(e) {
  this.buffer = Bs.concat([this.buffer, Bs.from(e)]), this.emit("data", e);
};
Vo.prototype.end = function(e) {
  e && this.write(e), this.emit("end", e), this.emit("close"), this.writable = !1, this.readable = !1;
};
var rm = Vo, Oi = ln.Buffer, gr = ge, nm = nf, Up = ge, sw = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, aa = "secret must be a string or buffer", Si = "key must be a string or a buffer", ow = "key must be a string, a buffer or an object", $f = typeof gr.createPublicKey == "function";
$f && (Si += " or a KeyObject", aa += "or a KeyObject");
function im(t) {
  if (!Oi.isBuffer(t) && typeof t != "string" && (!$f || typeof t != "object" || typeof t.type != "string" || typeof t.asymmetricKeyType != "string" || typeof t.export != "function"))
    throw Dr(Si);
}
function am(t) {
  if (!Oi.isBuffer(t) && typeof t != "string" && typeof t != "object")
    throw Dr(ow);
}
function cw(t) {
  if (!Oi.isBuffer(t)) {
    if (typeof t == "string")
      return t;
    if (!$f || typeof t != "object" || t.type !== "secret" || typeof t.export != "function")
      throw Dr(aa);
  }
}
function Hf(t) {
  return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function sm(t) {
  t = t.toString();
  var e = 4 - t.length % 4;
  if (e !== 4)
    for (var r = 0; r < e; ++r)
      t += "=";
  return t.replace(/\-/g, "+").replace(/_/g, "/");
}
function Dr(t) {
  var e = [].slice.call(arguments, 1), r = Up.format.bind(Up, t).apply(null, e);
  return new TypeError(r);
}
function uw(t) {
  return Oi.isBuffer(t) || typeof t == "string";
}
function Ua(t) {
  return uw(t) || (t = JSON.stringify(t)), t;
}
function om(t) {
  return function(r, n) {
    cw(n), r = Ua(r);
    var i = gr.createHmac("sha" + t, n), a = (i.update(r), i.digest("base64"));
    return Hf(a);
  };
}
var ju, lw = "timingSafeEqual" in gr ? function(e, r) {
  return e.byteLength !== r.byteLength ? !1 : gr.timingSafeEqual(e, r);
} : function(e, r) {
  return ju || (ju = Fg()), ju(e, r);
};
function fw(t) {
  return function(r, n, i) {
    var a = om(t)(r, i);
    return lw(Oi.from(n), Oi.from(a));
  };
}
function cm(t) {
  return function(r, n) {
    am(n), r = Ua(r);
    var i = gr.createSign("RSA-SHA" + t), a = (i.update(r), i.sign(n, "base64"));
    return Hf(a);
  };
}
function um(t) {
  return function(r, n, i) {
    im(i), r = Ua(r), n = sm(n);
    var a = gr.createVerify("RSA-SHA" + t);
    return a.update(r), a.verify(i, n, "base64");
  };
}
function dw(t) {
  return function(r, n) {
    am(n), r = Ua(r);
    var i = gr.createSign("RSA-SHA" + t), a = (i.update(r), i.sign({
      key: n,
      padding: gr.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: gr.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return Hf(a);
  };
}
function hw(t) {
  return function(r, n, i) {
    im(i), r = Ua(r), n = sm(n);
    var a = gr.createVerify("RSA-SHA" + t);
    return a.update(r), a.verify({
      key: i,
      padding: gr.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: gr.constants.RSA_PSS_SALTLEN_DIGEST
    }, n, "base64");
  };
}
function pw(t) {
  var e = cm(t);
  return function() {
    var n = e.apply(null, arguments);
    return n = nm.derToJose(n, "ES" + t), n;
  };
}
function gw(t) {
  var e = um(t);
  return function(n, i, a) {
    i = nm.joseToDer(i, "ES" + t).toString("base64");
    var s = e(n, i, a);
    return s;
  };
}
function yw() {
  return function() {
    return "";
  };
}
function mw() {
  return function(e, r) {
    return r === "";
  };
}
var lm = function(e) {
  var r = {
    hs: om,
    rs: cm,
    ps: dw,
    es: pw,
    none: yw
  }, n = {
    hs: fw,
    rs: um,
    ps: hw,
    es: gw,
    none: mw
  }, i = e.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!i)
    throw Dr(sw, e);
  var a = (i[1] || i[3]).toLowerCase(), s = i[2];
  return {
    sign: r[a](s),
    verify: n[a](s)
  };
}, Ew = ge.Buffer, fm = function(e) {
  return typeof e == "string" ? e : typeof e == "number" || Ew.isBuffer(e) ? e.toString() : JSON.stringify(e);
}, vw = ln.Buffer, Fp = rm, Aw = lm, Cw = ge, Mp = fm, Kf = ge;
function Vp(t, e) {
  return vw.from(t, e).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function _w(t, e, r) {
  r = r || "utf8";
  var n = Vp(Mp(t), "binary"), i = Vp(Mp(e), r);
  return Kf.format("%s.%s", n, i);
}
function dm(t) {
  var e = t.header, r = t.payload, n = t.secret || t.privateKey, i = t.encoding, a = Aw(e.alg), s = _w(e, r, i), o = a.sign(s, n);
  return Kf.format("%s.%s", s, o);
}
function $o(t) {
  var e = t.secret || t.privateKey || t.key, r = new Fp(e);
  this.readable = !0, this.header = t.header, this.encoding = t.encoding, this.secret = this.privateKey = this.key = r, this.payload = new Fp(t.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
Kf.inherits($o, Cw);
$o.prototype.sign = function() {
  try {
    var e = dm({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", e), this.emit("data", e), this.emit("end"), this.readable = !1, e;
  } catch (r) {
    this.readable = !1, this.emit("error", r), this.emit("close");
  }
};
$o.sign = dm;
var Sw = $o, hm = ln.Buffer, $p = rm, Iw = lm, bw = ge, pm = fm, ww = ge, Tw = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function Rw(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Nw(t) {
  if (Rw(t))
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}
function gm(t) {
  var e = t.split(".", 1)[0];
  return Nw(hm.from(e, "base64").toString("binary"));
}
function xw(t) {
  return t.split(".", 2).join(".");
}
function ym(t) {
  return t.split(".")[2];
}
function Ow(t, e) {
  e = e || "utf8";
  var r = t.split(".")[1];
  return hm.from(r, "base64").toString(e);
}
function mm(t) {
  return Tw.test(t) && !!gm(t);
}
function Em(t, e, r) {
  if (!e) {
    var n = new Error("Missing algorithm parameter for jws.verify");
    throw n.code = "MISSING_ALGORITHM", n;
  }
  t = pm(t);
  var i = ym(t), a = xw(t), s = Iw(e);
  return s.verify(a, i, r);
}
function vm(t, e) {
  if (e = e || {}, t = pm(t), !mm(t))
    return null;
  var r = gm(t);
  if (!r)
    return null;
  var n = Ow(t);
  return (r.typ === "JWT" || e.json) && (n = JSON.parse(n, e.encoding)), {
    header: r,
    payload: n,
    signature: ym(t)
  };
}
function Gi(t) {
  t = t || {};
  var e = t.secret || t.publicKey || t.key, r = new $p(e);
  this.readable = !0, this.algorithm = t.algorithm, this.encoding = t.encoding, this.secret = this.publicKey = this.key = r, this.signature = new $p(t.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
ww.inherits(Gi, bw);
Gi.prototype.verify = function() {
  try {
    var e = Em(this.signature.buffer, this.algorithm, this.key.buffer), r = vm(this.signature.buffer, this.encoding);
    return this.emit("done", e, r), this.emit("data", e), this.emit("end"), this.readable = !1, e;
  } catch (n) {
    this.readable = !1, this.emit("error", n), this.emit("close");
  }
};
Gi.decode = vm;
Gi.isValid = mm;
Gi.verify = Em;
var Dw = Gi, Am = Sw, Ho = Dw, Lw = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
Jr.ALGORITHMS = Lw;
Jr.sign = Am.sign;
Jr.verify = Ho.verify;
Jr.decode = Ho.decode;
Jr.isValid = Ho.isValid;
Jr.createSign = function(e) {
  return new Am(e);
};
Jr.createVerify = function(e) {
  return new Ho(e);
};
var Pw = Jr, Cm = function(t, e) {
  e = e || {};
  var r = Pw.decode(t, e);
  if (!r)
    return null;
  var n = r.payload;
  if (typeof n == "string")
    try {
      var i = JSON.parse(n);
      i !== null && typeof i == "object" && (n = i);
    } catch {
    }
  return e.complete === !0 ? {
    header: r.header,
    payload: n,
    signature: r.signature
  } : n;
}, Us = function(t, e) {
  Error.call(this, t), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = t, e && (this.inner = e);
};
Us.prototype = Object.create(Error.prototype);
Us.prototype.constructor = Us;
var Ko = Us, _m = Ko, Fs = function(t, e) {
  _m.call(this, t), this.name = "NotBeforeError", this.date = e;
};
Fs.prototype = Object.create(_m.prototype);
Fs.prototype.constructor = Fs;
var Sm = Fs, Im = Ko, Ms = function(t, e) {
  Im.call(this, t), this.name = "TokenExpiredError", this.expiredAt = e;
};
Ms.prototype = Object.create(Im.prototype);
Ms.prototype.constructor = Ms;
var bm = Ms, Di = 1e3, Li = Di * 60, Pi = Li * 60, Wn = Pi * 24, kw = Wn * 7, Bw = Wn * 365.25, Uw = function(t, e) {
  e = e || {};
  var r = typeof t;
  if (r === "string" && t.length > 0)
    return Fw(t);
  if (r === "number" && isFinite(t))
    return e.long ? Vw(t) : Mw(t);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
  );
};
function Fw(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      t
    );
    if (e) {
      var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
      switch (n) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * Bw;
        case "weeks":
        case "week":
        case "w":
          return r * kw;
        case "days":
        case "day":
        case "d":
          return r * Wn;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * Pi;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * Li;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * Di;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function Mw(t) {
  var e = Math.abs(t);
  return e >= Wn ? Math.round(t / Wn) + "d" : e >= Pi ? Math.round(t / Pi) + "h" : e >= Li ? Math.round(t / Li) + "m" : e >= Di ? Math.round(t / Di) + "s" : t + "ms";
}
function Vw(t) {
  var e = Math.abs(t);
  return e >= Wn ? is(t, e, Wn, "day") : e >= Pi ? is(t, e, Pi, "hour") : e >= Li ? is(t, e, Li, "minute") : e >= Di ? is(t, e, Di, "second") : t + " ms";
}
function is(t, e, r, n) {
  var i = e >= r * 1.5;
  return Math.round(t / r) + " " + n + (i ? "s" : "");
}
var $w = Uw, wm = function(t, e) {
  var r = e || Math.floor(Date.now() / 1e3);
  if (typeof t == "string") {
    var n = $w(t);
    return typeof n > "u" ? void 0 : Math.floor(r + n / 1e3);
  } else return typeof t == "number" ? r + t : void 0;
}, Pl = { exports: {} };
const Hw = "2.0.0", Tm = 256, Kw = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, Gw = 16, jw = Tm - 6, qw = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Go = {
  MAX_LENGTH: Tm,
  MAX_SAFE_COMPONENT_LENGTH: Gw,
  MAX_SAFE_BUILD_LENGTH: jw,
  MAX_SAFE_INTEGER: Kw,
  RELEASE_TYPES: qw,
  SEMVER_SPEC_VERSION: Hw,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const Ww = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var jo = Ww;
(function(t, e) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: i
  } = Go, a = jo;
  e = t.exports = {};
  const s = e.re = [], o = e.safeRe = [], l = e.src = [], u = e.safeSrc = [], f = e.t = {};
  let y = 0;
  const m = "[a-zA-Z0-9-]", p = [
    ["\\s", 1],
    ["\\d", i],
    [m, n]
  ], S = (I) => {
    for (const [c, E] of p)
      I = I.split(`${c}*`).join(`${c}{0,${E}}`).split(`${c}+`).join(`${c}{1,${E}}`);
    return I;
  }, A = (I, c, E) => {
    const v = S(c), R = y++;
    a(I, R, c), f[I] = R, l[R] = c, u[R] = v, s[R] = new RegExp(c, E ? "g" : void 0), o[R] = new RegExp(v, E ? "g" : void 0);
  };
  A("NUMERICIDENTIFIER", "0|[1-9]\\d*"), A("NUMERICIDENTIFIERLOOSE", "\\d+"), A("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m}*`), A("MAINVERSION", `(${l[f.NUMERICIDENTIFIER]})\\.(${l[f.NUMERICIDENTIFIER]})\\.(${l[f.NUMERICIDENTIFIER]})`), A("MAINVERSIONLOOSE", `(${l[f.NUMERICIDENTIFIERLOOSE]})\\.(${l[f.NUMERICIDENTIFIERLOOSE]})\\.(${l[f.NUMERICIDENTIFIERLOOSE]})`), A("PRERELEASEIDENTIFIER", `(?:${l[f.NONNUMERICIDENTIFIER]}|${l[f.NUMERICIDENTIFIER]})`), A("PRERELEASEIDENTIFIERLOOSE", `(?:${l[f.NONNUMERICIDENTIFIER]}|${l[f.NUMERICIDENTIFIERLOOSE]})`), A("PRERELEASE", `(?:-(${l[f.PRERELEASEIDENTIFIER]}(?:\\.${l[f.PRERELEASEIDENTIFIER]})*))`), A("PRERELEASELOOSE", `(?:-?(${l[f.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[f.PRERELEASEIDENTIFIERLOOSE]})*))`), A("BUILDIDENTIFIER", `${m}+`), A("BUILD", `(?:\\+(${l[f.BUILDIDENTIFIER]}(?:\\.${l[f.BUILDIDENTIFIER]})*))`), A("FULLPLAIN", `v?${l[f.MAINVERSION]}${l[f.PRERELEASE]}?${l[f.BUILD]}?`), A("FULL", `^${l[f.FULLPLAIN]}$`), A("LOOSEPLAIN", `[v=\\s]*${l[f.MAINVERSIONLOOSE]}${l[f.PRERELEASELOOSE]}?${l[f.BUILD]}?`), A("LOOSE", `^${l[f.LOOSEPLAIN]}$`), A("GTLT", "((?:<|>)?=?)"), A("XRANGEIDENTIFIERLOOSE", `${l[f.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), A("XRANGEIDENTIFIER", `${l[f.NUMERICIDENTIFIER]}|x|X|\\*`), A("XRANGEPLAIN", `[v=\\s]*(${l[f.XRANGEIDENTIFIER]})(?:\\.(${l[f.XRANGEIDENTIFIER]})(?:\\.(${l[f.XRANGEIDENTIFIER]})(?:${l[f.PRERELEASE]})?${l[f.BUILD]}?)?)?`), A("XRANGEPLAINLOOSE", `[v=\\s]*(${l[f.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[f.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[f.XRANGEIDENTIFIERLOOSE]})(?:${l[f.PRERELEASELOOSE]})?${l[f.BUILD]}?)?)?`), A("XRANGE", `^${l[f.GTLT]}\\s*${l[f.XRANGEPLAIN]}$`), A("XRANGELOOSE", `^${l[f.GTLT]}\\s*${l[f.XRANGEPLAINLOOSE]}$`), A("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), A("COERCE", `${l[f.COERCEPLAIN]}(?:$|[^\\d])`), A("COERCEFULL", l[f.COERCEPLAIN] + `(?:${l[f.PRERELEASE]})?(?:${l[f.BUILD]})?(?:$|[^\\d])`), A("COERCERTL", l[f.COERCE], !0), A("COERCERTLFULL", l[f.COERCEFULL], !0), A("LONETILDE", "(?:~>?)"), A("TILDETRIM", `(\\s*)${l[f.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", A("TILDE", `^${l[f.LONETILDE]}${l[f.XRANGEPLAIN]}$`), A("TILDELOOSE", `^${l[f.LONETILDE]}${l[f.XRANGEPLAINLOOSE]}$`), A("LONECARET", "(?:\\^)"), A("CARETTRIM", `(\\s*)${l[f.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", A("CARET", `^${l[f.LONECARET]}${l[f.XRANGEPLAIN]}$`), A("CARETLOOSE", `^${l[f.LONECARET]}${l[f.XRANGEPLAINLOOSE]}$`), A("COMPARATORLOOSE", `^${l[f.GTLT]}\\s*(${l[f.LOOSEPLAIN]})$|^$`), A("COMPARATOR", `^${l[f.GTLT]}\\s*(${l[f.FULLPLAIN]})$|^$`), A("COMPARATORTRIM", `(\\s*)${l[f.GTLT]}\\s*(${l[f.LOOSEPLAIN]}|${l[f.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", A("HYPHENRANGE", `^\\s*(${l[f.XRANGEPLAIN]})\\s+-\\s+(${l[f.XRANGEPLAIN]})\\s*$`), A("HYPHENRANGELOOSE", `^\\s*(${l[f.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[f.XRANGEPLAINLOOSE]})\\s*$`), A("STAR", "(<|>)?=?\\s*\\*"), A("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), A("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Pl, Pl.exports);
var Fa = Pl.exports;
const Jw = Object.freeze({ loose: !0 }), zw = Object.freeze({}), Xw = (t) => t ? typeof t != "object" ? Jw : t : zw;
var Gf = Xw;
const Hp = /^[0-9]+$/, Rm = (t, e) => {
  const r = Hp.test(t), n = Hp.test(e);
  return r && n && (t = +t, e = +e), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1;
}, Yw = (t, e) => Rm(e, t);
var Nm = {
  compareIdentifiers: Rm,
  rcompareIdentifiers: Yw
};
const as = jo, { MAX_LENGTH: Kp, MAX_SAFE_INTEGER: ss } = Go, { safeRe: os, t: cs } = Fa, Qw = Gf, { compareIdentifiers: mi } = Nm;
let Zw = class Vr {
  constructor(e, r) {
    if (r = Qw(r), e instanceof Vr) {
      if (e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
    if (e.length > Kp)
      throw new TypeError(
        `version is longer than ${Kp} characters`
      );
    as("SemVer", e, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = e.trim().match(r.loose ? os[cs.LOOSE] : os[cs.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > ss || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > ss || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > ss || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const a = +i;
        if (a >= 0 && a < ss)
          return a;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (as("SemVer.compare", this.version, this.options, e), !(e instanceof Vr)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new Vr(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof Vr || (e = new Vr(e, this.options)), mi(this.major, e.major) || mi(this.minor, e.minor) || mi(this.patch, e.patch);
  }
  comparePre(e) {
    if (e instanceof Vr || (e = new Vr(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], i = e.prerelease[r];
      if (as("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return mi(n, i);
    } while (++r);
  }
  compareBuild(e) {
    e instanceof Vr || (e = new Vr(e, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = e.build[r];
      if (as("build compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return mi(n, i);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, r, n) {
    if (e.startsWith("pre")) {
      if (!r && n === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (r) {
        const i = `-${r}`.match(this.options.loose ? os[cs.PRERELEASELOOSE] : os[cs.PRERELEASE]);
        if (!i || i[1] !== r)
          throw new Error(`invalid identifier: ${r}`);
      }
    }
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, n), this.inc("pre", r, n);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(n) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" && (this.prerelease[a]++, a = -2);
          if (a === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (r) {
          let a = [r, i];
          n === !1 && (a = [r]), mi(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var Wt = Zw;
const Gp = Wt, eT = (t, e, r = !1) => {
  if (t instanceof Gp)
    return t;
  try {
    return new Gp(t, e);
  } catch (n) {
    if (!r)
      return null;
    throw n;
  }
};
var ji = eT;
const tT = ji, rT = (t, e) => {
  const r = tT(t, e);
  return r ? r.version : null;
};
var nT = rT;
const iT = ji, aT = (t, e) => {
  const r = iT(t.trim().replace(/^[=v]+/, ""), e);
  return r ? r.version : null;
};
var sT = aT;
const jp = Wt, oT = (t, e, r, n, i) => {
  typeof r == "string" && (i = n, n = r, r = void 0);
  try {
    return new jp(
      t instanceof jp ? t.version : t,
      r
    ).inc(e, n, i).version;
  } catch {
    return null;
  }
};
var cT = oT;
const qp = ji, uT = (t, e) => {
  const r = qp(t, null, !0), n = qp(e, null, !0), i = r.compare(n);
  if (i === 0)
    return null;
  const a = i > 0, s = a ? r : n, o = a ? n : r, l = !!s.prerelease.length;
  if (!!o.prerelease.length && !l) {
    if (!o.patch && !o.minor)
      return "major";
    if (o.compareMain(s) === 0)
      return o.minor && !o.patch ? "minor" : "patch";
  }
  const f = l ? "pre" : "";
  return r.major !== n.major ? f + "major" : r.minor !== n.minor ? f + "minor" : r.patch !== n.patch ? f + "patch" : "prerelease";
};
var lT = uT;
const fT = Wt, dT = (t, e) => new fT(t, e).major;
var hT = dT;
const pT = Wt, gT = (t, e) => new pT(t, e).minor;
var yT = gT;
const mT = Wt, ET = (t, e) => new mT(t, e).patch;
var vT = ET;
const AT = ji, CT = (t, e) => {
  const r = AT(t, e);
  return r && r.prerelease.length ? r.prerelease : null;
};
var _T = CT;
const Wp = Wt, ST = (t, e, r) => new Wp(t, r).compare(new Wp(e, r));
var kr = ST;
const IT = kr, bT = (t, e, r) => IT(e, t, r);
var wT = bT;
const TT = kr, RT = (t, e) => TT(t, e, !0);
var NT = RT;
const Jp = Wt, xT = (t, e, r) => {
  const n = new Jp(t, r), i = new Jp(e, r);
  return n.compare(i) || n.compareBuild(i);
};
var jf = xT;
const OT = jf, DT = (t, e) => t.sort((r, n) => OT(r, n, e));
var LT = DT;
const PT = jf, kT = (t, e) => t.sort((r, n) => PT(n, r, e));
var BT = kT;
const UT = kr, FT = (t, e, r) => UT(t, e, r) > 0;
var qo = FT;
const MT = kr, VT = (t, e, r) => MT(t, e, r) < 0;
var qf = VT;
const $T = kr, HT = (t, e, r) => $T(t, e, r) === 0;
var xm = HT;
const KT = kr, GT = (t, e, r) => KT(t, e, r) !== 0;
var Om = GT;
const jT = kr, qT = (t, e, r) => jT(t, e, r) >= 0;
var Wf = qT;
const WT = kr, JT = (t, e, r) => WT(t, e, r) <= 0;
var Jf = JT;
const zT = xm, XT = Om, YT = qo, QT = Wf, ZT = qf, e1 = Jf, t1 = (t, e, r, n) => {
  switch (e) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t === r;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t !== r;
    case "":
    case "=":
    case "==":
      return zT(t, r, n);
    case "!=":
      return XT(t, r, n);
    case ">":
      return YT(t, r, n);
    case ">=":
      return QT(t, r, n);
    case "<":
      return ZT(t, r, n);
    case "<=":
      return e1(t, r, n);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var Dm = t1;
const r1 = Wt, n1 = ji, { safeRe: us, t: ls } = Fa, i1 = (t, e) => {
  if (t instanceof r1)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  e = e || {};
  let r = null;
  if (!e.rtl)
    r = t.match(e.includePrerelease ? us[ls.COERCEFULL] : us[ls.COERCE]);
  else {
    const l = e.includePrerelease ? us[ls.COERCERTLFULL] : us[ls.COERCERTL];
    let u;
    for (; (u = l.exec(t)) && (!r || r.index + r[0].length !== t.length); )
      (!r || u.index + u[0].length !== r.index + r[0].length) && (r = u), l.lastIndex = u.index + u[1].length + u[2].length;
    l.lastIndex = -1;
  }
  if (r === null)
    return null;
  const n = r[2], i = r[3] || "0", a = r[4] || "0", s = e.includePrerelease && r[5] ? `-${r[5]}` : "", o = e.includePrerelease && r[6] ? `+${r[6]}` : "";
  return n1(`${n}.${i}.${a}${s}${o}`, e);
};
var a1 = i1;
let s1 = class {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(e) {
    const r = this.map.get(e);
    if (r !== void 0)
      return this.map.delete(e), this.map.set(e, r), r;
  }
  delete(e) {
    return this.map.delete(e);
  }
  set(e, r) {
    if (!this.delete(e) && r !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(e, r);
    }
    return this;
  }
};
var o1 = s1, qu, zp;
function Br() {
  if (zp) return qu;
  zp = 1;
  const t = /\s+/g;
  class e {
    constructor(K, Q) {
      if (Q = i(Q), K instanceof e)
        return K.loose === !!Q.loose && K.includePrerelease === !!Q.includePrerelease ? K : new e(K.raw, Q);
      if (K instanceof a)
        return this.raw = K.value, this.set = [[K]], this.formatted = void 0, this;
      if (this.options = Q, this.loose = !!Q.loose, this.includePrerelease = !!Q.includePrerelease, this.raw = K.trim().replace(t, " "), this.set = this.raw.split("||").map((ee) => this.parseRange(ee.trim())).filter((ee) => ee.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const ee = this.set[0];
        if (this.set = this.set.filter((ne) => !A(ne[0])), this.set.length === 0)
          this.set = [ee];
        else if (this.set.length > 1) {
          for (const ne of this.set)
            if (ne.length === 1 && I(ne[0])) {
              this.set = [ne];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let K = 0; K < this.set.length; K++) {
          K > 0 && (this.formatted += "||");
          const Q = this.set[K];
          for (let ee = 0; ee < Q.length; ee++)
            ee > 0 && (this.formatted += " "), this.formatted += Q[ee].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(K) {
      const ee = ((this.options.includePrerelease && p) | (this.options.loose && S)) + ":" + K, ne = n.get(ee);
      if (ne)
        return ne;
      const ae = this.options.loose, se = ae ? l[u.HYPHENRANGELOOSE] : l[u.HYPHENRANGE];
      K = K.replace(se, D(this.options.includePrerelease)), s("hyphen replace", K), K = K.replace(l[u.COMPARATORTRIM], f), s("comparator trim", K), K = K.replace(l[u.TILDETRIM], y), s("tilde trim", K), K = K.replace(l[u.CARETTRIM], m), s("caret trim", K);
      let me = K.split(" ").map((Ce) => E(Ce, this.options)).join(" ").split(/\s+/).map((Ce) => L(Ce, this.options));
      ae && (me = me.filter((Ce) => (s("loose invalid filter", Ce, this.options), !!Ce.match(l[u.COMPARATORLOOSE])))), s("range list", me);
      const ye = /* @__PURE__ */ new Map(), Se = me.map((Ce) => new a(Ce, this.options));
      for (const Ce of Se) {
        if (A(Ce))
          return [Ce];
        ye.set(Ce.value, Ce);
      }
      ye.size > 1 && ye.has("") && ye.delete("");
      const te = [...ye.values()];
      return n.set(ee, te), te;
    }
    intersects(K, Q) {
      if (!(K instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((ee) => c(ee, Q) && K.set.some((ne) => c(ne, Q) && ee.every((ae) => ne.every((se) => ae.intersects(se, Q)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(K) {
      if (!K)
        return !1;
      if (typeof K == "string")
        try {
          K = new o(K, this.options);
        } catch {
          return !1;
        }
      for (let Q = 0; Q < this.set.length; Q++)
        if (V(this.set[Q], K, this.options))
          return !0;
      return !1;
    }
  }
  qu = e;
  const r = o1, n = new r(), i = Gf, a = Wo(), s = jo, o = Wt, {
    safeRe: l,
    t: u,
    comparatorTrimReplace: f,
    tildeTrimReplace: y,
    caretTrimReplace: m
  } = Fa, { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: S } = Go, A = ($) => $.value === "<0.0.0-0", I = ($) => $.value === "", c = ($, K) => {
    let Q = !0;
    const ee = $.slice();
    let ne = ee.pop();
    for (; Q && ee.length; )
      Q = ee.every((ae) => ne.intersects(ae, K)), ne = ee.pop();
    return Q;
  }, E = ($, K) => (s("comp", $, K), $ = C($, K), s("caret", $), $ = R($, K), s("tildes", $), $ = d($, K), s("xrange", $), $ = P($, K), s("stars", $), $), v = ($) => !$ || $.toLowerCase() === "x" || $ === "*", R = ($, K) => $.trim().split(/\s+/).map((Q) => N(Q, K)).join(" "), N = ($, K) => {
    const Q = K.loose ? l[u.TILDELOOSE] : l[u.TILDE];
    return $.replace(Q, (ee, ne, ae, se, me) => {
      s("tilde", $, ee, ne, ae, se, me);
      let ye;
      return v(ne) ? ye = "" : v(ae) ? ye = `>=${ne}.0.0 <${+ne + 1}.0.0-0` : v(se) ? ye = `>=${ne}.${ae}.0 <${ne}.${+ae + 1}.0-0` : me ? (s("replaceTilde pr", me), ye = `>=${ne}.${ae}.${se}-${me} <${ne}.${+ae + 1}.0-0`) : ye = `>=${ne}.${ae}.${se} <${ne}.${+ae + 1}.0-0`, s("tilde return", ye), ye;
    });
  }, C = ($, K) => $.trim().split(/\s+/).map((Q) => h(Q, K)).join(" "), h = ($, K) => {
    s("caret", $, K);
    const Q = K.loose ? l[u.CARETLOOSE] : l[u.CARET], ee = K.includePrerelease ? "-0" : "";
    return $.replace(Q, (ne, ae, se, me, ye) => {
      s("caret", $, ne, ae, se, me, ye);
      let Se;
      return v(ae) ? Se = "" : v(se) ? Se = `>=${ae}.0.0${ee} <${+ae + 1}.0.0-0` : v(me) ? ae === "0" ? Se = `>=${ae}.${se}.0${ee} <${ae}.${+se + 1}.0-0` : Se = `>=${ae}.${se}.0${ee} <${+ae + 1}.0.0-0` : ye ? (s("replaceCaret pr", ye), ae === "0" ? se === "0" ? Se = `>=${ae}.${se}.${me}-${ye} <${ae}.${se}.${+me + 1}-0` : Se = `>=${ae}.${se}.${me}-${ye} <${ae}.${+se + 1}.0-0` : Se = `>=${ae}.${se}.${me}-${ye} <${+ae + 1}.0.0-0`) : (s("no pr"), ae === "0" ? se === "0" ? Se = `>=${ae}.${se}.${me}${ee} <${ae}.${se}.${+me + 1}-0` : Se = `>=${ae}.${se}.${me}${ee} <${ae}.${+se + 1}.0-0` : Se = `>=${ae}.${se}.${me} <${+ae + 1}.0.0-0`), s("caret return", Se), Se;
    });
  }, d = ($, K) => (s("replaceXRanges", $, K), $.split(/\s+/).map((Q) => O(Q, K)).join(" ")), O = ($, K) => {
    $ = $.trim();
    const Q = K.loose ? l[u.XRANGELOOSE] : l[u.XRANGE];
    return $.replace(Q, (ee, ne, ae, se, me, ye) => {
      s("xRange", $, ee, ne, ae, se, me, ye);
      const Se = v(ae), te = Se || v(se), Ce = te || v(me), fe = Ce;
      return ne === "=" && fe && (ne = ""), ye = K.includePrerelease ? "-0" : "", Se ? ne === ">" || ne === "<" ? ee = "<0.0.0-0" : ee = "*" : ne && fe ? (te && (se = 0), me = 0, ne === ">" ? (ne = ">=", te ? (ae = +ae + 1, se = 0, me = 0) : (se = +se + 1, me = 0)) : ne === "<=" && (ne = "<", te ? ae = +ae + 1 : se = +se + 1), ne === "<" && (ye = "-0"), ee = `${ne + ae}.${se}.${me}${ye}`) : te ? ee = `>=${ae}.0.0${ye} <${+ae + 1}.0.0-0` : Ce && (ee = `>=${ae}.${se}.0${ye} <${ae}.${+se + 1}.0-0`), s("xRange return", ee), ee;
    });
  }, P = ($, K) => (s("replaceStars", $, K), $.trim().replace(l[u.STAR], "")), L = ($, K) => (s("replaceGTE0", $, K), $.trim().replace(l[K.includePrerelease ? u.GTE0PRE : u.GTE0], "")), D = ($) => (K, Q, ee, ne, ae, se, me, ye, Se, te, Ce, fe) => (v(ee) ? Q = "" : v(ne) ? Q = `>=${ee}.0.0${$ ? "-0" : ""}` : v(ae) ? Q = `>=${ee}.${ne}.0${$ ? "-0" : ""}` : se ? Q = `>=${Q}` : Q = `>=${Q}${$ ? "-0" : ""}`, v(Se) ? ye = "" : v(te) ? ye = `<${+Se + 1}.0.0-0` : v(Ce) ? ye = `<${Se}.${+te + 1}.0-0` : fe ? ye = `<=${Se}.${te}.${Ce}-${fe}` : $ ? ye = `<${Se}.${te}.${+Ce + 1}-0` : ye = `<=${ye}`, `${Q} ${ye}`.trim()), V = ($, K, Q) => {
    for (let ee = 0; ee < $.length; ee++)
      if (!$[ee].test(K))
        return !1;
    if (K.prerelease.length && !Q.includePrerelease) {
      for (let ee = 0; ee < $.length; ee++)
        if (s($[ee].semver), $[ee].semver !== a.ANY && $[ee].semver.prerelease.length > 0) {
          const ne = $[ee].semver;
          if (ne.major === K.major && ne.minor === K.minor && ne.patch === K.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return qu;
}
var Wu, Xp;
function Wo() {
  if (Xp) return Wu;
  Xp = 1;
  const t = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(f, y) {
      if (y = r(y), f instanceof e) {
        if (f.loose === !!y.loose)
          return f;
        f = f.value;
      }
      f = f.trim().split(/\s+/).join(" "), s("comparator", f, y), this.options = y, this.loose = !!y.loose, this.parse(f), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(f) {
      const y = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], m = f.match(y);
      if (!m)
        throw new TypeError(`Invalid comparator: ${f}`);
      this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new o(m[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (s("Comparator.test", f, this.options.loose), this.semver === t || f === t)
        return !0;
      if (typeof f == "string")
        try {
          f = new o(f, this.options);
        } catch {
          return !1;
        }
      return a(f, this.operator, this.semver, this.options);
    }
    intersects(f, y) {
      if (!(f instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new l(f.value, y).test(this.value) : f.operator === "" ? f.value === "" ? !0 : new l(this.value, y).test(f.semver) : (y = r(y), y.includePrerelease && (this.value === "<0.0.0-0" || f.value === "<0.0.0-0") || !y.includePrerelease && (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && f.operator.startsWith(">") || this.operator.startsWith("<") && f.operator.startsWith("<") || this.semver.version === f.semver.version && this.operator.includes("=") && f.operator.includes("=") || a(this.semver, "<", f.semver, y) && this.operator.startsWith(">") && f.operator.startsWith("<") || a(this.semver, ">", f.semver, y) && this.operator.startsWith("<") && f.operator.startsWith(">")));
    }
  }
  Wu = e;
  const r = Gf, { safeRe: n, t: i } = Fa, a = Dm, s = jo, o = Wt, l = Br();
  return Wu;
}
const c1 = Br(), u1 = (t, e, r) => {
  try {
    e = new c1(e, r);
  } catch {
    return !1;
  }
  return e.test(t);
};
var Jo = u1;
const l1 = Br(), f1 = (t, e) => new l1(t, e).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var d1 = f1;
const h1 = Wt, p1 = Br(), g1 = (t, e, r) => {
  let n = null, i = null, a = null;
  try {
    a = new p1(e, r);
  } catch {
    return null;
  }
  return t.forEach((s) => {
    a.test(s) && (!n || i.compare(s) === -1) && (n = s, i = new h1(n, r));
  }), n;
};
var y1 = g1;
const m1 = Wt, E1 = Br(), v1 = (t, e, r) => {
  let n = null, i = null, a = null;
  try {
    a = new E1(e, r);
  } catch {
    return null;
  }
  return t.forEach((s) => {
    a.test(s) && (!n || i.compare(s) === 1) && (n = s, i = new m1(n, r));
  }), n;
};
var A1 = v1;
const Ju = Wt, C1 = Br(), Yp = qo, _1 = (t, e) => {
  t = new C1(t, e);
  let r = new Ju("0.0.0");
  if (t.test(r) || (r = new Ju("0.0.0-0"), t.test(r)))
    return r;
  r = null;
  for (let n = 0; n < t.set.length; ++n) {
    const i = t.set[n];
    let a = null;
    i.forEach((s) => {
      const o = new Ju(s.semver.version);
      switch (s.operator) {
        case ">":
          o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0), o.raw = o.format();
        case "":
        case ">=":
          (!a || Yp(o, a)) && (a = o);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${s.operator}`);
      }
    }), a && (!r || Yp(r, a)) && (r = a);
  }
  return r && t.test(r) ? r : null;
};
var S1 = _1;
const I1 = Br(), b1 = (t, e) => {
  try {
    return new I1(t, e).range || "*";
  } catch {
    return null;
  }
};
var w1 = b1;
const T1 = Wt, Lm = Wo(), { ANY: R1 } = Lm, N1 = Br(), x1 = Jo, Qp = qo, Zp = qf, O1 = Jf, D1 = Wf, L1 = (t, e, r, n) => {
  t = new T1(t, n), e = new N1(e, n);
  let i, a, s, o, l;
  switch (r) {
    case ">":
      i = Qp, a = O1, s = Zp, o = ">", l = ">=";
      break;
    case "<":
      i = Zp, a = D1, s = Qp, o = "<", l = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (x1(t, e, n))
    return !1;
  for (let u = 0; u < e.set.length; ++u) {
    const f = e.set[u];
    let y = null, m = null;
    if (f.forEach((p) => {
      p.semver === R1 && (p = new Lm(">=0.0.0")), y = y || p, m = m || p, i(p.semver, y.semver, n) ? y = p : s(p.semver, m.semver, n) && (m = p);
    }), y.operator === o || y.operator === l || (!m.operator || m.operator === o) && a(t, m.semver))
      return !1;
    if (m.operator === l && s(t, m.semver))
      return !1;
  }
  return !0;
};
var zf = L1;
const P1 = zf, k1 = (t, e, r) => P1(t, e, ">", r);
var B1 = k1;
const U1 = zf, F1 = (t, e, r) => U1(t, e, "<", r);
var M1 = F1;
const e0 = Br(), V1 = (t, e, r) => (t = new e0(t, r), e = new e0(e, r), t.intersects(e, r));
var $1 = V1;
const H1 = Jo, K1 = kr;
var G1 = (t, e, r) => {
  const n = [];
  let i = null, a = null;
  const s = t.sort((f, y) => K1(f, y, r));
  for (const f of s)
    H1(f, e, r) ? (a = f, i || (i = f)) : (a && n.push([i, a]), a = null, i = null);
  i && n.push([i, null]);
  const o = [];
  for (const [f, y] of n)
    f === y ? o.push(f) : !y && f === s[0] ? o.push("*") : y ? f === s[0] ? o.push(`<=${y}`) : o.push(`${f} - ${y}`) : o.push(`>=${f}`);
  const l = o.join(" || "), u = typeof e.raw == "string" ? e.raw : String(e);
  return l.length < u.length ? l : e;
};
const t0 = Br(), Xf = Wo(), { ANY: zu } = Xf, Qi = Jo, Yf = kr, j1 = (t, e, r = {}) => {
  if (t === e)
    return !0;
  t = new t0(t, r), e = new t0(e, r);
  let n = !1;
  e: for (const i of t.set) {
    for (const a of e.set) {
      const s = W1(i, a, r);
      if (n = n || s !== null, s)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
}, q1 = [new Xf(">=0.0.0-0")], r0 = [new Xf(">=0.0.0")], W1 = (t, e, r) => {
  if (t === e)
    return !0;
  if (t.length === 1 && t[0].semver === zu) {
    if (e.length === 1 && e[0].semver === zu)
      return !0;
    r.includePrerelease ? t = q1 : t = r0;
  }
  if (e.length === 1 && e[0].semver === zu) {
    if (r.includePrerelease)
      return !0;
    e = r0;
  }
  const n = /* @__PURE__ */ new Set();
  let i, a;
  for (const p of t)
    p.operator === ">" || p.operator === ">=" ? i = n0(i, p, r) : p.operator === "<" || p.operator === "<=" ? a = i0(a, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let s;
  if (i && a) {
    if (s = Yf(i.semver, a.semver, r), s > 0)
      return null;
    if (s === 0 && (i.operator !== ">=" || a.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (i && !Qi(p, String(i), r) || a && !Qi(p, String(a), r))
      return null;
    for (const S of e)
      if (!Qi(p, String(S), r))
        return !1;
    return !0;
  }
  let o, l, u, f, y = a && !r.includePrerelease && a.semver.prerelease.length ? a.semver : !1, m = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  y && y.prerelease.length === 1 && a.operator === "<" && y.prerelease[0] === 0 && (y = !1);
  for (const p of e) {
    if (f = f || p.operator === ">" || p.operator === ">=", u = u || p.operator === "<" || p.operator === "<=", i) {
      if (m && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === m.major && p.semver.minor === m.minor && p.semver.patch === m.patch && (m = !1), p.operator === ">" || p.operator === ">=") {
        if (o = n0(i, p, r), o === p && o !== i)
          return !1;
      } else if (i.operator === ">=" && !Qi(i.semver, String(p), r))
        return !1;
    }
    if (a) {
      if (y && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === y.major && p.semver.minor === y.minor && p.semver.patch === y.patch && (y = !1), p.operator === "<" || p.operator === "<=") {
        if (l = i0(a, p, r), l === p && l !== a)
          return !1;
      } else if (a.operator === "<=" && !Qi(a.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (a || i) && s !== 0)
      return !1;
  }
  return !(i && u && !a && s !== 0 || a && f && !i && s !== 0 || m || y);
}, n0 = (t, e, r) => {
  if (!t)
    return e;
  const n = Yf(t.semver, e.semver, r);
  return n > 0 ? t : n < 0 || e.operator === ">" && t.operator === ">=" ? e : t;
}, i0 = (t, e, r) => {
  if (!t)
    return e;
  const n = Yf(t.semver, e.semver, r);
  return n < 0 ? t : n > 0 || e.operator === "<" && t.operator === "<=" ? e : t;
};
var J1 = j1;
const Xu = Fa, a0 = Go, z1 = Wt, s0 = Nm, X1 = ji, Y1 = nT, Q1 = sT, Z1 = cT, eR = lT, tR = hT, rR = yT, nR = vT, iR = _T, aR = kr, sR = wT, oR = NT, cR = jf, uR = LT, lR = BT, fR = qo, dR = qf, hR = xm, pR = Om, gR = Wf, yR = Jf, mR = Dm, ER = a1, vR = Wo(), AR = Br(), CR = Jo, _R = d1, SR = y1, IR = A1, bR = S1, wR = w1, TR = zf, RR = B1, NR = M1, xR = $1, OR = G1, DR = J1;
var Qf = {
  parse: X1,
  valid: Y1,
  clean: Q1,
  inc: Z1,
  diff: eR,
  major: tR,
  minor: rR,
  patch: nR,
  prerelease: iR,
  compare: aR,
  rcompare: sR,
  compareLoose: oR,
  compareBuild: cR,
  sort: uR,
  rsort: lR,
  gt: fR,
  lt: dR,
  eq: hR,
  neq: pR,
  gte: gR,
  lte: yR,
  cmp: mR,
  coerce: ER,
  Comparator: vR,
  Range: AR,
  satisfies: CR,
  toComparators: _R,
  maxSatisfying: SR,
  minSatisfying: IR,
  minVersion: bR,
  validRange: wR,
  outside: TR,
  gtr: RR,
  ltr: NR,
  intersects: xR,
  simplifyRange: OR,
  subset: DR,
  SemVer: z1,
  re: Xu.re,
  src: Xu.src,
  tokens: Xu.t,
  SEMVER_SPEC_VERSION: a0.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: a0.RELEASE_TYPES,
  compareIdentifiers: s0.compareIdentifiers,
  rcompareIdentifiers: s0.rcompareIdentifiers
};
const LR = Qf;
var PR = LR.satisfies(process.version, ">=15.7.0");
const kR = Qf;
var BR = kR.satisfies(process.version, ">=16.9.0");
const UR = PR, FR = BR, MR = {
  ec: ["ES256", "ES384", "ES512"],
  rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
  "rsa-pss": ["PS256", "PS384", "PS512"]
}, VR = {
  ES256: "prime256v1",
  ES384: "secp384r1",
  ES512: "secp521r1"
};
var Pm = function(t, e) {
  if (!t || !e) return;
  const r = e.asymmetricKeyType;
  if (!r) return;
  const n = MR[r];
  if (!n)
    throw new Error(`Unknown key type "${r}".`);
  if (!n.includes(t))
    throw new Error(`"alg" parameter for "${r}" key type must be one of: ${n.join(", ")}.`);
  if (UR)
    switch (r) {
      case "ec":
        const i = e.asymmetricKeyDetails.namedCurve, a = VR[t];
        if (i !== a)
          throw new Error(`"alg" parameter "${t}" requires curve "${a}".`);
        break;
      case "rsa-pss":
        if (FR) {
          const s = parseInt(t.slice(-3), 10), { hashAlgorithm: o, mgf1HashAlgorithm: l, saltLength: u } = e.asymmetricKeyDetails;
          if (o !== `sha${s}` || l !== o)
            throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${t}.`);
          if (u !== void 0 && u > s >> 3)
            throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${t}.`);
        }
        break;
    }
}, $R = Qf, km = $R.satisfies(process.version, "^6.12.0 || >=8.0.0");
const Ye = Ko, HR = Sm, o0 = bm, KR = Cm, GR = wm, jR = Pm, qR = km, WR = Jr, { KeyObject: JR, createSecretKey: zR, createPublicKey: XR } = ge, kl = ["RS256", "RS384", "RS512"], YR = ["ES256", "ES384", "ES512"], Bl = ["RS256", "RS384", "RS512"], QR = ["HS256", "HS384", "HS512"];
qR && (kl.splice(kl.length, 0, "PS256", "PS384", "PS512"), Bl.splice(Bl.length, 0, "PS256", "PS384", "PS512"));
var ZR = function(t, e, r, n) {
  typeof r == "function" && !n && (n = r, r = {}), r || (r = {}), r = Object.assign({}, r);
  let i;
  if (n ? i = n : i = function(f, y) {
    if (f) throw f;
    return y;
  }, r.clockTimestamp && typeof r.clockTimestamp != "number")
    return i(new Ye("clockTimestamp must be a number"));
  if (r.nonce !== void 0 && (typeof r.nonce != "string" || r.nonce.trim() === ""))
    return i(new Ye("nonce must be a non-empty string"));
  if (r.allowInvalidAsymmetricKeyTypes !== void 0 && typeof r.allowInvalidAsymmetricKeyTypes != "boolean")
    return i(new Ye("allowInvalidAsymmetricKeyTypes must be a boolean"));
  const a = r.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!t)
    return i(new Ye("jwt must be provided"));
  if (typeof t != "string")
    return i(new Ye("jwt must be a string"));
  const s = t.split(".");
  if (s.length !== 3)
    return i(new Ye("jwt malformed"));
  let o;
  try {
    o = KR(t, { complete: !0 });
  } catch (f) {
    return i(f);
  }
  if (!o)
    return i(new Ye("invalid token"));
  const l = o.header;
  let u;
  if (typeof e == "function") {
    if (!n)
      return i(new Ye("verify must be called asynchronous if secret or public key is provided as a callback"));
    u = e;
  } else
    u = function(f, y) {
      return y(null, e);
    };
  return u(l, function(f, y) {
    if (f)
      return i(new Ye("error in secret or public key callback: " + f.message));
    const m = s[2].trim() !== "";
    if (!m && y)
      return i(new Ye("jwt signature is required"));
    if (m && !y)
      return i(new Ye("secret or public key must be provided"));
    if (!m && !r.algorithms)
      return i(new Ye('please specify "none" in "algorithms" to verify unsigned tokens'));
    if (y != null && !(y instanceof JR))
      try {
        y = XR(y);
      } catch {
        try {
          y = zR(typeof y == "string" ? Buffer.from(y) : y);
        } catch {
          return i(new Ye("secretOrPublicKey is not valid key material"));
        }
      }
    if (r.algorithms || (y.type === "secret" ? r.algorithms = QR : ["rsa", "rsa-pss"].includes(y.asymmetricKeyType) ? r.algorithms = Bl : y.asymmetricKeyType === "ec" ? r.algorithms = YR : r.algorithms = kl), r.algorithms.indexOf(o.header.alg) === -1)
      return i(new Ye("invalid algorithm"));
    if (l.alg.startsWith("HS") && y.type !== "secret")
      return i(new Ye(`secretOrPublicKey must be a symmetric key when using ${l.alg}`));
    if (/^(?:RS|PS|ES)/.test(l.alg) && y.type !== "public")
      return i(new Ye(`secretOrPublicKey must be an asymmetric key when using ${l.alg}`));
    if (!r.allowInvalidAsymmetricKeyTypes)
      try {
        jR(l.alg, y);
      } catch (A) {
        return i(A);
      }
    let p;
    try {
      p = WR.verify(t, o.header.alg, y);
    } catch (A) {
      return i(A);
    }
    if (!p)
      return i(new Ye("invalid signature"));
    const S = o.payload;
    if (typeof S.nbf < "u" && !r.ignoreNotBefore) {
      if (typeof S.nbf != "number")
        return i(new Ye("invalid nbf value"));
      if (S.nbf > a + (r.clockTolerance || 0))
        return i(new HR("jwt not active", new Date(S.nbf * 1e3)));
    }
    if (typeof S.exp < "u" && !r.ignoreExpiration) {
      if (typeof S.exp != "number")
        return i(new Ye("invalid exp value"));
      if (a >= S.exp + (r.clockTolerance || 0))
        return i(new o0("jwt expired", new Date(S.exp * 1e3)));
    }
    if (r.audience) {
      const A = Array.isArray(r.audience) ? r.audience : [r.audience];
      if (!(Array.isArray(S.aud) ? S.aud : [S.aud]).some(function(E) {
        return A.some(function(v) {
          return v instanceof RegExp ? v.test(E) : v === E;
        });
      }))
        return i(new Ye("jwt audience invalid. expected: " + A.join(" or ")));
    }
    if (r.issuer && (typeof r.issuer == "string" && S.iss !== r.issuer || Array.isArray(r.issuer) && r.issuer.indexOf(S.iss) === -1))
      return i(new Ye("jwt issuer invalid. expected: " + r.issuer));
    if (r.subject && S.sub !== r.subject)
      return i(new Ye("jwt subject invalid. expected: " + r.subject));
    if (r.jwtid && S.jti !== r.jwtid)
      return i(new Ye("jwt jwtid invalid. expected: " + r.jwtid));
    if (r.nonce && S.nonce !== r.nonce)
      return i(new Ye("jwt nonce invalid. expected: " + r.nonce));
    if (r.maxAge) {
      if (typeof S.iat != "number")
        return i(new Ye("iat required when maxAge is specified"));
      const A = GR(r.maxAge, S.iat);
      if (typeof A > "u")
        return i(new Ye('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (a >= A + (r.clockTolerance || 0))
        return i(new o0("maxAge exceeded", new Date(A * 1e3)));
    }
    if (r.complete === !0) {
      const A = o.signature;
      return i(null, {
        header: l,
        payload: S,
        signature: A
      });
    }
    return i(null, S);
  });
}, c0 = 1 / 0, Bm = 9007199254740991, eN = 17976931348623157e292, u0 = NaN, tN = "[object Arguments]", rN = "[object Function]", nN = "[object GeneratorFunction]", iN = "[object String]", aN = "[object Symbol]", sN = /^\s+|\s+$/g, oN = /^[-+]0x[0-9a-f]+$/i, cN = /^0b[01]+$/i, uN = /^0o[0-7]+$/i, lN = /^(?:0|[1-9]\d*)$/, fN = parseInt;
function dN(t, e) {
  for (var r = -1, n = t ? t.length : 0, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
function hN(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function pN(t, e, r) {
  if (e !== e)
    return hN(t, gN, r);
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function gN(t) {
  return t !== t;
}
function yN(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
function mN(t, e) {
  return dN(e, function(r) {
    return t[r];
  });
}
function EN(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var zo = Object.prototype, Zf = zo.hasOwnProperty, Xo = zo.toString, vN = zo.propertyIsEnumerable, AN = EN(Object.keys, Object), CN = Math.max;
function _N(t, e) {
  var r = Um(t) || TN(t) ? yN(t.length, String) : [], n = r.length, i = !!n;
  for (var a in t)
    Zf.call(t, a) && !(i && (a == "length" || IN(a, n))) && r.push(a);
  return r;
}
function SN(t) {
  if (!bN(t))
    return AN(t);
  var e = [];
  for (var r in Object(t))
    Zf.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function IN(t, e) {
  return e = e ?? Bm, !!e && (typeof t == "number" || lN.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function bN(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || zo;
  return t === r;
}
function wN(t, e, r, n) {
  t = ed(t) ? t : UN(t), r = r && !n ? PN(r) : 0;
  var i = t.length;
  return r < 0 && (r = CN(i + r, 0)), ON(t) ? r <= i && t.indexOf(e, r) > -1 : !!i && pN(t, e, r) > -1;
}
function TN(t) {
  return RN(t) && Zf.call(t, "callee") && (!vN.call(t, "callee") || Xo.call(t) == tN);
}
var Um = Array.isArray;
function ed(t) {
  return t != null && xN(t.length) && !NN(t);
}
function RN(t) {
  return td(t) && ed(t);
}
function NN(t) {
  var e = Ul(t) ? Xo.call(t) : "";
  return e == rN || e == nN;
}
function xN(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Bm;
}
function Ul(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function td(t) {
  return !!t && typeof t == "object";
}
function ON(t) {
  return typeof t == "string" || !Um(t) && td(t) && Xo.call(t) == iN;
}
function DN(t) {
  return typeof t == "symbol" || td(t) && Xo.call(t) == aN;
}
function LN(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = kN(t), t === c0 || t === -c0) {
    var e = t < 0 ? -1 : 1;
    return e * eN;
  }
  return t === t ? t : 0;
}
function PN(t) {
  var e = LN(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function kN(t) {
  if (typeof t == "number")
    return t;
  if (DN(t))
    return u0;
  if (Ul(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Ul(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(sN, "");
  var r = cN.test(t);
  return r || uN.test(t) ? fN(t.slice(2), r ? 2 : 8) : oN.test(t) ? u0 : +t;
}
function BN(t) {
  return ed(t) ? _N(t) : SN(t);
}
function UN(t) {
  return t ? mN(t, BN(t)) : [];
}
var FN = wN, MN = "[object Boolean]", VN = Object.prototype, $N = VN.toString;
function HN(t) {
  return t === !0 || t === !1 || KN(t) && $N.call(t) == MN;
}
function KN(t) {
  return !!t && typeof t == "object";
}
var GN = HN, l0 = 1 / 0, jN = 17976931348623157e292, f0 = NaN, qN = "[object Symbol]", WN = /^\s+|\s+$/g, JN = /^[-+]0x[0-9a-f]+$/i, zN = /^0b[01]+$/i, XN = /^0o[0-7]+$/i, YN = parseInt, QN = Object.prototype, ZN = QN.toString;
function ex(t) {
  return typeof t == "number" && t == ix(t);
}
function d0(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function tx(t) {
  return !!t && typeof t == "object";
}
function rx(t) {
  return typeof t == "symbol" || tx(t) && ZN.call(t) == qN;
}
function nx(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = ax(t), t === l0 || t === -l0) {
    var e = t < 0 ? -1 : 1;
    return e * jN;
  }
  return t === t ? t : 0;
}
function ix(t) {
  var e = nx(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function ax(t) {
  if (typeof t == "number")
    return t;
  if (rx(t))
    return f0;
  if (d0(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = d0(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(WN, "");
  var r = zN.test(t);
  return r || XN.test(t) ? YN(t.slice(2), r ? 2 : 8) : JN.test(t) ? f0 : +t;
}
var sx = ex, ox = "[object Number]", cx = Object.prototype, ux = cx.toString;
function lx(t) {
  return !!t && typeof t == "object";
}
function fx(t) {
  return typeof t == "number" || lx(t) && ux.call(t) == ox;
}
var dx = fx, hx = "[object Object]";
function px(t) {
  var e = !1;
  if (t != null && typeof t.toString != "function")
    try {
      e = !!(t + "");
    } catch {
    }
  return e;
}
function gx(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var yx = Function.prototype, Fm = Object.prototype, Mm = yx.toString, mx = Fm.hasOwnProperty, Ex = Mm.call(Object), vx = Fm.toString, Ax = gx(Object.getPrototypeOf, Object);
function Cx(t) {
  return !!t && typeof t == "object";
}
function _x(t) {
  if (!Cx(t) || vx.call(t) != hx || px(t))
    return !1;
  var e = Ax(t);
  if (e === null)
    return !0;
  var r = mx.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Mm.call(r) == Ex;
}
var Sx = _x, Ix = "[object String]", bx = Object.prototype, wx = bx.toString, Tx = Array.isArray;
function Rx(t) {
  return !!t && typeof t == "object";
}
function Nx(t) {
  return typeof t == "string" || !Tx(t) && Rx(t) && wx.call(t) == Ix;
}
var xx = Nx, Ox = "Expected a function", h0 = 1 / 0, Dx = 17976931348623157e292, p0 = NaN, Lx = "[object Symbol]", Px = /^\s+|\s+$/g, kx = /^[-+]0x[0-9a-f]+$/i, Bx = /^0b[01]+$/i, Ux = /^0o[0-7]+$/i, Fx = parseInt, Mx = Object.prototype, Vx = Mx.toString;
function $x(t, e) {
  var r;
  if (typeof e != "function")
    throw new TypeError(Ox);
  return t = qx(t), function() {
    return --t > 0 && (r = e.apply(this, arguments)), t <= 1 && (e = void 0), r;
  };
}
function Hx(t) {
  return $x(2, t);
}
function g0(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function Kx(t) {
  return !!t && typeof t == "object";
}
function Gx(t) {
  return typeof t == "symbol" || Kx(t) && Vx.call(t) == Lx;
}
function jx(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Wx(t), t === h0 || t === -h0) {
    var e = t < 0 ? -1 : 1;
    return e * Dx;
  }
  return t === t ? t : 0;
}
function qx(t) {
  var e = jx(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function Wx(t) {
  if (typeof t == "number")
    return t;
  if (Gx(t))
    return p0;
  if (g0(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = g0(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(Px, "");
  var r = Bx.test(t);
  return r || Ux.test(t) ? Fx(t.slice(2), r ? 2 : 8) : kx.test(t) ? p0 : +t;
}
var Jx = Hx;
const y0 = wm, zx = km, Xx = Pm, m0 = Jr, Yx = FN, fs = GN, E0 = sx, Yu = dx, Vm = Sx, mn = xx, Qx = Jx, { KeyObject: Zx, createSecretKey: e2, createPrivateKey: t2 } = ge, $m = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
zx && $m.splice(3, 0, "PS256", "PS384", "PS512");
const r2 = {
  expiresIn: { isValid: function(t) {
    return E0(t) || mn(t) && t;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(t) {
    return E0(t) || mn(t) && t;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(t) {
    return mn(t) || Array.isArray(t);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: Yx.bind(null, $m), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: Vm, message: '"header" must be an object' },
  encoding: { isValid: mn, message: '"encoding" must be a string' },
  issuer: { isValid: mn, message: '"issuer" must be a string' },
  subject: { isValid: mn, message: '"subject" must be a string' },
  jwtid: { isValid: mn, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: fs, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: mn, message: '"keyid" must be a string' },
  mutatePayload: { isValid: fs, message: '"mutatePayload" must be a boolean' },
  allowInsecureKeySizes: { isValid: fs, message: '"allowInsecureKeySizes" must be a boolean' },
  allowInvalidAsymmetricKeyTypes: { isValid: fs, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
}, n2 = {
  iat: { isValid: Yu, message: '"iat" should be a number of seconds' },
  exp: { isValid: Yu, message: '"exp" should be a number of seconds' },
  nbf: { isValid: Yu, message: '"nbf" should be a number of seconds' }
};
function Hm(t, e, r, n) {
  if (!Vm(r))
    throw new Error('Expected "' + n + '" to be a plain object.');
  Object.keys(r).forEach(function(i) {
    const a = t[i];
    if (!a) {
      if (!e)
        throw new Error('"' + i + '" is not allowed in "' + n + '"');
      return;
    }
    if (!a.isValid(r[i]))
      throw new Error(a.message);
  });
}
function i2(t) {
  return Hm(r2, !1, t, "options");
}
function a2(t) {
  return Hm(n2, !0, t, "payload");
}
const v0 = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, s2 = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
];
var o2 = function(t, e, r, n) {
  typeof r == "function" ? (n = r, r = {}) : r = r || {};
  const i = typeof t == "object" && !Buffer.isBuffer(t), a = Object.assign({
    alg: r.algorithm || "HS256",
    typ: i ? "JWT" : void 0,
    kid: r.keyid
  }, r.header);
  function s(u) {
    if (n)
      return n(u);
    throw u;
  }
  if (!e && r.algorithm !== "none")
    return s(new Error("secretOrPrivateKey must have a value"));
  if (e != null && !(e instanceof Zx))
    try {
      e = t2(e);
    } catch {
      try {
        e = e2(typeof e == "string" ? Buffer.from(e) : e);
      } catch {
        return s(new Error("secretOrPrivateKey is not valid key material"));
      }
    }
  if (a.alg.startsWith("HS") && e.type !== "secret")
    return s(new Error(`secretOrPrivateKey must be a symmetric key when using ${a.alg}`));
  if (/^(?:RS|PS|ES)/.test(a.alg)) {
    if (e.type !== "private")
      return s(new Error(`secretOrPrivateKey must be an asymmetric key when using ${a.alg}`));
    if (!r.allowInsecureKeySizes && !a.alg.startsWith("ES") && e.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
    e.asymmetricKeyDetails.modulusLength < 2048)
      return s(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${a.alg}`));
  }
  if (typeof t > "u")
    return s(new Error("payload is required"));
  if (i) {
    try {
      a2(t);
    } catch (u) {
      return s(u);
    }
    r.mutatePayload || (t = Object.assign({}, t));
  } else {
    const u = s2.filter(function(f) {
      return typeof r[f] < "u";
    });
    if (u.length > 0)
      return s(new Error("invalid " + u.join(",") + " option for " + typeof t + " payload"));
  }
  if (typeof t.exp < "u" && typeof r.expiresIn < "u")
    return s(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof t.nbf < "u" && typeof r.notBefore < "u")
    return s(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    i2(r);
  } catch (u) {
    return s(u);
  }
  if (!r.allowInvalidAsymmetricKeyTypes)
    try {
      Xx(a.alg, e);
    } catch (u) {
      return s(u);
    }
  const o = t.iat || Math.floor(Date.now() / 1e3);
  if (r.noTimestamp ? delete t.iat : i && (t.iat = o), typeof r.notBefore < "u") {
    try {
      t.nbf = y0(r.notBefore, o);
    } catch (u) {
      return s(u);
    }
    if (typeof t.nbf > "u")
      return s(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof r.expiresIn < "u" && typeof t == "object") {
    try {
      t.exp = y0(r.expiresIn, o);
    } catch (u) {
      return s(u);
    }
    if (typeof t.exp > "u")
      return s(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(v0).forEach(function(u) {
    const f = v0[u];
    if (typeof r[u] < "u") {
      if (typeof t[f] < "u")
        return s(new Error('Bad "options.' + u + '" option. The payload already has an "' + f + '" property.'));
      t[f] = r[u];
    }
  });
  const l = r.encoding || "utf8";
  if (typeof n == "function")
    n = n && Qx(n), m0.createSign({
      header: a,
      privateKey: e,
      payload: t,
      encoding: l
    }).once("error", n).once("done", function(u) {
      if (!r.allowInsecureKeySizes && /^(?:RS|PS)/.test(a.alg) && u.length < 256)
        return n(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${a.alg}`));
      n(null, u);
    });
  else {
    let u = m0.sign({ header: a, payload: t, secret: e, encoding: l });
    if (!r.allowInsecureKeySizes && /^(?:RS|PS)/.test(a.alg) && u.length < 256)
      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${a.alg}`);
    return u;
  }
}, c2 = {
  decode: Cm,
  verify: ZR,
  sign: o2,
  JsonWebTokenError: Ko,
  NotBeforeError: Sm,
  TokenExpiredError: bm
}, Cr = { exports: {} }, Fl = { exports: {} }, Qu, A0;
function u2() {
  if (A0) return Qu;
  A0 = 1;
  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, a = n * 365.25;
  Qu = function(f, y) {
    y = y || {};
    var m = typeof f;
    if (m === "string" && f.length > 0)
      return s(f);
    if (m === "number" && isFinite(f))
      return y.long ? l(f) : o(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function s(f) {
    if (f = String(f), !(f.length > 100)) {
      var y = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (y) {
        var m = parseFloat(y[1]), p = (y[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return m * a;
          case "weeks":
          case "week":
          case "w":
            return m * i;
          case "days":
          case "day":
          case "d":
            return m * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return m * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return m * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return m * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return m;
          default:
            return;
        }
      }
    }
  }
  function o(f) {
    var y = Math.abs(f);
    return y >= n ? Math.round(f / n) + "d" : y >= r ? Math.round(f / r) + "h" : y >= e ? Math.round(f / e) + "m" : y >= t ? Math.round(f / t) + "s" : f + "ms";
  }
  function l(f) {
    var y = Math.abs(f);
    return y >= n ? u(f, y, n, "day") : y >= r ? u(f, y, r, "hour") : y >= e ? u(f, y, e, "minute") : y >= t ? u(f, y, t, "second") : f + " ms";
  }
  function u(f, y, m, p) {
    var S = y >= m * 1.5;
    return Math.round(f / m) + " " + p + (S ? "s" : "");
  }
  return Qu;
}
function l2(t) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = s, r.enable = i, r.enabled = o, r.humanize = u2(), r.destroy = u, Object.keys(t).forEach((f) => {
    r[f] = t[f];
  }), r.names = [], r.skips = [], r.formatters = {};
  function e(f) {
    let y = 0;
    for (let m = 0; m < f.length; m++)
      y = (y << 5) - y + f.charCodeAt(m), y |= 0;
    return r.colors[Math.abs(y) % r.colors.length];
  }
  r.selectColor = e;
  function r(f) {
    let y, m = null, p, S;
    function A(...I) {
      if (!A.enabled)
        return;
      const c = A, E = Number(/* @__PURE__ */ new Date()), v = E - (y || E);
      c.diff = v, c.prev = y, c.curr = E, y = E, I[0] = r.coerce(I[0]), typeof I[0] != "string" && I.unshift("%O");
      let R = 0;
      I[0] = I[0].replace(/%([a-zA-Z%])/g, (C, h) => {
        if (C === "%%")
          return "%";
        R++;
        const d = r.formatters[h];
        if (typeof d == "function") {
          const O = I[R];
          C = d.call(c, O), I.splice(R, 1), R--;
        }
        return C;
      }), r.formatArgs.call(c, I), (c.log || r.log).apply(c, I);
    }
    return A.namespace = f, A.useColors = r.useColors(), A.color = r.selectColor(f), A.extend = n, A.destroy = r.destroy, Object.defineProperty(A, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => m !== null ? m : (p !== r.namespaces && (p = r.namespaces, S = r.enabled(f)), S),
      set: (I) => {
        m = I;
      }
    }), typeof r.init == "function" && r.init(A), A;
  }
  function n(f, y) {
    const m = r(this.namespace + (typeof y > "u" ? ":" : y) + f);
    return m.log = this.log, m;
  }
  function i(f) {
    r.save(f), r.namespaces = f, r.names = [], r.skips = [];
    const y = (typeof f == "string" ? f : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
    for (const m of y)
      m[0] === "-" ? r.skips.push(m.slice(1)) : r.names.push(m);
  }
  function a(f, y) {
    let m = 0, p = 0, S = -1, A = 0;
    for (; m < f.length; )
      if (p < y.length && (y[p] === f[m] || y[p] === "*"))
        y[p] === "*" ? (S = p, A = m, p++) : (m++, p++);
      else if (S !== -1)
        p = S + 1, A++, m = A;
      else
        return !1;
    for (; p < y.length && y[p] === "*"; )
      p++;
    return p === y.length;
  }
  function s() {
    const f = [
      ...r.names,
      ...r.skips.map((y) => "-" + y)
    ].join(",");
    return r.enable(""), f;
  }
  function o(f) {
    for (const y of r.skips)
      if (a(f, y))
        return !1;
    for (const y of r.names)
      if (a(f, y))
        return !0;
    return !1;
  }
  function l(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var f2 = l2;
(function(t, e) {
  e.formatArgs = n, e.save = i, e.load = a, e.useColors = r, e.storage = s(), e.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    l.splice(1, 0, u, "color: inherit");
    let f = 0, y = 0;
    l[0].replace(/%[a-zA-Z%]/g, (m) => {
      m !== "%%" && (f++, m === "%c" && (y = f));
    }), l.splice(y, 0, u);
  }
  e.log = console.debug || console.log || (() => {
  });
  function i(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function a() {
    let l;
    try {
      l = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function s() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = f2(e);
  const { formatters: o } = t.exports;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(Fl, Fl.exports);
var rd = Fl.exports;
const Ne = crypto, rr = (t) => t instanceof CryptoKey, Km = async (t, e) => {
  const r = `SHA-${t.slice(-3)}`;
  return new Uint8Array(await Ne.subtle.digest(r, e));
}, dt = new TextEncoder(), mr = new TextDecoder(), Vs = 2 ** 32;
function zr(...t) {
  const e = t.reduce((i, { length: a }) => i + a, 0), r = new Uint8Array(e);
  let n = 0;
  return t.forEach((i) => {
    r.set(i, n), n += i.length;
  }), r;
}
function d2(t, e) {
  return zr(dt.encode(t), new Uint8Array([0]), e);
}
function Ml(t, e, r) {
  if (e < 0 || e >= Vs)
    throw new RangeError(`value must be >= 0 and <= ${Vs - 1}. Received ${e}`);
  t.set([e >>> 24, e >>> 16, e >>> 8, e & 255], r);
}
function Gm(t) {
  const e = Math.floor(t / Vs), r = t % Vs, n = new Uint8Array(8);
  return Ml(n, e, 0), Ml(n, r, 4), n;
}
function nd(t) {
  const e = new Uint8Array(4);
  return Ml(e, t), e;
}
function Zu(t) {
  return zr(nd(t.length), t);
}
async function h2(t, e, r) {
  const n = Math.ceil((e >> 3) / 32), i = new Uint8Array(n * 32);
  for (let a = 0; a < n; a++) {
    const s = new Uint8Array(4 + t.length + r.length);
    s.set(nd(a + 1)), s.set(t, 4), s.set(r, 4 + t.length), i.set(await Km("sha256", s), a * 32);
  }
  return i.slice(0, e >> 3);
}
const id = (t) => {
  let e = t;
  typeof e == "string" && (e = dt.encode(e));
  const r = 32768, n = [];
  for (let i = 0; i < e.length; i += r)
    n.push(String.fromCharCode.apply(null, e.subarray(i, i + r)));
  return btoa(n.join(""));
}, It = (t) => id(t).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"), jm = (t) => {
  const e = atob(t), r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e.charCodeAt(n);
  return r;
}, wt = (t) => {
  let e = t;
  e instanceof Uint8Array && (e = mr.decode(e)), e = e.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return jm(e);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};
class Nt extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(e) {
    var r;
    super(e), this.code = "ERR_JOSE_GENERIC", this.name = this.constructor.name, (r = Error.captureStackTrace) === null || r === void 0 || r.call(Error, this, this.constructor);
  }
}
class Zt extends Nt {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(e, r = "unspecified", n = "unspecified") {
    super(e), this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED", this.claim = r, this.reason = n;
  }
}
class Vl extends Nt {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(e, r = "unspecified", n = "unspecified") {
    super(e), this.code = "ERR_JWT_EXPIRED", this.claim = r, this.reason = n;
  }
}
class $s extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}
class Fe extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class pa extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWE_DECRYPTION_FAILED", this.message = "decryption operation failed";
  }
  static get code() {
    return "ERR_JWE_DECRYPTION_FAILED";
  }
}
class p2 extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWE_DECOMPRESSION_FAILED", this.message = "decompression operation failed";
  }
  static get code() {
    return "ERR_JWE_DECOMPRESSION_FAILED";
  }
}
class Ie extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWE_INVALID";
  }
  static get code() {
    return "ERR_JWE_INVALID";
  }
}
class Ge extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}
class er extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class qm extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWK_INVALID";
  }
  static get code() {
    return "ERR_JWK_INVALID";
  }
}
class Yo extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWKS_INVALID";
  }
  static get code() {
    return "ERR_JWKS_INVALID";
  }
}
class ad extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWKS_NO_MATCHING_KEY", this.message = "no applicable key found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_NO_MATCHING_KEY";
  }
}
class Wm extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS", this.message = "multiple matching keys found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
}
class Jm extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWKS_TIMEOUT", this.message = "request timed out";
  }
  static get code() {
    return "ERR_JWKS_TIMEOUT";
  }
}
class sd extends Nt {
  constructor() {
    super(...arguments), this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED", this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}
const g2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JOSEAlgNotAllowed: $s,
  JOSEError: Nt,
  JOSENotSupported: Fe,
  JWEDecompressionFailed: p2,
  JWEDecryptionFailed: pa,
  JWEInvalid: Ie,
  JWKInvalid: qm,
  JWKSInvalid: Yo,
  JWKSMultipleMatchingKeys: Wm,
  JWKSNoMatchingKey: ad,
  JWKSTimeout: Jm,
  JWSInvalid: Ge,
  JWSSignatureVerificationFailed: sd,
  JWTClaimValidationFailed: Zt,
  JWTExpired: Vl,
  JWTInvalid: er
}, Symbol.toStringTag, { value: "Module" })), Qo = Ne.getRandomValues.bind(Ne);
function zm(t) {
  switch (t) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new Fe(`Unsupported JWE Algorithm: ${t}`);
  }
}
const Xm = (t) => Qo(new Uint8Array(zm(t) >> 3)), Ym = (t, e) => {
  if (e.length << 3 !== zm(t))
    throw new Ie("Invalid Initialization Vector length");
}, Hs = (t, e) => {
  const r = t.byteLength << 3;
  if (r !== e)
    throw new Ie(`Invalid Content Encryption Key length. Expected ${e} bits, got ${r} bits`);
}, y2 = (t, e) => {
  if (!(t instanceof Uint8Array))
    throw new TypeError("First argument must be a buffer");
  if (!(e instanceof Uint8Array))
    throw new TypeError("Second argument must be a buffer");
  if (t.length !== e.length)
    throw new TypeError("Input buffers must have the same length");
  const r = t.length;
  let n = 0, i = -1;
  for (; ++i < r; )
    n |= t[i] ^ e[i];
  return n === 0;
};
function Dt(t, e = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${t}`);
}
function Cn(t, e) {
  return t.name === e;
}
function Cs(t) {
  return parseInt(t.name.slice(4), 10);
}
function m2(t) {
  switch (t) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function Qm(t, e) {
  if (e.length && !e.some((r) => t.usages.includes(r))) {
    let r = "CryptoKey does not support this operation, its usages must include ";
    if (e.length > 2) {
      const n = e.pop();
      r += `one of ${e.join(", ")}, or ${n}.`;
    } else e.length === 2 ? r += `one of ${e[0]} or ${e[1]}.` : r += `${e[0]}.`;
    throw new TypeError(r);
  }
}
function E2(t, e, ...r) {
  switch (e) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!Cn(t.algorithm, "HMAC"))
        throw Dt("HMAC");
      const n = parseInt(e.slice(2), 10);
      if (Cs(t.algorithm.hash) !== n)
        throw Dt(`SHA-${n}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!Cn(t.algorithm, "RSASSA-PKCS1-v1_5"))
        throw Dt("RSASSA-PKCS1-v1_5");
      const n = parseInt(e.slice(2), 10);
      if (Cs(t.algorithm.hash) !== n)
        throw Dt(`SHA-${n}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!Cn(t.algorithm, "RSA-PSS"))
        throw Dt("RSA-PSS");
      const n = parseInt(e.slice(2), 10);
      if (Cs(t.algorithm.hash) !== n)
        throw Dt(`SHA-${n}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (t.algorithm.name !== "Ed25519" && t.algorithm.name !== "Ed448")
        throw Dt("Ed25519 or Ed448");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!Cn(t.algorithm, "ECDSA"))
        throw Dt("ECDSA");
      const n = m2(e);
      if (t.algorithm.namedCurve !== n)
        throw Dt(n, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  Qm(t, r);
}
function bn(t, e, ...r) {
  switch (e) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!Cn(t.algorithm, "AES-GCM"))
        throw Dt("AES-GCM");
      const n = parseInt(e.slice(1, 4), 10);
      if (t.algorithm.length !== n)
        throw Dt(n, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!Cn(t.algorithm, "AES-KW"))
        throw Dt("AES-KW");
      const n = parseInt(e.slice(1, 4), 10);
      if (t.algorithm.length !== n)
        throw Dt(n, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (t.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw Dt("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!Cn(t.algorithm, "PBKDF2"))
        throw Dt("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!Cn(t.algorithm, "RSA-OAEP"))
        throw Dt("RSA-OAEP");
      const n = parseInt(e.slice(9), 10) || 1;
      if (Cs(t.algorithm.hash) !== n)
        throw Dt(`SHA-${n}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  Qm(t, r);
}
function Zm(t, e, ...r) {
  if (r.length > 2) {
    const n = r.pop();
    t += `one of type ${r.join(", ")}, or ${n}.`;
  } else r.length === 2 ? t += `one of type ${r[0]} or ${r[1]}.` : t += `of type ${r[0]}.`;
  return e == null ? t += ` Received ${e}` : typeof e == "function" && e.name ? t += ` Received function ${e.name}` : typeof e == "object" && e != null && e.constructor && e.constructor.name && (t += ` Received an instance of ${e.constructor.name}`), t;
}
const $t = (t, ...e) => Zm("Key must be ", t, ...e);
function eE(t, e, ...r) {
  return Zm(`Key for the ${t} algorithm must be `, e, ...r);
}
const tE = (t) => rr(t), st = ["CryptoKey"];
async function v2(t, e, r, n, i, a) {
  if (!(e instanceof Uint8Array))
    throw new TypeError($t(e, "Uint8Array"));
  const s = parseInt(t.slice(1, 4), 10), o = await Ne.subtle.importKey("raw", e.subarray(s >> 3), "AES-CBC", !1, ["decrypt"]), l = await Ne.subtle.importKey("raw", e.subarray(0, s >> 3), {
    hash: `SHA-${s << 1}`,
    name: "HMAC"
  }, !1, ["sign"]), u = zr(a, n, r, Gm(a.length << 3)), f = new Uint8Array((await Ne.subtle.sign("HMAC", l, u)).slice(0, s >> 3));
  let y;
  try {
    y = y2(i, f);
  } catch {
  }
  if (!y)
    throw new pa();
  let m;
  try {
    m = new Uint8Array(await Ne.subtle.decrypt({ iv: n, name: "AES-CBC" }, o, r));
  } catch {
  }
  if (!m)
    throw new pa();
  return m;
}
async function A2(t, e, r, n, i, a) {
  let s;
  e instanceof Uint8Array ? s = await Ne.subtle.importKey("raw", e, "AES-GCM", !1, ["decrypt"]) : (bn(e, t, "decrypt"), s = e);
  try {
    return new Uint8Array(await Ne.subtle.decrypt({
      additionalData: a,
      iv: n,
      name: "AES-GCM",
      tagLength: 128
    }, s, zr(r, i)));
  } catch {
    throw new pa();
  }
}
const rE = async (t, e, r, n, i, a) => {
  if (!rr(e) && !(e instanceof Uint8Array))
    throw new TypeError($t(e, ...st, "Uint8Array"));
  switch (Ym(t, n), t) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return e instanceof Uint8Array && Hs(e, parseInt(t.slice(-3), 10)), v2(t, e, r, n, i, a);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      return e instanceof Uint8Array && Hs(e, parseInt(t.slice(1, 4), 10)), A2(t, e, r, n, i, a);
    default:
      throw new Fe("Unsupported JWE Content Encryption Algorithm");
  }
}, C2 = async () => {
  throw new Fe('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
}, _2 = async () => {
  throw new Fe('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
}, Ma = (...t) => {
  const e = t.filter(Boolean);
  if (e.length === 0 || e.length === 1)
    return !0;
  let r;
  for (const n of e) {
    const i = Object.keys(n);
    if (!r || r.size === 0) {
      r = new Set(i);
      continue;
    }
    for (const a of i) {
      if (r.has(a))
        return !1;
      r.add(a);
    }
  }
  return !0;
};
function S2(t) {
  return typeof t == "object" && t !== null;
}
function Rt(t) {
  if (!S2(t) || Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(t) === null)
    return !0;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
const Zo = [
  { hash: "SHA-256", name: "HMAC" },
  !0,
  ["sign"]
];
function nE(t, e) {
  if (t.algorithm.length !== parseInt(e.slice(1, 4), 10))
    throw new TypeError(`Invalid key size for alg: ${e}`);
}
function iE(t, e, r) {
  if (rr(t))
    return bn(t, e, r), t;
  if (t instanceof Uint8Array)
    return Ne.subtle.importKey("raw", t, "AES-KW", !0, [r]);
  throw new TypeError($t(t, ...st, "Uint8Array"));
}
const $l = async (t, e, r) => {
  const n = await iE(e, t, "wrapKey");
  nE(n, t);
  const i = await Ne.subtle.importKey("raw", r, ...Zo);
  return new Uint8Array(await Ne.subtle.wrapKey("raw", i, n, "AES-KW"));
}, Hl = async (t, e, r) => {
  const n = await iE(e, t, "unwrapKey");
  nE(n, t);
  const i = await Ne.subtle.unwrapKey("raw", r, n, "AES-KW", ...Zo);
  return new Uint8Array(await Ne.subtle.exportKey("raw", i));
};
async function aE(t, e, r, n, i = new Uint8Array(0), a = new Uint8Array(0)) {
  if (!rr(t))
    throw new TypeError($t(t, ...st));
  if (bn(t, "ECDH"), !rr(e))
    throw new TypeError($t(e, ...st));
  bn(e, "ECDH", "deriveBits");
  const s = zr(Zu(dt.encode(r)), Zu(i), Zu(a), nd(n));
  let o;
  t.algorithm.name === "X25519" ? o = 256 : t.algorithm.name === "X448" ? o = 448 : o = Math.ceil(parseInt(t.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  const l = new Uint8Array(await Ne.subtle.deriveBits({
    name: t.algorithm.name,
    public: t
  }, e, o));
  return h2(l, n, s);
}
async function I2(t) {
  if (!rr(t))
    throw new TypeError($t(t, ...st));
  return Ne.subtle.generateKey(t.algorithm, !0, ["deriveBits"]);
}
function sE(t) {
  if (!rr(t))
    throw new TypeError($t(t, ...st));
  return ["P-256", "P-384", "P-521"].includes(t.algorithm.namedCurve) || t.algorithm.name === "X25519" || t.algorithm.name === "X448";
}
function b2(t) {
  if (!(t instanceof Uint8Array) || t.length < 8)
    throw new Ie("PBES2 Salt Input must be 8 or more octets");
}
function w2(t, e) {
  if (t instanceof Uint8Array)
    return Ne.subtle.importKey("raw", t, "PBKDF2", !1, ["deriveBits"]);
  if (rr(t))
    return bn(t, e, "deriveBits", "deriveKey"), t;
  throw new TypeError($t(t, ...st, "Uint8Array"));
}
async function oE(t, e, r, n) {
  b2(t);
  const i = d2(e, t), a = parseInt(e.slice(13, 16), 10), s = {
    hash: `SHA-${e.slice(8, 11)}`,
    iterations: r,
    name: "PBKDF2",
    salt: i
  }, o = {
    length: a,
    name: "AES-KW"
  }, l = await w2(n, e);
  if (l.usages.includes("deriveBits"))
    return new Uint8Array(await Ne.subtle.deriveBits(s, l, a));
  if (l.usages.includes("deriveKey"))
    return Ne.subtle.deriveKey(s, l, o, !1, ["wrapKey", "unwrapKey"]);
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
const T2 = async (t, e, r, n = 2048, i = Qo(new Uint8Array(16))) => {
  const a = await oE(i, t, n, e);
  return { encryptedKey: await $l(t.slice(-6), a, r), p2c: n, p2s: It(i) };
}, R2 = async (t, e, r, n, i) => {
  const a = await oE(i, t, n, e);
  return Hl(t.slice(-6), a, r);
};
function Ks(t) {
  switch (t) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new Fe(`alg ${t} is not supported either by JOSE or your javascript runtime`);
  }
}
const ec = (t, e) => {
  if (t.startsWith("RS") || t.startsWith("PS")) {
    const { modulusLength: r } = e.algorithm;
    if (typeof r != "number" || r < 2048)
      throw new TypeError(`${t} requires key modulusLength to be 2048 bits or larger`);
  }
}, N2 = async (t, e, r) => {
  if (!rr(e))
    throw new TypeError($t(e, ...st));
  if (bn(e, t, "encrypt", "wrapKey"), ec(t, e), e.usages.includes("encrypt"))
    return new Uint8Array(await Ne.subtle.encrypt(Ks(t), e, r));
  if (e.usages.includes("wrapKey")) {
    const n = await Ne.subtle.importKey("raw", r, ...Zo);
    return new Uint8Array(await Ne.subtle.wrapKey("raw", n, e, Ks(t)));
  }
  throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
}, x2 = async (t, e, r) => {
  if (!rr(e))
    throw new TypeError($t(e, ...st));
  if (bn(e, t, "decrypt", "unwrapKey"), ec(t, e), e.usages.includes("decrypt"))
    return new Uint8Array(await Ne.subtle.decrypt(Ks(t), e, r));
  if (e.usages.includes("unwrapKey")) {
    const n = await Ne.subtle.unwrapKey("raw", r, e, Ks(t), ...Zo);
    return new Uint8Array(await Ne.subtle.exportKey("raw", n));
  }
  throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
};
function od(t) {
  switch (t) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new Fe(`Unsupported JWE Algorithm: ${t}`);
  }
}
const Mn = (t) => Qo(new Uint8Array(od(t) >> 3)), cE = (t, e) => {
  const r = (t.match(/.{1,64}/g) || []).join(`
`);
  return `-----BEGIN ${e}-----
${r}
-----END ${e}-----`;
}, uE = async (t, e, r) => {
  if (!rr(r))
    throw new TypeError($t(r, ...st));
  if (!r.extractable)
    throw new TypeError("CryptoKey is not extractable");
  if (r.type !== t)
    throw new TypeError(`key is not a ${t} key`);
  return cE(id(new Uint8Array(await Ne.subtle.exportKey(e, r))), `${t.toUpperCase()} KEY`);
}, O2 = (t) => uE("public", "spki", t), D2 = (t) => uE("private", "pkcs8", t), vn = (t, e, r = 0) => {
  r === 0 && (e.unshift(e.length), e.unshift(6));
  let n = t.indexOf(e[0], r);
  if (n === -1)
    return !1;
  const i = t.subarray(n, n + e.length);
  return i.length !== e.length ? !1 : i.every((a, s) => a === e[s]) || vn(t, e, n + 1);
}, C0 = (t) => {
  switch (!0) {
    case vn(t, [42, 134, 72, 206, 61, 3, 1, 7]):
      return "P-256";
    case vn(t, [43, 129, 4, 0, 34]):
      return "P-384";
    case vn(t, [43, 129, 4, 0, 35]):
      return "P-521";
    case vn(t, [43, 101, 110]):
      return "X25519";
    case vn(t, [43, 101, 111]):
      return "X448";
    case vn(t, [43, 101, 112]):
      return "Ed25519";
    case vn(t, [43, 101, 113]):
      return "Ed448";
    default:
      throw new Fe("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
  }
}, lE = async (t, e, r, n, i) => {
  var a;
  let s, o;
  const l = new Uint8Array(atob(r.replace(t, "")).split("").map((f) => f.charCodeAt(0))), u = e === "spki";
  switch (n) {
    case "PS256":
    case "PS384":
    case "PS512":
      s = { name: "RSA-PSS", hash: `SHA-${n.slice(-3)}` }, o = u ? ["verify"] : ["sign"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      s = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${n.slice(-3)}` }, o = u ? ["verify"] : ["sign"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      s = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(n.slice(-3), 10) || 1}`
      }, o = u ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
      break;
    case "ES256":
      s = { name: "ECDSA", namedCurve: "P-256" }, o = u ? ["verify"] : ["sign"];
      break;
    case "ES384":
      s = { name: "ECDSA", namedCurve: "P-384" }, o = u ? ["verify"] : ["sign"];
      break;
    case "ES512":
      s = { name: "ECDSA", namedCurve: "P-521" }, o = u ? ["verify"] : ["sign"];
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      const f = C0(l);
      s = f.startsWith("P-") ? { name: "ECDH", namedCurve: f } : { name: f }, o = u ? [] : ["deriveBits"];
      break;
    }
    case "EdDSA":
      s = { name: C0(l) }, o = u ? ["verify"] : ["sign"];
      break;
    default:
      throw new Fe('Invalid or unsupported "alg" (Algorithm) value');
  }
  return Ne.subtle.importKey(e, l, s, (a = i == null ? void 0 : i.extractable) !== null && a !== void 0 ? a : !1, o);
}, L2 = (t, e, r) => lE(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", t, e, r), fE = (t, e, r) => lE(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", t, e, r);
function _0(t) {
  let e = [], r = 0;
  for (; r < t.length; ) {
    let n = dE(t.subarray(r));
    e.push(n), r += n.byteLength;
  }
  return e;
}
function dE(t) {
  let e = 0, r = t[0] & 31;
  if (e++, r === 31) {
    for (r = 0; t[e] >= 128; )
      r = r * 128 + t[e] - 128, e++;
    r = r * 128 + t[e] - 128, e++;
  }
  let n = 0;
  if (t[e] < 128)
    n = t[e], e++;
  else if (n === 128) {
    for (n = 0; t[e + n] !== 0 || t[e + n + 1] !== 0; ) {
      if (n > t.byteLength)
        throw new TypeError("invalid indefinite form length");
      n++;
    }
    const a = e + n + 2;
    return {
      byteLength: a,
      contents: t.subarray(e, e + n),
      raw: t.subarray(0, a)
    };
  } else {
    let a = t[e] & 127;
    e++, n = 0;
    for (let s = 0; s < a; s++)
      n = n * 256 + t[e], e++;
  }
  const i = e + n;
  return {
    byteLength: i,
    contents: t.subarray(e, i),
    raw: t.subarray(0, i)
  };
}
function P2(t) {
  const e = _0(_0(dE(t).contents)[0].contents);
  return id(e[e[0].raw[0] === 160 ? 6 : 5].raw);
}
function k2(t) {
  const e = t.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, ""), r = jm(e);
  return cE(P2(r), "PUBLIC KEY");
}
const B2 = (t, e, r) => {
  let n;
  try {
    n = k2(t);
  } catch (i) {
    throw new TypeError("Failed to parse the X.509 certificate", { cause: i });
  }
  return fE(n, e, r);
};
function U2(t) {
  let e, r;
  switch (t.kty) {
    case "oct": {
      switch (t.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          e = { name: "HMAC", hash: `SHA-${t.alg.slice(-3)}` }, r = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new Fe(`${t.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          e = { name: "AES-GCM" }, r = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          e = { name: "AES-KW" }, r = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          e = { name: "PBKDF2" }, r = ["deriveBits"];
          break;
        default:
          throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (t.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          e = { name: "RSA-PSS", hash: `SHA-${t.alg.slice(-3)}` }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          e = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${t.alg.slice(-3)}` }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          e = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(t.alg.slice(-3), 10) || 1}`
          }, r = t.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (t.alg) {
        case "ES256":
          e = { name: "ECDSA", namedCurve: "P-256" }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          e = { name: "ECDSA", namedCurve: "P-384" }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          e = { name: "ECDSA", namedCurve: "P-521" }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          e = { name: "ECDH", namedCurve: t.crv }, r = t.d ? ["deriveBits"] : [];
          break;
        default:
          throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (t.alg) {
        case "EdDSA":
          e = { name: t.crv }, r = t.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          e = { name: t.crv }, r = t.d ? ["deriveBits"] : [];
          break;
        default:
          throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new Fe('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm: e, keyUsages: r };
}
const S0 = async (t) => {
  var e, r;
  if (!t.alg)
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  const { algorithm: n, keyUsages: i } = U2(t), a = [
    n,
    (e = t.ext) !== null && e !== void 0 ? e : !1,
    (r = t.key_ops) !== null && r !== void 0 ? r : i
  ];
  if (n.name === "PBKDF2")
    return Ne.subtle.importKey("raw", wt(t.k), ...a);
  const s = { ...t };
  return delete s.alg, delete s.use, Ne.subtle.importKey("jwk", s, ...a);
};
async function F2(t, e, r) {
  if (typeof t != "string" || t.indexOf("-----BEGIN PUBLIC KEY-----") !== 0)
    throw new TypeError('"spki" must be SPKI formatted string');
  return fE(t, e, r);
}
async function M2(t, e, r) {
  if (typeof t != "string" || t.indexOf("-----BEGIN CERTIFICATE-----") !== 0)
    throw new TypeError('"x509" must be X.509 formatted string');
  return B2(t, e, r);
}
async function V2(t, e, r) {
  if (typeof t != "string" || t.indexOf("-----BEGIN PRIVATE KEY-----") !== 0)
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  return L2(t, e, r);
}
async function tc(t, e, r) {
  var n;
  if (!Rt(t))
    throw new TypeError("JWK must be an object");
  switch (e || (e = t.alg), t.kty) {
    case "oct":
      if (typeof t.k != "string" || !t.k)
        throw new TypeError('missing "k" (Key Value) Parameter value');
      return r ?? (r = t.ext !== !0), r ? S0({ ...t, alg: e, ext: (n = t.ext) !== null && n !== void 0 ? n : !1 }) : wt(t.k);
    case "RSA":
      if (t.oth !== void 0)
        throw new Fe('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
    case "EC":
    case "OKP":
      return S0({ ...t, alg: e });
    default:
      throw new Fe('Unsupported "kty" (Key Type) Parameter value');
  }
}
const $2 = (t, e) => {
  if (!(e instanceof Uint8Array)) {
    if (!tE(e))
      throw new TypeError(eE(t, e, ...st, "Uint8Array"));
    if (e.type !== "secret")
      throw new TypeError(`${st.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
}, H2 = (t, e, r) => {
  if (!tE(e))
    throw new TypeError(eE(t, e, ...st));
  if (e.type === "secret")
    throw new TypeError(`${st.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  if (r === "sign" && e.type === "public")
    throw new TypeError(`${st.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  if (r === "decrypt" && e.type === "public")
    throw new TypeError(`${st.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  if (e.algorithm && r === "verify" && e.type === "private")
    throw new TypeError(`${st.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  if (e.algorithm && r === "encrypt" && e.type === "private")
    throw new TypeError(`${st.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
}, rc = (t, e, r) => {
  t.startsWith("HS") || t === "dir" || t.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(t) ? $2(t, e) : H2(t, e, r);
};
async function K2(t, e, r, n, i) {
  if (!(r instanceof Uint8Array))
    throw new TypeError($t(r, "Uint8Array"));
  const a = parseInt(t.slice(1, 4), 10), s = await Ne.subtle.importKey("raw", r.subarray(a >> 3), "AES-CBC", !1, ["encrypt"]), o = await Ne.subtle.importKey("raw", r.subarray(0, a >> 3), {
    hash: `SHA-${a << 1}`,
    name: "HMAC"
  }, !1, ["sign"]), l = new Uint8Array(await Ne.subtle.encrypt({
    iv: n,
    name: "AES-CBC"
  }, s, e)), u = zr(i, n, l, Gm(i.length << 3)), f = new Uint8Array((await Ne.subtle.sign("HMAC", o, u)).slice(0, a >> 3));
  return { ciphertext: l, tag: f };
}
async function G2(t, e, r, n, i) {
  let a;
  r instanceof Uint8Array ? a = await Ne.subtle.importKey("raw", r, "AES-GCM", !1, ["encrypt"]) : (bn(r, t, "encrypt"), a = r);
  const s = new Uint8Array(await Ne.subtle.encrypt({
    additionalData: i,
    iv: n,
    name: "AES-GCM",
    tagLength: 128
  }, a, e)), o = s.slice(-16);
  return { ciphertext: s.slice(0, -16), tag: o };
}
const Kl = async (t, e, r, n, i) => {
  if (!rr(r) && !(r instanceof Uint8Array))
    throw new TypeError($t(r, ...st, "Uint8Array"));
  switch (Ym(t, n), t) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return r instanceof Uint8Array && Hs(r, parseInt(t.slice(-3), 10)), K2(t, e, r, n, i);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      return r instanceof Uint8Array && Hs(r, parseInt(t.slice(1, 4), 10)), G2(t, e, r, n, i);
    default:
      throw new Fe("Unsupported JWE Content Encryption Algorithm");
  }
};
async function j2(t, e, r, n) {
  const i = t.slice(0, 7);
  n || (n = Xm(i));
  const { ciphertext: a, tag: s } = await Kl(i, r, e, n, new Uint8Array(0));
  return { encryptedKey: a, iv: It(n), tag: It(s) };
}
async function q2(t, e, r, n, i) {
  const a = t.slice(0, 7);
  return rE(a, e, r, n, i, new Uint8Array(0));
}
async function W2(t, e, r, n, i) {
  switch (rc(t, e, "decrypt"), t) {
    case "dir": {
      if (r !== void 0)
        throw new Ie("Encountered unexpected JWE Encrypted Key");
      return e;
    }
    case "ECDH-ES":
      if (r !== void 0)
        throw new Ie("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!Rt(n.epk))
        throw new Ie('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');
      if (!sE(e))
        throw new Fe("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const a = await tc(n.epk, t);
      let s, o;
      if (n.apu !== void 0) {
        if (typeof n.apu != "string")
          throw new Ie('JOSE Header "apu" (Agreement PartyUInfo) invalid');
        try {
          s = wt(n.apu);
        } catch {
          throw new Ie("Failed to base64url decode the apu");
        }
      }
      if (n.apv !== void 0) {
        if (typeof n.apv != "string")
          throw new Ie('JOSE Header "apv" (Agreement PartyVInfo) invalid');
        try {
          o = wt(n.apv);
        } catch {
          throw new Ie("Failed to base64url decode the apv");
        }
      }
      const l = await aE(a, e, t === "ECDH-ES" ? n.enc : t, t === "ECDH-ES" ? od(n.enc) : parseInt(t.slice(-5, -2), 10), s, o);
      if (t === "ECDH-ES")
        return l;
      if (r === void 0)
        throw new Ie("JWE Encrypted Key missing");
      return Hl(t.slice(-6), l, r);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (r === void 0)
        throw new Ie("JWE Encrypted Key missing");
      return x2(t, e, r);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (r === void 0)
        throw new Ie("JWE Encrypted Key missing");
      if (typeof n.p2c != "number")
        throw new Ie('JOSE Header "p2c" (PBES2 Count) missing or invalid');
      const a = (i == null ? void 0 : i.maxPBES2Count) || 1e4;
      if (n.p2c > a)
        throw new Ie('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');
      if (typeof n.p2s != "string")
        throw new Ie('JOSE Header "p2s" (PBES2 Salt) missing or invalid');
      let s;
      try {
        s = wt(n.p2s);
      } catch {
        throw new Ie("Failed to base64url decode the p2s");
      }
      return R2(t, e, r, n.p2c, s);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (r === void 0)
        throw new Ie("JWE Encrypted Key missing");
      return Hl(t, e, r);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (r === void 0)
        throw new Ie("JWE Encrypted Key missing");
      if (typeof n.iv != "string")
        throw new Ie('JOSE Header "iv" (Initialization Vector) missing or invalid');
      if (typeof n.tag != "string")
        throw new Ie('JOSE Header "tag" (Authentication Tag) missing or invalid');
      let a;
      try {
        a = wt(n.iv);
      } catch {
        throw new Ie("Failed to base64url decode the iv");
      }
      let s;
      try {
        s = wt(n.tag);
      } catch {
        throw new Ie("Failed to base64url decode the tag");
      }
      return q2(t, e, r, a, s);
    }
    default:
      throw new Fe('Invalid or unsupported "alg" (JWE Algorithm) header value');
  }
}
function Va(t, e, r, n, i) {
  if (i.crit !== void 0 && n.crit === void 0)
    throw new t('"crit" (Critical) Header Parameter MUST be integrity protected');
  if (!n || n.crit === void 0)
    return /* @__PURE__ */ new Set();
  if (!Array.isArray(n.crit) || n.crit.length === 0 || n.crit.some((s) => typeof s != "string" || s.length === 0))
    throw new t('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  let a;
  r !== void 0 ? a = new Map([...Object.entries(r), ...e.entries()]) : a = e;
  for (const s of n.crit) {
    if (!a.has(s))
      throw new Fe(`Extension Header Parameter "${s}" is not recognized`);
    if (i[s] === void 0)
      throw new t(`Extension Header Parameter "${s}" is missing`);
    if (a.get(s) && n[s] === void 0)
      throw new t(`Extension Header Parameter "${s}" MUST be integrity protected`);
  }
  return new Set(n.crit);
}
const Gl = (t, e) => {
  if (e !== void 0 && (!Array.isArray(e) || e.some((r) => typeof r != "string")))
    throw new TypeError(`"${t}" option must be an array of strings`);
  if (e)
    return new Set(e);
};
async function cd(t, e, r) {
  var n;
  if (!Rt(t))
    throw new Ie("Flattened JWE must be an object");
  if (t.protected === void 0 && t.header === void 0 && t.unprotected === void 0)
    throw new Ie("JOSE Header missing");
  if (typeof t.iv != "string")
    throw new Ie("JWE Initialization Vector missing or incorrect type");
  if (typeof t.ciphertext != "string")
    throw new Ie("JWE Ciphertext missing or incorrect type");
  if (typeof t.tag != "string")
    throw new Ie("JWE Authentication Tag missing or incorrect type");
  if (t.protected !== void 0 && typeof t.protected != "string")
    throw new Ie("JWE Protected Header incorrect type");
  if (t.encrypted_key !== void 0 && typeof t.encrypted_key != "string")
    throw new Ie("JWE Encrypted Key incorrect type");
  if (t.aad !== void 0 && typeof t.aad != "string")
    throw new Ie("JWE AAD incorrect type");
  if (t.header !== void 0 && !Rt(t.header))
    throw new Ie("JWE Shared Unprotected Header incorrect type");
  if (t.unprotected !== void 0 && !Rt(t.unprotected))
    throw new Ie("JWE Per-Recipient Unprotected Header incorrect type");
  let i;
  if (t.protected)
    try {
      const R = wt(t.protected);
      i = JSON.parse(mr.decode(R));
    } catch {
      throw new Ie("JWE Protected Header is invalid");
    }
  if (!Ma(i, t.header, t.unprotected))
    throw new Ie("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  const a = {
    ...i,
    ...t.header,
    ...t.unprotected
  };
  if (Va(Ie, /* @__PURE__ */ new Map(), r == null ? void 0 : r.crit, i, a), a.zip !== void 0) {
    if (!i || !i.zip)
      throw new Ie('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    if (a.zip !== "DEF")
      throw new Fe('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
  }
  const { alg: s, enc: o } = a;
  if (typeof s != "string" || !s)
    throw new Ie("missing JWE Algorithm (alg) in JWE Header");
  if (typeof o != "string" || !o)
    throw new Ie("missing JWE Encryption Algorithm (enc) in JWE Header");
  const l = r && Gl("keyManagementAlgorithms", r.keyManagementAlgorithms), u = r && Gl("contentEncryptionAlgorithms", r.contentEncryptionAlgorithms);
  if (l && !l.has(s))
    throw new $s('"alg" (Algorithm) Header Parameter not allowed');
  if (u && !u.has(o))
    throw new $s('"enc" (Encryption Algorithm) Header Parameter not allowed');
  let f;
  if (t.encrypted_key !== void 0)
    try {
      f = wt(t.encrypted_key);
    } catch {
      throw new Ie("Failed to base64url decode the encrypted_key");
    }
  let y = !1;
  typeof e == "function" && (e = await e(i, t), y = !0);
  let m;
  try {
    m = await W2(s, e, f, a, r);
  } catch (R) {
    if (R instanceof TypeError || R instanceof Ie || R instanceof Fe)
      throw R;
    m = Mn(o);
  }
  let p, S;
  try {
    p = wt(t.iv);
  } catch {
    throw new Ie("Failed to base64url decode the iv");
  }
  try {
    S = wt(t.tag);
  } catch {
    throw new Ie("Failed to base64url decode the tag");
  }
  const A = dt.encode((n = t.protected) !== null && n !== void 0 ? n : "");
  let I;
  t.aad !== void 0 ? I = zr(A, dt.encode("."), dt.encode(t.aad)) : I = A;
  let c;
  try {
    c = wt(t.ciphertext);
  } catch {
    throw new Ie("Failed to base64url decode the ciphertext");
  }
  let E = await rE(o, m, c, p, S, I);
  a.zip === "DEF" && (E = await ((r == null ? void 0 : r.inflateRaw) || C2)(E));
  const v = { plaintext: E };
  if (t.protected !== void 0 && (v.protectedHeader = i), t.aad !== void 0)
    try {
      v.additionalAuthenticatedData = wt(t.aad);
    } catch {
      throw new Ie("Failed to base64url decode the aad");
    }
  return t.unprotected !== void 0 && (v.sharedUnprotectedHeader = t.unprotected), t.header !== void 0 && (v.unprotectedHeader = t.header), y ? { ...v, key: e } : v;
}
async function hE(t, e, r) {
  if (t instanceof Uint8Array && (t = mr.decode(t)), typeof t != "string")
    throw new Ie("Compact JWE must be a string or Uint8Array");
  const { 0: n, 1: i, 2: a, 3: s, 4: o, length: l } = t.split(".");
  if (l !== 5)
    throw new Ie("Invalid Compact JWE");
  const u = await cd({
    ciphertext: s,
    iv: a || void 0,
    protected: n || void 0,
    tag: o || void 0,
    encrypted_key: i || void 0
  }, e, r), f = { plaintext: u.plaintext, protectedHeader: u.protectedHeader };
  return typeof e == "function" ? { ...f, key: u.key } : f;
}
async function J2(t, e, r) {
  if (!Rt(t))
    throw new Ie("General JWE must be an object");
  if (!Array.isArray(t.recipients) || !t.recipients.every(Rt))
    throw new Ie("JWE Recipients missing or incorrect type");
  if (!t.recipients.length)
    throw new Ie("JWE Recipients has no members");
  for (const n of t.recipients)
    try {
      return await cd({
        aad: t.aad,
        ciphertext: t.ciphertext,
        encrypted_key: n.encrypted_key,
        header: n.header,
        iv: t.iv,
        protected: t.protected,
        tag: t.tag,
        unprotected: t.unprotected
      }, e, r);
    } catch {
    }
  throw new pa();
}
const z2 = async (t) => {
  if (t instanceof Uint8Array)
    return {
      kty: "oct",
      k: It(t)
    };
  if (!rr(t))
    throw new TypeError($t(t, ...st, "Uint8Array"));
  if (!t.extractable)
    throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
  const { ext: e, key_ops: r, alg: n, use: i, ...a } = await Ne.subtle.exportKey("jwk", t);
  return a;
};
async function X2(t) {
  return O2(t);
}
async function Y2(t) {
  return D2(t);
}
async function pE(t) {
  return z2(t);
}
async function gE(t, e, r, n, i = {}) {
  let a, s, o;
  switch (rc(t, r, "encrypt"), t) {
    case "dir": {
      o = r;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!sE(r))
        throw new Fe("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const { apu: l, apv: u } = i;
      let { epk: f } = i;
      f || (f = (await I2(r)).privateKey);
      const { x: y, y: m, crv: p, kty: S } = await pE(f), A = await aE(r, f, t === "ECDH-ES" ? e : t, t === "ECDH-ES" ? od(e) : parseInt(t.slice(-5, -2), 10), l, u);
      if (s = { epk: { x: y, crv: p, kty: S } }, S === "EC" && (s.epk.y = m), l && (s.apu = It(l)), u && (s.apv = It(u)), t === "ECDH-ES") {
        o = A;
        break;
      }
      o = n || Mn(e);
      const I = t.slice(-6);
      a = await $l(I, A, o);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      o = n || Mn(e), a = await N2(t, r, o);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      o = n || Mn(e);
      const { p2c: l, p2s: u } = i;
      ({ encryptedKey: a, ...s } = await T2(t, r, o, l, u));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      o = n || Mn(e), a = await $l(t, r, o);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      o = n || Mn(e);
      const { iv: l } = i;
      ({ encryptedKey: a, ...s } = await j2(t, r, o, l));
      break;
    }
    default:
      throw new Fe('Invalid or unsupported "alg" (JWE Algorithm) header value');
  }
  return { cek: o, encryptedKey: a, parameters: s };
}
const yE = Symbol();
class Gs {
  constructor(e) {
    if (!(e instanceof Uint8Array))
      throw new TypeError("plaintext must be an instance of Uint8Array");
    this._plaintext = e;
  }
  setKeyManagementParameters(e) {
    if (this._keyManagementParameters)
      throw new TypeError("setKeyManagementParameters can only be called once");
    return this._keyManagementParameters = e, this;
  }
  setProtectedHeader(e) {
    if (this._protectedHeader)
      throw new TypeError("setProtectedHeader can only be called once");
    return this._protectedHeader = e, this;
  }
  setSharedUnprotectedHeader(e) {
    if (this._sharedUnprotectedHeader)
      throw new TypeError("setSharedUnprotectedHeader can only be called once");
    return this._sharedUnprotectedHeader = e, this;
  }
  setUnprotectedHeader(e) {
    if (this._unprotectedHeader)
      throw new TypeError("setUnprotectedHeader can only be called once");
    return this._unprotectedHeader = e, this;
  }
  setAdditionalAuthenticatedData(e) {
    return this._aad = e, this;
  }
  setContentEncryptionKey(e) {
    if (this._cek)
      throw new TypeError("setContentEncryptionKey can only be called once");
    return this._cek = e, this;
  }
  setInitializationVector(e) {
    if (this._iv)
      throw new TypeError("setInitializationVector can only be called once");
    return this._iv = e, this;
  }
  async encrypt(e, r) {
    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader)
      throw new Ie("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
    if (!Ma(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader))
      throw new Ie("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
    const n = {
      ...this._protectedHeader,
      ...this._unprotectedHeader,
      ...this._sharedUnprotectedHeader
    };
    if (Va(Ie, /* @__PURE__ */ new Map(), r == null ? void 0 : r.crit, this._protectedHeader, n), n.zip !== void 0) {
      if (!this._protectedHeader || !this._protectedHeader.zip)
        throw new Ie('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
      if (n.zip !== "DEF")
        throw new Fe('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
    const { alg: i, enc: a } = n;
    if (typeof i != "string" || !i)
      throw new Ie('JWE "alg" (Algorithm) Header Parameter missing or invalid');
    if (typeof a != "string" || !a)
      throw new Ie('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
    let s;
    if (i === "dir") {
      if (this._cek)
        throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
    } else if (i === "ECDH-ES" && this._cek)
      throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
    let o;
    {
      let S;
      ({ cek: o, encryptedKey: s, parameters: S } = await gE(i, a, e, this._cek, this._keyManagementParameters)), S && (r && yE in r ? this._unprotectedHeader ? this._unprotectedHeader = { ...this._unprotectedHeader, ...S } : this.setUnprotectedHeader(S) : this._protectedHeader ? this._protectedHeader = { ...this._protectedHeader, ...S } : this.setProtectedHeader(S));
    }
    this._iv || (this._iv = Xm(a));
    let l, u, f;
    this._protectedHeader ? u = dt.encode(It(JSON.stringify(this._protectedHeader))) : u = dt.encode(""), this._aad ? (f = It(this._aad), l = zr(u, dt.encode("."), dt.encode(f))) : l = u;
    let y, m;
    if (n.zip === "DEF") {
      const S = await ((r == null ? void 0 : r.deflateRaw) || _2)(this._plaintext);
      ({ ciphertext: y, tag: m } = await Kl(a, S, o, this._iv, l));
    } else
      ({ ciphertext: y, tag: m } = await Kl(a, this._plaintext, o, this._iv, l));
    const p = {
      ciphertext: It(y),
      iv: It(this._iv),
      tag: It(m)
    };
    return s && (p.encrypted_key = It(s)), f && (p.aad = f), this._protectedHeader && (p.protected = mr.decode(u)), this._sharedUnprotectedHeader && (p.unprotected = this._sharedUnprotectedHeader), this._unprotectedHeader && (p.header = this._unprotectedHeader), p;
  }
}
class Q2 {
  constructor(e, r, n) {
    this.parent = e, this.key = r, this.options = n;
  }
  setUnprotectedHeader(e) {
    if (this.unprotectedHeader)
      throw new TypeError("setUnprotectedHeader can only be called once");
    return this.unprotectedHeader = e, this;
  }
  addRecipient(...e) {
    return this.parent.addRecipient(...e);
  }
  encrypt(...e) {
    return this.parent.encrypt(...e);
  }
  done() {
    return this.parent;
  }
}
class Z2 {
  constructor(e) {
    this._recipients = [], this._plaintext = e;
  }
  addRecipient(e, r) {
    const n = new Q2(this, e, { crit: r == null ? void 0 : r.crit });
    return this._recipients.push(n), n;
  }
  setProtectedHeader(e) {
    if (this._protectedHeader)
      throw new TypeError("setProtectedHeader can only be called once");
    return this._protectedHeader = e, this;
  }
  setSharedUnprotectedHeader(e) {
    if (this._unprotectedHeader)
      throw new TypeError("setSharedUnprotectedHeader can only be called once");
    return this._unprotectedHeader = e, this;
  }
  setAdditionalAuthenticatedData(e) {
    return this._aad = e, this;
  }
  async encrypt(e) {
    var r, n, i;
    if (!this._recipients.length)
      throw new Ie("at least one recipient must be added");
    if (e = { deflateRaw: e == null ? void 0 : e.deflateRaw }, this._recipients.length === 1) {
      const [l] = this._recipients, u = await new Gs(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(l.unprotectedHeader).encrypt(l.key, { ...l.options, ...e });
      let f = {
        ciphertext: u.ciphertext,
        iv: u.iv,
        recipients: [{}],
        tag: u.tag
      };
      return u.aad && (f.aad = u.aad), u.protected && (f.protected = u.protected), u.unprotected && (f.unprotected = u.unprotected), u.encrypted_key && (f.recipients[0].encrypted_key = u.encrypted_key), u.header && (f.recipients[0].header = u.header), f;
    }
    let a;
    for (let l = 0; l < this._recipients.length; l++) {
      const u = this._recipients[l];
      if (!Ma(this._protectedHeader, this._unprotectedHeader, u.unprotectedHeader))
        throw new Ie("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
      const f = {
        ...this._protectedHeader,
        ...this._unprotectedHeader,
        ...u.unprotectedHeader
      }, { alg: y } = f;
      if (typeof y != "string" || !y)
        throw new Ie('JWE "alg" (Algorithm) Header Parameter missing or invalid');
      if (y === "dir" || y === "ECDH-ES")
        throw new Ie('"dir" and "ECDH-ES" alg may only be used with a single recipient');
      if (typeof f.enc != "string" || !f.enc)
        throw new Ie('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
      if (!a)
        a = f.enc;
      else if (a !== f.enc)
        throw new Ie('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
      if (Va(Ie, /* @__PURE__ */ new Map(), u.options.crit, this._protectedHeader, f), f.zip !== void 0 && (!this._protectedHeader || !this._protectedHeader.zip))
        throw new Ie('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    const s = Mn(a);
    let o = {
      ciphertext: "",
      iv: "",
      recipients: [],
      tag: ""
    };
    for (let l = 0; l < this._recipients.length; l++) {
      const u = this._recipients[l], f = {};
      o.recipients.push(f);
      const m = {
        ...this._protectedHeader,
        ...this._unprotectedHeader,
        ...u.unprotectedHeader
      }.alg.startsWith("PBES2") ? 2048 + l : void 0;
      if (l === 0) {
        const A = await new Gs(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(s).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(u.unprotectedHeader).setKeyManagementParameters({ p2c: m }).encrypt(u.key, {
          ...u.options,
          ...e,
          [yE]: !0
        });
        o.ciphertext = A.ciphertext, o.iv = A.iv, o.tag = A.tag, A.aad && (o.aad = A.aad), A.protected && (o.protected = A.protected), A.unprotected && (o.unprotected = A.unprotected), f.encrypted_key = A.encrypted_key, A.header && (f.header = A.header);
        continue;
      }
      const { encryptedKey: p, parameters: S } = await gE(((r = u.unprotectedHeader) === null || r === void 0 ? void 0 : r.alg) || ((n = this._protectedHeader) === null || n === void 0 ? void 0 : n.alg) || ((i = this._unprotectedHeader) === null || i === void 0 ? void 0 : i.alg), a, u.key, s, { p2c: m });
      f.encrypted_key = It(p), (u.unprotectedHeader || S) && (f.header = { ...u.unprotectedHeader, ...S });
    }
    return o;
  }
}
function mE(t, e) {
  const r = `SHA-${t.slice(-3)}`;
  switch (t) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: r, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: r, name: "RSA-PSS", saltLength: t.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: r, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: r, name: "ECDSA", namedCurve: e.namedCurve };
    case "EdDSA":
      return { name: e.name };
    default:
      throw new Fe(`alg ${t} is not supported either by JOSE or your javascript runtime`);
  }
}
function EE(t, e, r) {
  if (rr(e))
    return E2(e, t, r), e;
  if (e instanceof Uint8Array) {
    if (!t.startsWith("HS"))
      throw new TypeError($t(e, ...st));
    return Ne.subtle.importKey("raw", e, { hash: `SHA-${t.slice(-3)}`, name: "HMAC" }, !1, [r]);
  }
  throw new TypeError($t(e, ...st, "Uint8Array"));
}
const eO = async (t, e, r, n) => {
  const i = await EE(t, e, "verify");
  ec(t, i);
  const a = mE(t, i.algorithm);
  try {
    return await Ne.subtle.verify(a, i, r, n);
  } catch {
    return !1;
  }
};
async function ud(t, e, r) {
  var n;
  if (!Rt(t))
    throw new Ge("Flattened JWS must be an object");
  if (t.protected === void 0 && t.header === void 0)
    throw new Ge('Flattened JWS must have either of the "protected" or "header" members');
  if (t.protected !== void 0 && typeof t.protected != "string")
    throw new Ge("JWS Protected Header incorrect type");
  if (t.payload === void 0)
    throw new Ge("JWS Payload missing");
  if (typeof t.signature != "string")
    throw new Ge("JWS Signature missing or incorrect type");
  if (t.header !== void 0 && !Rt(t.header))
    throw new Ge("JWS Unprotected Header incorrect type");
  let i = {};
  if (t.protected)
    try {
      const I = wt(t.protected);
      i = JSON.parse(mr.decode(I));
    } catch {
      throw new Ge("JWS Protected Header is invalid");
    }
  if (!Ma(i, t.header))
    throw new Ge("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  const a = {
    ...i,
    ...t.header
  }, s = Va(Ge, /* @__PURE__ */ new Map([["b64", !0]]), r == null ? void 0 : r.crit, i, a);
  let o = !0;
  if (s.has("b64") && (o = i.b64, typeof o != "boolean"))
    throw new Ge('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
  const { alg: l } = a;
  if (typeof l != "string" || !l)
    throw new Ge('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  const u = r && Gl("algorithms", r.algorithms);
  if (u && !u.has(l))
    throw new $s('"alg" (Algorithm) Header Parameter not allowed');
  if (o) {
    if (typeof t.payload != "string")
      throw new Ge("JWS Payload must be a string");
  } else if (typeof t.payload != "string" && !(t.payload instanceof Uint8Array))
    throw new Ge("JWS Payload must be a string or an Uint8Array instance");
  let f = !1;
  typeof e == "function" && (e = await e(i, t), f = !0), rc(l, e, "verify");
  const y = zr(dt.encode((n = t.protected) !== null && n !== void 0 ? n : ""), dt.encode("."), typeof t.payload == "string" ? dt.encode(t.payload) : t.payload);
  let m;
  try {
    m = wt(t.signature);
  } catch {
    throw new Ge("Failed to base64url decode the signature");
  }
  if (!await eO(l, e, m, y))
    throw new sd();
  let S;
  if (o)
    try {
      S = wt(t.payload);
    } catch {
      throw new Ge("Failed to base64url decode the payload");
    }
  else typeof t.payload == "string" ? S = dt.encode(t.payload) : S = t.payload;
  const A = { payload: S };
  return t.protected !== void 0 && (A.protectedHeader = i), t.header !== void 0 && (A.unprotectedHeader = t.header), f ? { ...A, key: e } : A;
}
async function vE(t, e, r) {
  if (t instanceof Uint8Array && (t = mr.decode(t)), typeof t != "string")
    throw new Ge("Compact JWS must be a string or Uint8Array");
  const { 0: n, 1: i, 2: a, length: s } = t.split(".");
  if (s !== 3)
    throw new Ge("Invalid Compact JWS");
  const o = await ud({ payload: i, protected: n, signature: a }, e, r), l = { payload: o.payload, protectedHeader: o.protectedHeader };
  return typeof e == "function" ? { ...l, key: o.key } : l;
}
async function tO(t, e, r) {
  if (!Rt(t))
    throw new Ge("General JWS must be an object");
  if (!Array.isArray(t.signatures) || !t.signatures.every(Rt))
    throw new Ge("JWS Signatures missing or incorrect type");
  for (const n of t.signatures)
    try {
      return await ud({
        header: n.header,
        payload: t.payload,
        protected: n.protected,
        signature: n.signature
      }, e, r);
    } catch {
    }
  throw new sd();
}
const _s = (t) => Math.floor(t.getTime() / 1e3), AE = 60, CE = AE * 60, ld = CE * 24, rO = ld * 7, nO = ld * 365.25, iO = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i, js = (t) => {
  const e = iO.exec(t);
  if (!e)
    throw new TypeError("Invalid time period format");
  const r = parseFloat(e[1]);
  switch (e[2].toLowerCase()) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(r);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(r * AE);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(r * CE);
    case "day":
    case "days":
    case "d":
      return Math.round(r * ld);
    case "week":
    case "weeks":
    case "w":
      return Math.round(r * rO);
    default:
      return Math.round(r * nO);
  }
}, I0 = (t) => t.toLowerCase().replace(/^application\//, ""), aO = (t, e) => typeof t == "string" ? e.includes(t) : Array.isArray(t) ? e.some(Set.prototype.has.bind(new Set(t))) : !1, fd = (t, e, r = {}) => {
  const { typ: n } = r;
  if (n && (typeof t.typ != "string" || I0(t.typ) !== I0(n)))
    throw new Zt('unexpected "typ" JWT header value', "typ", "check_failed");
  let i;
  try {
    i = JSON.parse(mr.decode(e));
  } catch {
  }
  if (!Rt(i))
    throw new er("JWT Claims Set must be a top-level JSON object");
  const { requiredClaims: a = [], issuer: s, subject: o, audience: l, maxTokenAge: u } = r;
  u !== void 0 && a.push("iat"), l !== void 0 && a.push("aud"), o !== void 0 && a.push("sub"), s !== void 0 && a.push("iss");
  for (const p of new Set(a.reverse()))
    if (!(p in i))
      throw new Zt(`missing required "${p}" claim`, p, "missing");
  if (s && !(Array.isArray(s) ? s : [s]).includes(i.iss))
    throw new Zt('unexpected "iss" claim value', "iss", "check_failed");
  if (o && i.sub !== o)
    throw new Zt('unexpected "sub" claim value', "sub", "check_failed");
  if (l && !aO(i.aud, typeof l == "string" ? [l] : l))
    throw new Zt('unexpected "aud" claim value', "aud", "check_failed");
  let f;
  switch (typeof r.clockTolerance) {
    case "string":
      f = js(r.clockTolerance);
      break;
    case "number":
      f = r.clockTolerance;
      break;
    case "undefined":
      f = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate: y } = r, m = _s(y || /* @__PURE__ */ new Date());
  if ((i.iat !== void 0 || u) && typeof i.iat != "number")
    throw new Zt('"iat" claim must be a number', "iat", "invalid");
  if (i.nbf !== void 0) {
    if (typeof i.nbf != "number")
      throw new Zt('"nbf" claim must be a number', "nbf", "invalid");
    if (i.nbf > m + f)
      throw new Zt('"nbf" claim timestamp check failed', "nbf", "check_failed");
  }
  if (i.exp !== void 0) {
    if (typeof i.exp != "number")
      throw new Zt('"exp" claim must be a number', "exp", "invalid");
    if (i.exp <= m - f)
      throw new Vl('"exp" claim timestamp check failed', "exp", "check_failed");
  }
  if (u) {
    const p = m - i.iat, S = typeof u == "number" ? u : js(u);
    if (p - f > S)
      throw new Vl('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    if (p < 0 - f)
      throw new Zt('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
  }
  return i;
};
async function sO(t, e, r) {
  var n;
  const i = await vE(t, e, r);
  if (!((n = i.protectedHeader.crit) === null || n === void 0) && n.includes("b64") && i.protectedHeader.b64 === !1)
    throw new er("JWTs MUST NOT use unencoded payload");
  const s = { payload: fd(i.protectedHeader, i.payload, r), protectedHeader: i.protectedHeader };
  return typeof e == "function" ? { ...s, key: i.key } : s;
}
async function oO(t, e, r) {
  const n = await hE(t, e, r), i = fd(n.protectedHeader, n.plaintext, r), { protectedHeader: a } = n;
  if (a.iss !== void 0 && a.iss !== i.iss)
    throw new Zt('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  if (a.sub !== void 0 && a.sub !== i.sub)
    throw new Zt('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  if (a.aud !== void 0 && JSON.stringify(a.aud) !== JSON.stringify(i.aud))
    throw new Zt('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  const s = { payload: i, protectedHeader: a };
  return typeof e == "function" ? { ...s, key: n.key } : s;
}
class _E {
  constructor(e) {
    this._flattened = new Gs(e);
  }
  setContentEncryptionKey(e) {
    return this._flattened.setContentEncryptionKey(e), this;
  }
  setInitializationVector(e) {
    return this._flattened.setInitializationVector(e), this;
  }
  setProtectedHeader(e) {
    return this._flattened.setProtectedHeader(e), this;
  }
  setKeyManagementParameters(e) {
    return this._flattened.setKeyManagementParameters(e), this;
  }
  async encrypt(e, r) {
    const n = await this._flattened.encrypt(e, r);
    return [n.protected, n.encrypted_key, n.iv, n.ciphertext, n.tag].join(".");
  }
}
const cO = async (t, e, r) => {
  const n = await EE(t, e, "sign");
  ec(t, n);
  const i = await Ne.subtle.sign(mE(t, n.algorithm), n, r);
  return new Uint8Array(i);
};
class dd {
  constructor(e) {
    if (!(e instanceof Uint8Array))
      throw new TypeError("payload must be an instance of Uint8Array");
    this._payload = e;
  }
  setProtectedHeader(e) {
    if (this._protectedHeader)
      throw new TypeError("setProtectedHeader can only be called once");
    return this._protectedHeader = e, this;
  }
  setUnprotectedHeader(e) {
    if (this._unprotectedHeader)
      throw new TypeError("setUnprotectedHeader can only be called once");
    return this._unprotectedHeader = e, this;
  }
  async sign(e, r) {
    if (!this._protectedHeader && !this._unprotectedHeader)
      throw new Ge("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    if (!Ma(this._protectedHeader, this._unprotectedHeader))
      throw new Ge("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    const n = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    }, i = Va(Ge, /* @__PURE__ */ new Map([["b64", !0]]), r == null ? void 0 : r.crit, this._protectedHeader, n);
    let a = !0;
    if (i.has("b64") && (a = this._protectedHeader.b64, typeof a != "boolean"))
      throw new Ge('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    const { alg: s } = n;
    if (typeof s != "string" || !s)
      throw new Ge('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    rc(s, e, "sign");
    let o = this._payload;
    a && (o = dt.encode(It(o)));
    let l;
    this._protectedHeader ? l = dt.encode(It(JSON.stringify(this._protectedHeader))) : l = dt.encode("");
    const u = zr(l, dt.encode("."), o), f = await cO(s, e, u), y = {
      signature: It(f),
      payload: ""
    };
    return a && (y.payload = mr.decode(o)), this._unprotectedHeader && (y.header = this._unprotectedHeader), this._protectedHeader && (y.protected = mr.decode(l)), y;
  }
}
class SE {
  constructor(e) {
    this._flattened = new dd(e);
  }
  setProtectedHeader(e) {
    return this._flattened.setProtectedHeader(e), this;
  }
  async sign(e, r) {
    const n = await this._flattened.sign(e, r);
    if (n.payload === void 0)
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    return `${n.protected}.${n.payload}.${n.signature}`;
  }
}
class uO {
  constructor(e, r, n) {
    this.parent = e, this.key = r, this.options = n;
  }
  setProtectedHeader(e) {
    if (this.protectedHeader)
      throw new TypeError("setProtectedHeader can only be called once");
    return this.protectedHeader = e, this;
  }
  setUnprotectedHeader(e) {
    if (this.unprotectedHeader)
      throw new TypeError("setUnprotectedHeader can only be called once");
    return this.unprotectedHeader = e, this;
  }
  addSignature(...e) {
    return this.parent.addSignature(...e);
  }
  sign(...e) {
    return this.parent.sign(...e);
  }
  done() {
    return this.parent;
  }
}
class lO {
  constructor(e) {
    this._signatures = [], this._payload = e;
  }
  addSignature(e, r) {
    const n = new uO(this, e, r);
    return this._signatures.push(n), n;
  }
  async sign() {
    if (!this._signatures.length)
      throw new Ge("at least one signature must be added");
    const e = {
      signatures: [],
      payload: ""
    };
    for (let r = 0; r < this._signatures.length; r++) {
      const n = this._signatures[r], i = new dd(this._payload);
      i.setProtectedHeader(n.protectedHeader), i.setUnprotectedHeader(n.unprotectedHeader);
      const { payload: a, ...s } = await i.sign(n.key, n.options);
      if (r === 0)
        e.payload = a;
      else if (e.payload !== a)
        throw new Ge("inconsistent use of JWS Unencoded Payload (RFC7797)");
      e.signatures.push(s);
    }
    return e;
  }
}
class hd {
  constructor(e) {
    if (!Rt(e))
      throw new TypeError("JWT Claims Set MUST be an object");
    this._payload = e;
  }
  setIssuer(e) {
    return this._payload = { ...this._payload, iss: e }, this;
  }
  setSubject(e) {
    return this._payload = { ...this._payload, sub: e }, this;
  }
  setAudience(e) {
    return this._payload = { ...this._payload, aud: e }, this;
  }
  setJti(e) {
    return this._payload = { ...this._payload, jti: e }, this;
  }
  setNotBefore(e) {
    return typeof e == "number" ? this._payload = { ...this._payload, nbf: e } : this._payload = { ...this._payload, nbf: _s(/* @__PURE__ */ new Date()) + js(e) }, this;
  }
  setExpirationTime(e) {
    return typeof e == "number" ? this._payload = { ...this._payload, exp: e } : this._payload = { ...this._payload, exp: _s(/* @__PURE__ */ new Date()) + js(e) }, this;
  }
  setIssuedAt(e) {
    return typeof e > "u" ? this._payload = { ...this._payload, iat: _s(/* @__PURE__ */ new Date()) } : this._payload = { ...this._payload, iat: e }, this;
  }
}
class fO extends hd {
  setProtectedHeader(e) {
    return this._protectedHeader = e, this;
  }
  async sign(e, r) {
    var n;
    const i = new SE(dt.encode(JSON.stringify(this._payload)));
    if (i.setProtectedHeader(this._protectedHeader), Array.isArray((n = this._protectedHeader) === null || n === void 0 ? void 0 : n.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === !1)
      throw new er("JWTs MUST NOT use unencoded payload");
    return i.sign(e, r);
  }
}
class dO extends hd {
  setProtectedHeader(e) {
    if (this._protectedHeader)
      throw new TypeError("setProtectedHeader can only be called once");
    return this._protectedHeader = e, this;
  }
  setKeyManagementParameters(e) {
    if (this._keyManagementParameters)
      throw new TypeError("setKeyManagementParameters can only be called once");
    return this._keyManagementParameters = e, this;
  }
  setContentEncryptionKey(e) {
    if (this._cek)
      throw new TypeError("setContentEncryptionKey can only be called once");
    return this._cek = e, this;
  }
  setInitializationVector(e) {
    if (this._iv)
      throw new TypeError("setInitializationVector can only be called once");
    return this._iv = e, this;
  }
  replicateIssuerAsHeader() {
    return this._replicateIssuerAsHeader = !0, this;
  }
  replicateSubjectAsHeader() {
    return this._replicateSubjectAsHeader = !0, this;
  }
  replicateAudienceAsHeader() {
    return this._replicateAudienceAsHeader = !0, this;
  }
  async encrypt(e, r) {
    const n = new _E(dt.encode(JSON.stringify(this._payload)));
    return this._replicateIssuerAsHeader && (this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss }), this._replicateSubjectAsHeader && (this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub }), this._replicateAudienceAsHeader && (this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud }), n.setProtectedHeader(this._protectedHeader), this._iv && n.setInitializationVector(this._iv), this._cek && n.setContentEncryptionKey(this._cek), this._keyManagementParameters && n.setKeyManagementParameters(this._keyManagementParameters), n.encrypt(e, r);
  }
}
const En = (t, e) => {
  if (typeof t != "string" || !t)
    throw new qm(`${e} missing or invalid`);
};
async function IE(t, e) {
  if (!Rt(t))
    throw new TypeError("JWK must be an object");
  if (e ?? (e = "sha256"), e !== "sha256" && e !== "sha384" && e !== "sha512")
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  let r;
  switch (t.kty) {
    case "EC":
      En(t.crv, '"crv" (Curve) Parameter'), En(t.x, '"x" (X Coordinate) Parameter'), En(t.y, '"y" (Y Coordinate) Parameter'), r = { crv: t.crv, kty: t.kty, x: t.x, y: t.y };
      break;
    case "OKP":
      En(t.crv, '"crv" (Subtype of Key Pair) Parameter'), En(t.x, '"x" (Public Key) Parameter'), r = { crv: t.crv, kty: t.kty, x: t.x };
      break;
    case "RSA":
      En(t.e, '"e" (Exponent) Parameter'), En(t.n, '"n" (Modulus) Parameter'), r = { e: t.e, kty: t.kty, n: t.n };
      break;
    case "oct":
      En(t.k, '"k" (Key Value) Parameter'), r = { k: t.k, kty: t.kty };
      break;
    default:
      throw new Fe('"kty" (Key Type) Parameter missing or unsupported');
  }
  const n = dt.encode(JSON.stringify(r));
  return It(await Km(e, n));
}
async function hO(t, e) {
  e ?? (e = "sha256");
  const r = await IE(t, e);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${e.slice(-3)}:${r}`;
}
async function pO(t, e) {
  const r = {
    ...t,
    ...e == null ? void 0 : e.header
  };
  if (!Rt(r.jwk))
    throw new Ge('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  const n = await tc({ ...r.jwk, ext: !0 }, r.alg, !0);
  if (n instanceof Uint8Array || n.type !== "public")
    throw new Ge('"jwk" (JSON Web Key) Header Parameter must be a public key');
  return n;
}
function gO(t) {
  switch (typeof t == "string" && t.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new Fe('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function bE(t) {
  return t && typeof t == "object" && Array.isArray(t.keys) && t.keys.every(yO);
}
function yO(t) {
  return Rt(t);
}
function mO(t) {
  return typeof structuredClone == "function" ? structuredClone(t) : JSON.parse(JSON.stringify(t));
}
class wE {
  constructor(e) {
    if (this._cached = /* @__PURE__ */ new WeakMap(), !bE(e))
      throw new Yo("JSON Web Key Set malformed");
    this._jwks = mO(e);
  }
  async getKey(e, r) {
    const { alg: n, kid: i } = { ...e, ...r == null ? void 0 : r.header }, a = gO(n), s = this._jwks.keys.filter((u) => {
      let f = a === u.kty;
      if (f && typeof i == "string" && (f = i === u.kid), f && typeof u.alg == "string" && (f = n === u.alg), f && typeof u.use == "string" && (f = u.use === "sig"), f && Array.isArray(u.key_ops) && (f = u.key_ops.includes("verify")), f && n === "EdDSA" && (f = u.crv === "Ed25519" || u.crv === "Ed448"), f)
        switch (n) {
          case "ES256":
            f = u.crv === "P-256";
            break;
          case "ES256K":
            f = u.crv === "secp256k1";
            break;
          case "ES384":
            f = u.crv === "P-384";
            break;
          case "ES512":
            f = u.crv === "P-521";
            break;
        }
      return f;
    }), { 0: o, length: l } = s;
    if (l === 0)
      throw new ad();
    if (l !== 1) {
      const u = new Wm(), { _cached: f } = this;
      throw u[Symbol.asyncIterator] = async function* () {
        for (const y of s)
          try {
            yield await b0(f, y, n);
          } catch {
            continue;
          }
      }, u;
    }
    return b0(this._cached, o, n);
  }
}
async function b0(t, e, r) {
  const n = t.get(e) || t.set(e, {}).get(e);
  if (n[r] === void 0) {
    const i = await tc({ ...e, ext: !0 }, r);
    if (i instanceof Uint8Array || i.type !== "public")
      throw new Yo("JSON Web Key Set members must be public keys");
    n[r] = i;
  }
  return n[r];
}
function EO(t) {
  const e = new wE(t);
  return async function(r, n) {
    return e.getKey(r, n);
  };
}
const vO = async (t, e, r) => {
  let n, i, a = !1;
  typeof AbortController == "function" && (n = new AbortController(), i = setTimeout(() => {
    a = !0, n.abort();
  }, e));
  const s = await fetch(t.href, {
    signal: n ? n.signal : void 0,
    redirect: "manual",
    headers: r.headers
  }).catch((o) => {
    throw a ? new Jm() : o;
  });
  if (i !== void 0 && clearTimeout(i), s.status !== 200)
    throw new Nt("Expected 200 OK from the JSON Web Key Set HTTP response");
  try {
    return await s.json();
  } catch {
    throw new Nt("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
};
function AO() {
  return typeof WebSocketPair < "u" || typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime < "u" && EdgeRuntime === "vercel";
}
class CO extends wE {
  constructor(e, r) {
    if (super({ keys: [] }), this._jwks = void 0, !(e instanceof URL))
      throw new TypeError("url must be an instance of URL");
    this._url = new URL(e.href), this._options = { agent: r == null ? void 0 : r.agent, headers: r == null ? void 0 : r.headers }, this._timeoutDuration = typeof (r == null ? void 0 : r.timeoutDuration) == "number" ? r == null ? void 0 : r.timeoutDuration : 5e3, this._cooldownDuration = typeof (r == null ? void 0 : r.cooldownDuration) == "number" ? r == null ? void 0 : r.cooldownDuration : 3e4, this._cacheMaxAge = typeof (r == null ? void 0 : r.cacheMaxAge) == "number" ? r == null ? void 0 : r.cacheMaxAge : 6e5;
  }
  coolingDown() {
    return typeof this._jwksTimestamp == "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : !1;
  }
  fresh() {
    return typeof this._jwksTimestamp == "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : !1;
  }
  async getKey(e, r) {
    (!this._jwks || !this.fresh()) && await this.reload();
    try {
      return await super.getKey(e, r);
    } catch (n) {
      if (n instanceof ad && this.coolingDown() === !1)
        return await this.reload(), super.getKey(e, r);
      throw n;
    }
  }
  async reload() {
    this._pendingFetch && AO() && (this._pendingFetch = void 0), this._pendingFetch || (this._pendingFetch = vO(this._url, this._timeoutDuration, this._options).then((e) => {
      if (!bE(e))
        throw new Yo("JSON Web Key Set malformed");
      this._jwks = { keys: e.keys }, this._jwksTimestamp = Date.now(), this._pendingFetch = void 0;
    }).catch((e) => {
      throw this._pendingFetch = void 0, e;
    })), await this._pendingFetch;
  }
}
function _O(t, e) {
  const r = new CO(t, e);
  return async function(n, i) {
    return r.getKey(n, i);
  };
}
class SO extends hd {
  encode() {
    const e = It(JSON.stringify({ alg: "none" })), r = It(JSON.stringify(this._payload));
    return `${e}.${r}.`;
  }
  static decode(e, r) {
    if (typeof e != "string")
      throw new er("Unsecured JWT must be a string");
    const { 0: n, 1: i, 2: a, length: s } = e.split(".");
    if (s !== 3 || a !== "")
      throw new er("Invalid Unsecured JWT");
    let o;
    try {
      if (o = JSON.parse(mr.decode(wt(n))), o.alg !== "none")
        throw new Error();
    } catch {
      throw new er("Invalid Unsecured JWT");
    }
    return { payload: fd(o, wt(i), r), header: o };
  }
}
const IO = It, pd = wt, bO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: pd,
  encode: IO
}, Symbol.toStringTag, { value: "Module" }));
function wO(t) {
  let e;
  if (typeof t == "string") {
    const r = t.split(".");
    (r.length === 3 || r.length === 5) && ([e] = r);
  } else if (typeof t == "object" && t)
    if ("protected" in t)
      e = t.protected;
    else
      throw new TypeError("Token does not contain a Protected Header");
  try {
    if (typeof e != "string" || !e)
      throw new Error();
    const r = JSON.parse(mr.decode(pd(e)));
    if (!Rt(r))
      throw new Error();
    return r;
  } catch {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
function TO(t) {
  if (typeof t != "string")
    throw new er("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: e, length: r } = t.split(".");
  if (r === 5)
    throw new er("Only JWTs using Compact JWS serialization can be decoded");
  if (r !== 3)
    throw new er("Invalid JWT");
  if (!e)
    throw new er("JWTs must contain a payload");
  let n;
  try {
    n = pd(e);
  } catch {
    throw new er("Failed to base64url decode the payload");
  }
  let i;
  try {
    i = JSON.parse(mr.decode(n));
  } catch {
    throw new er("Failed to parse the decoded payload as JSON");
  }
  if (!Rt(i))
    throw new er("Invalid JWT Claims Set");
  return i;
}
async function RO(t, e) {
  var r;
  let n, i, a;
  switch (t) {
    case "HS256":
    case "HS384":
    case "HS512":
      n = parseInt(t.slice(-3), 10), i = { name: "HMAC", hash: `SHA-${n}`, length: n }, a = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return n = parseInt(t.slice(-3), 10), Qo(new Uint8Array(n >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      n = parseInt(t.slice(1, 4), 10), i = { name: "AES-KW", length: n }, a = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      n = parseInt(t.slice(1, 4), 10), i = { name: "AES-GCM", length: n }, a = ["encrypt", "decrypt"];
      break;
    default:
      throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return Ne.subtle.generateKey(i, (r = e == null ? void 0 : e.extractable) !== null && r !== void 0 ? r : !1, a);
}
function el(t) {
  var e;
  const r = (e = t == null ? void 0 : t.modulusLength) !== null && e !== void 0 ? e : 2048;
  if (typeof r != "number" || r < 2048)
    throw new Fe("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  return r;
}
async function NO(t, e) {
  var r, n, i;
  let a, s;
  switch (t) {
    case "PS256":
    case "PS384":
    case "PS512":
      a = {
        name: "RSA-PSS",
        hash: `SHA-${t.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: el(e)
      }, s = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      a = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${t.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: el(e)
      }, s = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      a = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(t.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: el(e)
      }, s = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      a = { name: "ECDSA", namedCurve: "P-256" }, s = ["sign", "verify"];
      break;
    case "ES384":
      a = { name: "ECDSA", namedCurve: "P-384" }, s = ["sign", "verify"];
      break;
    case "ES512":
      a = { name: "ECDSA", namedCurve: "P-521" }, s = ["sign", "verify"];
      break;
    case "EdDSA":
      s = ["sign", "verify"];
      const o = (r = e == null ? void 0 : e.crv) !== null && r !== void 0 ? r : "Ed25519";
      switch (o) {
        case "Ed25519":
        case "Ed448":
          a = { name: o };
          break;
        default:
          throw new Fe("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      s = ["deriveKey", "deriveBits"];
      const l = (n = e == null ? void 0 : e.crv) !== null && n !== void 0 ? n : "P-256";
      switch (l) {
        case "P-256":
        case "P-384":
        case "P-521": {
          a = { name: "ECDH", namedCurve: l };
          break;
        }
        case "X25519":
        case "X448":
          a = { name: l };
          break;
        default:
          throw new Fe("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new Fe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return Ne.subtle.generateKey(a, (i = e == null ? void 0 : e.extractable) !== null && i !== void 0 ? i : !1, s);
}
async function xO(t, e) {
  return NO(t, e);
}
async function OO(t, e) {
  return RO(t, e);
}
const DO = "WebCryptoAPI", LO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompactEncrypt: _E,
  CompactSign: SE,
  EmbeddedJWK: pO,
  EncryptJWT: dO,
  FlattenedEncrypt: Gs,
  FlattenedSign: dd,
  GeneralEncrypt: Z2,
  GeneralSign: lO,
  SignJWT: fO,
  UnsecuredJWT: SO,
  base64url: bO,
  calculateJwkThumbprint: IE,
  calculateJwkThumbprintUri: hO,
  compactDecrypt: hE,
  compactVerify: vE,
  createLocalJWKSet: EO,
  createRemoteJWKSet: _O,
  cryptoRuntime: DO,
  decodeJwt: TO,
  decodeProtectedHeader: wO,
  errors: g2,
  exportJWK: pE,
  exportPKCS8: Y2,
  exportSPKI: X2,
  flattenedDecrypt: cd,
  flattenedVerify: ud,
  generalDecrypt: J2,
  generalVerify: tO,
  generateKeyPair: xO,
  generateSecret: OO,
  importJWK: tc,
  importPKCS8: V2,
  importSPKI: F2,
  importX509: M2,
  jwtDecrypt: oO,
  jwtVerify: sO
}, Symbol.toStringTag, { value: "Module" })), TE = /* @__PURE__ */ Z0(LO);
function qs(t) {
  Error.call(this, t), Error.captureStackTrace(this, this.constructor), this.name = "JwksError", this.message = t;
}
qs.prototype = Object.create(Error.prototype);
qs.prototype.constructor = qs;
var gd = qs;
const w0 = TE, PO = gd;
function kO(t) {
  if (t.alg)
    return t.alg;
  if (t.kty === "RSA")
    return "RS256";
  if (t.kty === "EC")
    switch (t.crv) {
      case "P-256":
        return "ES256";
      case "secp256k1":
        return "ES256K";
      case "P-384":
        return "ES384";
      case "P-521":
        return "ES512";
    }
  if (t.kty === "OKP")
    switch (t.crv) {
      case "Ed25519":
      case "Ed448":
        return "EdDSA";
    }
  throw new PO("Unsupported JWK");
}
async function BO(t) {
  const e = [];
  t = t.filter(({ use: r }) => r === "sig" || r === void 0).filter(({ kty: r }) => r === "RSA" || r === "EC" || r === "OKP");
  for (const r of t)
    try {
      const n = await w0.importJWK({ ...r, ext: !0 }, kO(r));
      if (n.type !== "public")
        continue;
      let i;
      switch (n[Symbol.toStringTag]) {
        case "CryptoKey": {
          const a = await w0.exportSPKI(n);
          i = () => a;
          break;
        }
        case "KeyObject":
        default:
          i = () => n.export({ format: "pem", type: "spki" });
      }
      e.push({
        get publicKey() {
          return i();
        },
        get rsaPublicKey() {
          return i();
        },
        getPublicKey() {
          return i();
        },
        ...typeof r.kid == "string" && r.kid ? { kid: r.kid } : void 0,
        ...typeof r.alg == "string" && r.alg ? { alg: r.alg } : void 0
      });
    } catch {
      continue;
    }
  return e;
}
var RE = {
  retrieveSigningKeys: BO
}, NE = {};
const UO = ge, FO = ge, MO = ge;
NE.default = (t) => t.fetcher ? t.fetcher(t.uri) : new Promise((e, r) => {
  const {
    hostname: n,
    path: i,
    port: a,
    protocol: s
  } = MO.parse(t.uri), o = {
    hostname: n,
    path: i,
    port: a,
    method: "GET",
    ...t.headers && { headers: { ...t.headers } },
    ...t.timeout && { timeout: t.timeout },
    ...t.agent && { agent: t.agent }
  }, u = (s === "https:" ? FO : UO).request(o, (f) => {
    let y = "";
    f.setEncoding("utf8"), f.on("data", (m) => {
      y += m;
    }), f.on("end", () => {
      if (f.statusCode < 200 || f.statusCode >= 300) {
        const m = f.body && (f.body.message || f.body) || f.statusMessage || `Http Error ${f.statusCode}`;
        r({ errorMsg: m });
      } else
        try {
          e(y && JSON.parse(y));
        } catch (m) {
          r(m);
        }
    });
  });
  u.on("timeout", () => u.destroy()).on("error", (f) => r(f)).end();
});
var xE = {}, nc = {}, tl, T0;
function VO() {
  return T0 || (T0 = 1, tl = function(t) {
    t.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next)
        yield e.value;
    };
  }), tl;
}
var $O = Ve;
Ve.Node = Jn;
Ve.create = Ve;
function Ve(t) {
  var e = this;
  if (e instanceof Ve || (e = new Ve()), e.tail = null, e.head = null, e.length = 0, t && typeof t.forEach == "function")
    t.forEach(function(i) {
      e.push(i);
    });
  else if (arguments.length > 0)
    for (var r = 0, n = arguments.length; r < n; r++)
      e.push(arguments[r]);
  return e;
}
Ve.prototype.removeNode = function(t) {
  if (t.list !== this)
    throw new Error("removing node which does not belong to this list");
  var e = t.next, r = t.prev;
  return e && (e.prev = r), r && (r.next = e), t === this.head && (this.head = e), t === this.tail && (this.tail = r), t.list.length--, t.next = null, t.prev = null, t.list = null, e;
};
Ve.prototype.unshiftNode = function(t) {
  if (t !== this.head) {
    t.list && t.list.removeNode(t);
    var e = this.head;
    t.list = this, t.next = e, e && (e.prev = t), this.head = t, this.tail || (this.tail = t), this.length++;
  }
};
Ve.prototype.pushNode = function(t) {
  if (t !== this.tail) {
    t.list && t.list.removeNode(t);
    var e = this.tail;
    t.list = this, t.prev = e, e && (e.next = t), this.tail = t, this.head || (this.head = t), this.length++;
  }
};
Ve.prototype.push = function() {
  for (var t = 0, e = arguments.length; t < e; t++)
    KO(this, arguments[t]);
  return this.length;
};
Ve.prototype.unshift = function() {
  for (var t = 0, e = arguments.length; t < e; t++)
    GO(this, arguments[t]);
  return this.length;
};
Ve.prototype.pop = function() {
  if (this.tail) {
    var t = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
  }
};
Ve.prototype.shift = function() {
  if (this.head) {
    var t = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
  }
};
Ve.prototype.forEach = function(t, e) {
  e = e || this;
  for (var r = this.head, n = 0; r !== null; n++)
    t.call(e, r.value, n, this), r = r.next;
};
Ve.prototype.forEachReverse = function(t, e) {
  e = e || this;
  for (var r = this.tail, n = this.length - 1; r !== null; n--)
    t.call(e, r.value, n, this), r = r.prev;
};
Ve.prototype.get = function(t) {
  for (var e = 0, r = this.head; r !== null && e < t; e++)
    r = r.next;
  if (e === t && r !== null)
    return r.value;
};
Ve.prototype.getReverse = function(t) {
  for (var e = 0, r = this.tail; r !== null && e < t; e++)
    r = r.prev;
  if (e === t && r !== null)
    return r.value;
};
Ve.prototype.map = function(t, e) {
  e = e || this;
  for (var r = new Ve(), n = this.head; n !== null; )
    r.push(t.call(e, n.value, this)), n = n.next;
  return r;
};
Ve.prototype.mapReverse = function(t, e) {
  e = e || this;
  for (var r = new Ve(), n = this.tail; n !== null; )
    r.push(t.call(e, n.value, this)), n = n.prev;
  return r;
};
Ve.prototype.reduce = function(t, e) {
  var r, n = this.head;
  if (arguments.length > 1)
    r = e;
  else if (this.head)
    n = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; n !== null; i++)
    r = t(r, n.value, i), n = n.next;
  return r;
};
Ve.prototype.reduceReverse = function(t, e) {
  var r, n = this.tail;
  if (arguments.length > 1)
    r = e;
  else if (this.tail)
    n = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; n !== null; i--)
    r = t(r, n.value, i), n = n.prev;
  return r;
};
Ve.prototype.toArray = function() {
  for (var t = new Array(this.length), e = 0, r = this.head; r !== null; e++)
    t[e] = r.value, r = r.next;
  return t;
};
Ve.prototype.toArrayReverse = function() {
  for (var t = new Array(this.length), e = 0, r = this.tail; r !== null; e++)
    t[e] = r.value, r = r.prev;
  return t;
};
Ve.prototype.slice = function(t, e) {
  e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
  var r = new Ve();
  if (e < t || e < 0)
    return r;
  t < 0 && (t = 0), e > this.length && (e = this.length);
  for (var n = 0, i = this.head; i !== null && n < t; n++)
    i = i.next;
  for (; i !== null && n < e; n++, i = i.next)
    r.push(i.value);
  return r;
};
Ve.prototype.sliceReverse = function(t, e) {
  e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
  var r = new Ve();
  if (e < t || e < 0)
    return r;
  t < 0 && (t = 0), e > this.length && (e = this.length);
  for (var n = this.length, i = this.tail; i !== null && n > e; n--)
    i = i.prev;
  for (; i !== null && n > t; n--, i = i.prev)
    r.push(i.value);
  return r;
};
Ve.prototype.splice = function(t, e, ...r) {
  t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
  for (var n = 0, i = this.head; i !== null && n < t; n++)
    i = i.next;
  for (var a = [], n = 0; i && n < e; n++)
    a.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < r.length; n++)
    i = HO(this, i, r[n]);
  return a;
};
Ve.prototype.reverse = function() {
  for (var t = this.head, e = this.tail, r = t; r !== null; r = r.prev) {
    var n = r.prev;
    r.prev = r.next, r.next = n;
  }
  return this.head = e, this.tail = t, this;
};
function HO(t, e, r) {
  var n = e === t.head ? new Jn(r, null, e, t) : new Jn(r, e, e.next, t);
  return n.next === null && (t.tail = n), n.prev === null && (t.head = n), t.length++, n;
}
function KO(t, e) {
  t.tail = new Jn(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++;
}
function GO(t, e) {
  t.head = new Jn(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++;
}
function Jn(t, e, r, n) {
  if (!(this instanceof Jn))
    return new Jn(t, e, r, n);
  this.list = n, this.value = t, e ? (e.next = this, this.prev = e) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  VO()(Ve);
} catch {
}
const jO = $O, Vn = Symbol("max"), an = Symbol("length"), Ei = Symbol("lengthCalculator"), la = Symbol("allowStale"), Hn = Symbol("maxAge"), rn = Symbol("dispose"), R0 = Symbol("noDisposeOnSet"), Tt = Symbol("lruList"), wr = Symbol("cache"), OE = Symbol("updateAgeOnGet"), rl = () => 1;
class qO {
  constructor(e) {
    if (typeof e == "number" && (e = { max: e }), e || (e = {}), e.max && (typeof e.max != "number" || e.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Vn] = e.max || 1 / 0;
    const r = e.length || rl;
    if (this[Ei] = typeof r != "function" ? rl : r, this[la] = e.stale || !1, e.maxAge && typeof e.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Hn] = e.maxAge || 0, this[rn] = e.dispose, this[R0] = e.noDisposeOnSet || !1, this[OE] = e.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(e) {
    if (typeof e != "number" || e < 0)
      throw new TypeError("max must be a non-negative number");
    this[Vn] = e || 1 / 0, Zi(this);
  }
  get max() {
    return this[Vn];
  }
  set allowStale(e) {
    this[la] = !!e;
  }
  get allowStale() {
    return this[la];
  }
  set maxAge(e) {
    if (typeof e != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Hn] = e, Zi(this);
  }
  get maxAge() {
    return this[Hn];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(e) {
    typeof e != "function" && (e = rl), e !== this[Ei] && (this[Ei] = e, this[an] = 0, this[Tt].forEach((r) => {
      r.length = this[Ei](r.value, r.key), this[an] += r.length;
    })), Zi(this);
  }
  get lengthCalculator() {
    return this[Ei];
  }
  get length() {
    return this[an];
  }
  get itemCount() {
    return this[Tt].length;
  }
  rforEach(e, r) {
    r = r || this;
    for (let n = this[Tt].tail; n !== null; ) {
      const i = n.prev;
      N0(this, e, n, r), n = i;
    }
  }
  forEach(e, r) {
    r = r || this;
    for (let n = this[Tt].head; n !== null; ) {
      const i = n.next;
      N0(this, e, n, r), n = i;
    }
  }
  keys() {
    return this[Tt].toArray().map((e) => e.key);
  }
  values() {
    return this[Tt].toArray().map((e) => e.value);
  }
  reset() {
    this[rn] && this[Tt] && this[Tt].length && this[Tt].forEach((e) => this[rn](e.key, e.value)), this[wr] = /* @__PURE__ */ new Map(), this[Tt] = new jO(), this[an] = 0;
  }
  dump() {
    return this[Tt].map((e) => Ws(this, e) ? !1 : {
      k: e.key,
      v: e.value,
      e: e.now + (e.maxAge || 0)
    }).toArray().filter((e) => e);
  }
  dumpLru() {
    return this[Tt];
  }
  set(e, r, n) {
    if (n = n || this[Hn], n && typeof n != "number")
      throw new TypeError("maxAge must be a number");
    const i = n ? Date.now() : 0, a = this[Ei](r, e);
    if (this[wr].has(e)) {
      if (a > this[Vn])
        return wi(this, this[wr].get(e)), !1;
      const l = this[wr].get(e).value;
      return this[rn] && (this[R0] || this[rn](e, l.value)), l.now = i, l.maxAge = n, l.value = r, this[an] += a - l.length, l.length = a, this.get(e), Zi(this), !0;
    }
    const s = new WO(e, r, a, i, n);
    return s.length > this[Vn] ? (this[rn] && this[rn](e, r), !1) : (this[an] += s.length, this[Tt].unshift(s), this[wr].set(e, this[Tt].head), Zi(this), !0);
  }
  has(e) {
    if (!this[wr].has(e)) return !1;
    const r = this[wr].get(e).value;
    return !Ws(this, r);
  }
  get(e) {
    return nl(this, e, !0);
  }
  peek(e) {
    return nl(this, e, !1);
  }
  pop() {
    const e = this[Tt].tail;
    return e ? (wi(this, e), e.value) : null;
  }
  del(e) {
    wi(this, this[wr].get(e));
  }
  load(e) {
    this.reset();
    const r = Date.now();
    for (let n = e.length - 1; n >= 0; n--) {
      const i = e[n], a = i.e || 0;
      if (a === 0)
        this.set(i.k, i.v);
      else {
        const s = a - r;
        s > 0 && this.set(i.k, i.v, s);
      }
    }
  }
  prune() {
    this[wr].forEach((e, r) => nl(this, r, !1));
  }
}
const nl = (t, e, r) => {
  const n = t[wr].get(e);
  if (n) {
    const i = n.value;
    if (Ws(t, i)) {
      if (wi(t, n), !t[la])
        return;
    } else
      r && (t[OE] && (n.value.now = Date.now()), t[Tt].unshiftNode(n));
    return i.value;
  }
}, Ws = (t, e) => {
  if (!e || !e.maxAge && !t[Hn])
    return !1;
  const r = Date.now() - e.now;
  return e.maxAge ? r > e.maxAge : t[Hn] && r > t[Hn];
}, Zi = (t) => {
  if (t[an] > t[Vn])
    for (let e = t[Tt].tail; t[an] > t[Vn] && e !== null; ) {
      const r = e.prev;
      wi(t, e), e = r;
    }
}, wi = (t, e) => {
  if (e) {
    const r = e.value;
    t[rn] && t[rn](r.key, r.value), t[an] -= r.length, t[wr].delete(r.key), t[Tt].removeNode(e);
  }
};
class WO {
  constructor(e, r, n, i, a) {
    this.key = e, this.value = r, this.length = n, this.now = i, this.maxAge = a || 0;
  }
}
const N0 = (t, e, r, n) => {
  let i = r.value;
  Ws(t, i) && (wi(t, r), t[la] || (i = void 0)), i && e.call(n, i.value, i.key, t);
};
var DE = qO, Js = { exports: {} };
Js.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 9007199254740991, a = "[object Arguments]", s = "[object Array]", o = "[object Boolean]", l = "[object Date]", u = "[object Error]", f = "[object Function]", y = "[object GeneratorFunction]", m = "[object Map]", p = "[object Number]", S = "[object Object]", A = "[object Promise]", I = "[object RegExp]", c = "[object Set]", E = "[object String]", v = "[object Symbol]", R = "[object WeakMap]", N = "[object ArrayBuffer]", C = "[object DataView]", h = "[object Float32Array]", d = "[object Float64Array]", O = "[object Int8Array]", P = "[object Int16Array]", L = "[object Int32Array]", D = "[object Uint8Array]", V = "[object Uint8ClampedArray]", $ = "[object Uint16Array]", K = "[object Uint32Array]", Q = /[\\^$.*+?()[\]{}|]/g, ee = /\w*$/, ne = /^\[object .+?Constructor\]$/, ae = /^(?:0|[1-9]\d*)$/, se = {};
  se[a] = se[s] = se[N] = se[C] = se[o] = se[l] = se[h] = se[d] = se[O] = se[P] = se[L] = se[m] = se[p] = se[S] = se[I] = se[c] = se[E] = se[v] = se[D] = se[V] = se[$] = se[K] = !0, se[u] = se[f] = se[R] = !1;
  var me = typeof pe == "object" && pe && pe.Object === Object && pe, ye = typeof self == "object" && self && self.Object === Object && self, Se = me || ye || Function("return this")(), te = e && !e.nodeType && e, Ce = te && !0 && t && !t.nodeType && t, fe = Ce && Ce.exports === te;
  function De(G, ie) {
    return G.set(ie[0], ie[1]), G;
  }
  function _e(G, ie) {
    return G.add(ie), G;
  }
  function w(G, ie) {
    for (var ue = -1, we = G ? G.length : 0; ++ue < we && ie(G[ue], ue, G) !== !1; )
      ;
    return G;
  }
  function b(G, ie) {
    for (var ue = -1, we = ie.length, xt = G.length; ++ue < we; )
      G[xt + ue] = ie[ue];
    return G;
  }
  function T(G, ie, ue, we) {
    for (var xt = -1, Xt = G ? G.length : 0; ++xt < Xt; )
      ue = ie(ue, G[xt], xt, G);
    return ue;
  }
  function g(G, ie) {
    for (var ue = -1, we = Array(G); ++ue < G; )
      we[ue] = ie(ue);
    return we;
  }
  function x(G, ie) {
    return G == null ? void 0 : G[ie];
  }
  function U(G) {
    var ie = !1;
    if (G != null && typeof G.toString != "function")
      try {
        ie = !!(G + "");
      } catch {
      }
    return ie;
  }
  function k(G) {
    var ie = -1, ue = Array(G.size);
    return G.forEach(function(we, xt) {
      ue[++ie] = [xt, we];
    }), ue;
  }
  function W(G, ie) {
    return function(ue) {
      return G(ie(ue));
    };
  }
  function q(G) {
    var ie = -1, ue = Array(G.size);
    return G.forEach(function(we) {
      ue[++ie] = we;
    }), ue;
  }
  var z = Array.prototype, j = Function.prototype, Y = Object.prototype, M = Se["__core-js_shared__"], X = function() {
    var G = /[^.]+$/.exec(M && M.keys && M.keys.IE_PROTO || "");
    return G ? "Symbol(src)_1." + G : "";
  }(), J = j.toString, Z = Y.hasOwnProperty, oe = Y.toString, he = RegExp(
    "^" + J.call(Z).replace(Q, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ee = fe ? Se.Buffer : void 0, be = Se.Symbol, Re = Se.Uint8Array, ze = W(Object.getPrototypeOf, Object), nt = Object.create, it = Y.propertyIsEnumerable, je = z.splice, Ze = Object.getOwnPropertySymbols, qe = Ee ? Ee.isBuffer : void 0, He = W(Object.keys, Object), ke = Ur(Se, "DataView"), Pt = Ur(Se, "Map"), nr = Ur(Se, "Promise"), ur = Ur(Se, "Set"), _r = Ur(Se, "WeakMap"), lr = Ur(Object, "create"), xn = Dn(ke), oi = Dn(Pt), ht = Dn(nr), pt = Dn(ur), gt = Dn(_r), ct = be ? be.prototype : void 0, ut = ct ? ct.valueOf : void 0;
  function Xe(G) {
    var ie = -1, ue = G ? G.length : 0;
    for (this.clear(); ++ie < ue; ) {
      var we = G[ie];
      this.set(we[0], we[1]);
    }
  }
  function yt() {
    this.__data__ = lr ? lr(null) : {};
  }
  function mt(G) {
    return this.has(G) && delete this.__data__[G];
  }
  function Et(G) {
    var ie = this.__data__;
    if (lr) {
      var ue = ie[G];
      return ue === n ? void 0 : ue;
    }
    return Z.call(ie, G) ? ie[G] : void 0;
  }
  function vt(G) {
    var ie = this.__data__;
    return lr ? ie[G] !== void 0 : Z.call(ie, G);
  }
  function At(G, ie) {
    var ue = this.__data__;
    return ue[G] = lr && ie === void 0 ? n : ie, this;
  }
  Xe.prototype.clear = yt, Xe.prototype.delete = mt, Xe.prototype.get = Et, Xe.prototype.has = vt, Xe.prototype.set = At;
  function We(G) {
    var ie = -1, ue = G ? G.length : 0;
    for (this.clear(); ++ie < ue; ) {
      var we = G[ie];
      this.set(we[0], we[1]);
    }
  }
  function et() {
    this.__data__ = [];
  }
  function lt(G) {
    var ie = this.__data__, ue = ci(ie, G);
    if (ue < 0)
      return !1;
    var we = ie.length - 1;
    return ue == we ? ie.pop() : je.call(ie, ue, 1), !0;
  }
  function Ct(G) {
    var ie = this.__data__, ue = ci(ie, G);
    return ue < 0 ? void 0 : ie[ue][1];
  }
  function _t(G) {
    return ci(this.__data__, G) > -1;
  }
  function dc(G, ie) {
    var ue = this.__data__, we = ci(ue, G);
    return we < 0 ? ue.push([G, ie]) : ue[we][1] = ie, this;
  }
  We.prototype.clear = et, We.prototype.delete = lt, We.prototype.get = Ct, We.prototype.has = _t, We.prototype.set = dc;
  function hn(G) {
    var ie = -1, ue = G ? G.length : 0;
    for (this.clear(); ++ie < ue; ) {
      var we = G[ie];
      this.set(we[0], we[1]);
    }
  }
  function hc() {
    this.__data__ = {
      hash: new Xe(),
      map: new (Pt || We)(),
      string: new Xe()
    };
  }
  function pn(G) {
    return sr(this, G).delete(G);
  }
  function pc(G) {
    return sr(this, G).get(G);
  }
  function gc(G) {
    return sr(this, G).has(G);
  }
  function yc(G, ie) {
    return sr(this, G).set(G, ie), this;
  }
  hn.prototype.clear = hc, hn.prototype.delete = pn, hn.prototype.get = pc, hn.prototype.has = gc, hn.prototype.set = yc;
  function gn(G) {
    this.__data__ = new We(G);
  }
  function mc() {
    this.__data__ = new We();
  }
  function Ec(G) {
    return this.__data__.delete(G);
  }
  function vc(G) {
    return this.__data__.get(G);
  }
  function Ac(G) {
    return this.__data__.has(G);
  }
  function Cc(G, ie) {
    var ue = this.__data__;
    if (ue instanceof We) {
      var we = ue.__data__;
      if (!Pt || we.length < r - 1)
        return we.push([G, ie]), this;
      ue = this.__data__ = new hn(we);
    }
    return ue.set(G, ie), this;
  }
  gn.prototype.clear = mc, gn.prototype.delete = Ec, gn.prototype.get = vc, gn.prototype.has = Ac, gn.prototype.set = Cc;
  function ir(G, ie) {
    var ue = Sc(G) || Xv(G) ? g(G.length, String) : [], we = ue.length, xt = !!we;
    for (var Xt in G)
      Z.call(G, Xt) && !(xt && (Xt == "length" || qv(Xt, we))) && ue.push(Xt);
    return ue;
  }
  function ja(G, ie, ue) {
    var we = G[ie];
    (!(Z.call(G, ie) && Dd(we, ue)) || ue === void 0 && !(ie in G)) && (G[ie] = ue);
  }
  function ci(G, ie) {
    for (var ue = G.length; ue--; )
      if (Dd(G[ue][0], ie))
        return ue;
    return -1;
  }
  function _c(G, ie) {
    return G && zt(ie, Ic(ie), G);
  }
  function Wi(G, ie, ue, we, xt, Xt, Xr) {
    var Yt;
    if (we && (Yt = Xt ? we(G, xt, Xt, Xr) : we(G)), Yt !== void 0)
      return Yt;
    if (!qa(G))
      return G;
    var kd = Sc(G);
    if (kd) {
      if (Yt = Kv(G), !ie)
        return ui(G, Yt);
    } else {
      var fi = On(G), Bd = fi == f || fi == y;
      if (Qv(G))
        return le(G, ie);
      if (fi == S || fi == a || Bd && !Xt) {
        if (U(G))
          return Xt ? G : {};
        if (Yt = Gv(Bd ? {} : G), !ie)
          return ar(G, _c(Yt, G));
      } else {
        if (!se[fi])
          return Xt ? G : {};
        Yt = jv(G, fi, Wi, ie);
      }
    }
    Xr || (Xr = new gn());
    var Ud = Xr.get(G);
    if (Ud)
      return Ud;
    if (Xr.set(G, Yt), !kd)
      var Fd = ue ? li(G) : Ic(G);
    return w(Fd || G, function(bc, Wa) {
      Fd && (Wa = bc, bc = G[Wa]), ja(Yt, Wa, Wi(bc, ie, ue, we, Wa, G, Xr));
    }), Yt;
  }
  function B(G) {
    return qa(G) ? nt(G) : {};
  }
  function F(G, ie, ue) {
    var we = ie(G);
    return Sc(G) ? we : b(we, ue(G));
  }
  function H(G) {
    return oe.call(G);
  }
  function re(G) {
    if (!qa(G) || Jv(G))
      return !1;
    var ie = Pd(G) || U(G) ? he : ne;
    return ie.test(Dn(G));
  }
  function ce(G) {
    if (!Od(G))
      return He(G);
    var ie = [];
    for (var ue in Object(G))
      Z.call(G, ue) && ue != "constructor" && ie.push(ue);
    return ie;
  }
  function le(G, ie) {
    if (ie)
      return G.slice();
    var ue = new G.constructor(G.length);
    return G.copy(ue), ue;
  }
  function Ae(G) {
    var ie = new G.constructor(G.byteLength);
    return new Re(ie).set(new Re(G)), ie;
  }
  function ve(G, ie) {
    var ue = ie ? Ae(G.buffer) : G.buffer;
    return new G.constructor(ue, G.byteOffset, G.byteLength);
  }
  function Ke(G, ie, ue) {
    var we = ie ? ue(k(G), !0) : k(G);
    return T(we, De, new G.constructor());
  }
  function St(G) {
    var ie = new G.constructor(G.source, ee.exec(G));
    return ie.lastIndex = G.lastIndex, ie;
  }
  function Jt(G, ie, ue) {
    var we = ie ? ue(q(G), !0) : q(G);
    return T(we, _e, new G.constructor());
  }
  function Kt(G) {
    return ut ? Object(ut.call(G)) : {};
  }
  function Sr(G, ie) {
    var ue = ie ? Ae(G.buffer) : G.buffer;
    return new G.constructor(ue, G.byteOffset, G.length);
  }
  function ui(G, ie) {
    var ue = -1, we = G.length;
    for (ie || (ie = Array(we)); ++ue < we; )
      ie[ue] = G[ue];
    return ie;
  }
  function zt(G, ie, ue, we) {
    ue || (ue = {});
    for (var xt = -1, Xt = ie.length; ++xt < Xt; ) {
      var Xr = ie[xt], Yt = void 0;
      ja(ue, Xr, Yt === void 0 ? G[Xr] : Yt);
    }
    return ue;
  }
  function ar(G, ie) {
    return zt(G, xd(G), ie);
  }
  function li(G) {
    return F(G, Ic, xd);
  }
  function sr(G, ie) {
    var ue = G.__data__;
    return Wv(ie) ? ue[typeof ie == "string" ? "string" : "hash"] : ue.map;
  }
  function Ur(G, ie) {
    var ue = x(G, ie);
    return re(ue) ? ue : void 0;
  }
  var xd = Ze ? W(Ze, Object) : tA, On = H;
  (ke && On(new ke(new ArrayBuffer(1))) != C || Pt && On(new Pt()) != m || nr && On(nr.resolve()) != A || ur && On(new ur()) != c || _r && On(new _r()) != R) && (On = function(G) {
    var ie = oe.call(G), ue = ie == S ? G.constructor : void 0, we = ue ? Dn(ue) : void 0;
    if (we)
      switch (we) {
        case xn:
          return C;
        case oi:
          return m;
        case ht:
          return A;
        case pt:
          return c;
        case gt:
          return R;
      }
    return ie;
  });
  function Kv(G) {
    var ie = G.length, ue = G.constructor(ie);
    return ie && typeof G[0] == "string" && Z.call(G, "index") && (ue.index = G.index, ue.input = G.input), ue;
  }
  function Gv(G) {
    return typeof G.constructor == "function" && !Od(G) ? B(ze(G)) : {};
  }
  function jv(G, ie, ue, we) {
    var xt = G.constructor;
    switch (ie) {
      case N:
        return Ae(G);
      case o:
      case l:
        return new xt(+G);
      case C:
        return ve(G, we);
      case h:
      case d:
      case O:
      case P:
      case L:
      case D:
      case V:
      case $:
      case K:
        return Sr(G, we);
      case m:
        return Ke(G, we, ue);
      case p:
      case E:
        return new xt(G);
      case I:
        return St(G);
      case c:
        return Jt(G, we, ue);
      case v:
        return Kt(G);
    }
  }
  function qv(G, ie) {
    return ie = ie ?? i, !!ie && (typeof G == "number" || ae.test(G)) && G > -1 && G % 1 == 0 && G < ie;
  }
  function Wv(G) {
    var ie = typeof G;
    return ie == "string" || ie == "number" || ie == "symbol" || ie == "boolean" ? G !== "__proto__" : G === null;
  }
  function Jv(G) {
    return !!X && X in G;
  }
  function Od(G) {
    var ie = G && G.constructor, ue = typeof ie == "function" && ie.prototype || Y;
    return G === ue;
  }
  function Dn(G) {
    if (G != null) {
      try {
        return J.call(G);
      } catch {
      }
      try {
        return G + "";
      } catch {
      }
    }
    return "";
  }
  function zv(G) {
    return Wi(G, !0, !0);
  }
  function Dd(G, ie) {
    return G === ie || G !== G && ie !== ie;
  }
  function Xv(G) {
    return Yv(G) && Z.call(G, "callee") && (!it.call(G, "callee") || oe.call(G) == a);
  }
  var Sc = Array.isArray;
  function Ld(G) {
    return G != null && Zv(G.length) && !Pd(G);
  }
  function Yv(G) {
    return eA(G) && Ld(G);
  }
  var Qv = qe || rA;
  function Pd(G) {
    var ie = qa(G) ? oe.call(G) : "";
    return ie == f || ie == y;
  }
  function Zv(G) {
    return typeof G == "number" && G > -1 && G % 1 == 0 && G <= i;
  }
  function qa(G) {
    var ie = typeof G;
    return !!G && (ie == "object" || ie == "function");
  }
  function eA(G) {
    return !!G && typeof G == "object";
  }
  function Ic(G) {
    return Ld(G) ? ir(G) : ce(G);
  }
  function tA() {
    return [];
  }
  function rA() {
    return !1;
  }
  t.exports = zv;
})(Js, Js.exports);
var LE = Js.exports, $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.deepFreeze = void 0;
function PE(t) {
  return t && (Object.freeze(t), Object.getOwnPropertyNames(t).forEach(function(e) {
    t.hasOwnProperty(e) && t[e] !== null && (typeof t[e] == "object" || typeof t[e] == "function") && t[e].constructor !== Buffer && !Object.isFrozen(t[e]) && PE(t[e]);
  })), t;
}
$a.deepFreeze = PE;
var ic = {}, JO = pe && pe.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, a = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) a.push(i.value);
  } catch (o) {
    s = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return a;
}, Mr = pe && pe.__spread || function() {
  for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(JO(arguments[e]));
  return t;
}, kE = pe && pe.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ic, "__esModule", { value: !0 });
ic.syncMemoizer = void 0;
var zO = kE(DE), XO = ge, x0 = kE(LE), O0 = $a;
function YO(t) {
  var e = new zO.default(t), r = t.load, n = t.hash, i = t.bypass, a = t.itemMaxAge, s = t.freeze, o = t.clone, l = new XO.EventEmitter(), u = Object.assign({
    del: f,
    reset: function() {
      return e.reset();
    },
    keys: e.keys.bind(e),
    on: l.on.bind(l),
    once: l.once.bind(l)
  }, t);
  if (t.disable)
    return Object.assign(r, u);
  function f() {
    var A = n.apply(void 0, Mr(arguments));
    e.del(A);
  }
  function y(A) {
    for (var I = [], c = 1; c < arguments.length; c++)
      I[c - 1] = arguments[c];
    l.emit.apply(l, Mr([A], I));
  }
  function m(A) {
    return A && A.then && typeof A.then == "function";
  }
  function p(A) {
    var I = A;
    return o && (m(I) ? I = I.then(x0.default) : I = x0.default(I)), s && (m(I) ? I = I.then(O0.deepFreeze) : O0.deepFreeze(I)), I;
  }
  var S = function() {
    for (var A = [], I = 0; I < arguments.length; I++)
      A[I] = arguments[I];
    if (i && i.apply(void 0, Mr(A)))
      return y.apply(void 0, Mr(["miss"], A)), r.apply(void 0, Mr(A));
    var c = n.apply(void 0, Mr(A)), E = e.get(c);
    if (E)
      return y.apply(void 0, Mr(["hit"], A)), p(E);
    y.apply(void 0, Mr(["miss"], A));
    var v = r.apply(void 0, Mr(A));
    return a ? e.set(c, v, a.apply(void 0, Mr(A.concat([v])))) : e.set(c, v), p(v);
  };
  return Object.assign(S, u);
}
ic.syncMemoizer = YO;
var QO = pe && pe.__read || function(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, a = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) a.push(i.value);
  } catch (o) {
    s = { error: o };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return a;
}, Qt = pe && pe.__spread || function() {
  for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(QO(arguments[e]));
  return t;
}, ZO = pe && pe.__values || function(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, BE = pe && pe.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(nc, "__esModule", { value: !0 });
nc.asyncMemoizer = void 0;
var eD = BE(DE), tD = ge, rD = BE(LE), nD = $a, iD = ic;
function UE(t) {
  var e = new eD.default(t), r = t.load, n = t.hash, i = t.bypass, a = t.itemMaxAge, s = t.freeze, o = t.clone, l = t.queueMaxAge || 1e3, u = /* @__PURE__ */ new Map(), f = new tD.EventEmitter(), y = Object.assign({
    del: m,
    reset: function() {
      return e.reset();
    },
    keys: e.keys.bind(e),
    on: f.on.bind(f),
    once: f.once.bind(f)
  }, t);
  if (t.disable)
    return Object.assign(r, y);
  function m() {
    for (var c = [], E = 0; E < arguments.length; E++)
      c[E] = arguments[E];
    var v = n.apply(void 0, Qt(c));
    e.del(v);
  }
  function p(c, E, v) {
    s && v.forEach(nD.deepFreeze), a ? e.set(c, v, a.apply(void 0, Qt(E.concat(v)))) : e.set(c, v);
  }
  function S(c, E) {
    var v, R;
    try {
      for (var N = ZO(c), C = N.next(); !C.done; C = N.next()) {
        var h = C.value;
        o ? setImmediate.apply(void 0, Qt([h], E.map(rD.default))) : setImmediate.apply(void 0, Qt([h], E));
      }
    } catch (d) {
      v = { error: d };
    } finally {
      try {
        C && !C.done && (R = N.return) && R.call(N);
      } finally {
        if (v) throw v.error;
      }
    }
  }
  function A(c) {
    for (var E = [], v = 1; v < arguments.length; v++)
      E[v - 1] = arguments[v];
    f.emit.apply(f, Qt([c], E));
  }
  function I() {
    for (var c = [], E = 0; E < arguments.length; E++)
      c[E] = arguments[E];
    var v = c.slice(0, -1), R = c.slice(-1).pop(), N;
    if (i && i.apply(void 0, Qt(v)))
      return A.apply(void 0, Qt(["miss"], v)), r.apply(void 0, Qt(c));
    v.length === 0 && !n ? N = "_" : N = n.apply(void 0, Qt(v));
    var C = e.get(N);
    if (C)
      return A.apply(void 0, Qt(["hit"], v)), S([R], [null].concat(C));
    var h = u.get(N);
    if (h && h.expiresAt > Date.now()) {
      h.queue.push(R), A.apply(void 0, Qt(["queue"], v));
      return;
    }
    A.apply(void 0, Qt(["miss"], v));
    var d = Date.now(), O = [R];
    u.set(N, {
      queue: O,
      expiresAt: d + l
    });
    var P = function() {
      for (var L = [], D = 0; D < arguments.length; D++)
        L[D] = arguments[D];
      var V = L[0];
      V || p(N, v, L.slice(1)), u.delete(N), A.apply(void 0, Qt(["loaded", Date.now() - d], v)), S(O, L);
    };
    r.apply(void 0, Qt(v, [P]));
  }
  return Object.assign(I, y);
}
nc.asyncMemoizer = UE;
UE.sync = iD.syncMemoizer;
var aD = nc, sD = aD.asyncMemoizer;
const oD = rd("jwks"), cD = sD, { promisify: uD, callbackify: lD } = ge;
function fD(t, { cacheMaxEntries: e = 5, cacheMaxAge: r = 6e5 }) {
  return oD(`Configured caching of signing keys. Max: ${e} / Age: ${r}`), uD(cD({
    hash: (n) => n,
    load: lD(t.getSigningKey.bind(t)),
    maxAge: r,
    max: e
  }));
}
xE.default = fD;
var FE = {}, yd = {}, ME = function(t, e, r, n) {
  if (this.bucketSize = t, this.tokensPerInterval = e, typeof r == "string")
    switch (r) {
      case "sec":
      case "second":
        this.interval = 1e3;
        break;
      case "min":
      case "minute":
        this.interval = 1e3 * 60;
        break;
      case "hr":
      case "hour":
        this.interval = 1e3 * 60 * 60;
        break;
      case "day":
        this.interval = 1e3 * 60 * 60 * 24;
        break;
      default:
        throw new Error("Invaid interval " + r);
    }
  else
    this.interval = r;
  this.parentBucket = n, this.content = 0, this.lastDrip = +/* @__PURE__ */ new Date();
};
ME.prototype = {
  bucketSize: 1,
  tokensPerInterval: 1,
  interval: 1e3,
  parentBucket: null,
  content: 0,
  lastDrip: 0,
  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * bucket (and any parent buckets) contains enough tokens this will happen
   * immediately. Otherwise, the removal and callback will happen when enough
   * tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(t, e) {
    var r = this;
    if (!this.bucketSize)
      return process.nextTick(e.bind(null, null, t, Number.POSITIVE_INFINITY)), !0;
    if (t > this.bucketSize)
      return process.nextTick(e.bind(null, "Requested tokens " + t + " exceeds bucket size " + this.bucketSize, null)), !1;
    if (this.drip(), t > this.content)
      return n();
    if (this.parentBucket)
      return this.parentBucket.removeTokens(t, function(i, a) {
        if (i) return e(i, null);
        if (t > r.content)
          return n();
        r.content -= t, e(null, Math.min(a, r.content));
      });
    return this.content -= t, process.nextTick(e.bind(null, null, this.content)), !0;
    function n() {
      var i = Math.ceil(
        (t - r.content) * (r.interval / r.tokensPerInterval)
      );
      return setTimeout(function() {
        r.removeTokens(t, e);
      }, i), !1;
    }
  },
  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens this will
   * return true, otherwise false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(t) {
    return this.bucketSize ? t > this.bucketSize || (this.drip(), t > this.content) || this.parentBucket && !this.parentBucket.tryRemoveTokens(t) ? !1 : (this.content -= t, !0) : !0;
  },
  /**
   * Add any new tokens to the bucket since the last drip.
   * @returns {Boolean} True if new tokens were added, otherwise false.
   */
  drip: function() {
    if (!this.tokensPerInterval) {
      this.content = this.bucketSize;
      return;
    }
    var t = +/* @__PURE__ */ new Date(), e = Math.max(t - this.lastDrip, 0);
    this.lastDrip = t;
    var r = e * (this.tokensPerInterval / this.interval);
    this.content = Math.min(this.content + r, this.bucketSize);
  }
};
var VE = ME, dD = function() {
  if (typeof process < "u" && process.hrtime) {
    var t = process.hrtime(), e = t[0], r = t[1];
    return e * 1e3 + Math.floor(r / 1e6);
  }
  return (/* @__PURE__ */ new Date()).getTime();
}, hD = dD, pD = VE, jl = hD, $E = function(t, e, r) {
  this.tokenBucket = new pD(
    t,
    t,
    e,
    null
  ), this.tokenBucket.content = t, this.curIntervalStart = jl(), this.tokensThisInterval = 0, this.fireImmediately = r;
};
$E.prototype = {
  tokenBucket: null,
  curIntervalStart: 0,
  tokensThisInterval: 0,
  fireImmediately: !1,
  /**
   * Remove the requested number of tokens and fire the given callback. If the
   * rate limiter contains enough tokens and we haven't spent too many tokens
   * in this interval already, this will happen immediately. Otherwise, the
   * removal and callback will happen when enough tokens become available.
   * @param {Number} count The number of tokens to remove.
   * @param {Function} callback(err, remainingTokens)
   * @returns {Boolean} True if the callback was fired immediately, otherwise
   *  false.
   */
  removeTokens: function(t, e) {
    if (t > this.tokenBucket.bucketSize)
      return process.nextTick(e.bind(
        null,
        "Requested tokens " + t + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
        null
      )), !1;
    var r = this, n = jl();
    if ((n < this.curIntervalStart || n - this.curIntervalStart >= this.tokenBucket.interval) && (this.curIntervalStart = n, this.tokensThisInterval = 0), t > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
      if (this.fireImmediately)
        process.nextTick(e.bind(null, null, -1));
      else {
        var i = Math.ceil(
          this.curIntervalStart + this.tokenBucket.interval - n
        );
        setTimeout(function() {
          r.tokenBucket.removeTokens(t, a);
        }, i);
      }
      return !1;
    }
    return this.tokenBucket.removeTokens(t, a);
    function a(s, o) {
      if (s) return e(s, null);
      r.tokensThisInterval += t, e(null, o);
    }
  },
  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens and we
   * haven't spent too many tokens in this interval already, this will return
   * true. Otherwise, false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens: function(t) {
    if (t > this.tokenBucket.bucketSize)
      return !1;
    var e = jl();
    if ((e < this.curIntervalStart || e - this.curIntervalStart >= this.tokenBucket.interval) && (this.curIntervalStart = e, this.tokensThisInterval = 0), t > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
      return !1;
    var r = this.tokenBucket.tryRemoveTokens(t);
    return r && (this.tokensThisInterval += t), r;
  },
  /**
   * Returns the number of tokens remaining in the TokenBucket.
   * @returns {Number} The number of tokens remaining.
   */
  getTokensRemaining: function() {
    return this.tokenBucket.drip(), this.tokenBucket.content;
  }
};
var gD = $E;
yd.RateLimiter = gD;
yd.TokenBucket = VE;
function zs(t) {
  Error.call(this, t), Error.captureStackTrace(this, this.constructor), this.name = "JwksRateLimitError", this.message = t;
}
zs.prototype = Object.create(Error.prototype);
zs.prototype.constructor = zs;
var HE = zs;
const il = rd("jwks"), { RateLimiter: yD } = yd, mD = HE;
function ED(t, { jwksRequestsPerMinute: e = 10 }) {
  const r = t.getSigningKey.bind(t), n = new yD(e, "minute", !0);
  return il(`Configured rate limiting to JWKS endpoint at ${e}/minute`), async (i) => await new Promise((a, s) => {
    n.removeTokens(1, async (o, l) => {
      if (o && s(o), il("Requests to the JWKS endpoint available for the next minute:", l), l < 0)
        il("Too many requests to the JWKS endpoint"), s(new mD("Too many requests to the JWKS endpoint"));
      else
        try {
          const u = await r(i);
          a(u);
        } catch (u) {
          s(u);
        }
    });
  });
}
FE.default = ED;
var KE = {};
const vD = RE.retrieveSigningKeys;
function AD(t, { getKeysInterceptor: e }) {
  const r = t.getSigningKey.bind(t);
  return async (n) => {
    const i = await e();
    let a;
    if (i && i.length && (a = await vD(i)), a && a.length) {
      const s = a.find((o) => !n || o.kid === n);
      if (s)
        return s;
    }
    return r(n);
  };
}
KE.default = AD;
var GE = {};
const { callbackify: CD } = ge, _D = (t) => {
  const e = t.getSigningKey.bind(t);
  return (r, n) => n ? CD(e)(r, n) : e(r);
};
GE.default = _D;
var SD = {
  request: NE.default,
  cacheSigningKey: xE.default,
  rateLimitSigningKey: FE.default,
  getKeysInterceptor: KE.default,
  callbackSupport: GE.default
};
function Xs(t) {
  Error.call(this, t), Error.captureStackTrace(this, this.constructor), this.name = "SigningKeyNotFoundError", this.message = t;
}
Xs.prototype = Object.create(Error.prototype);
Xs.prototype.constructor = Xs;
var jE = Xs;
const Bn = rd("jwks"), { retrieveSigningKeys: ID } = RE, { request: bD, cacheSigningKey: wD, rateLimitSigningKey: TD, getKeysInterceptor: RD, callbackSupport: ND } = SD, al = gd, D0 = jE;
let xD = class {
  constructor(e) {
    this.options = {
      rateLimit: !1,
      cache: !0,
      timeout: 3e4,
      ...e
    }, this.options.getKeysInterceptor && (this.getSigningKey = RD(this, e)), this.options.rateLimit && (this.getSigningKey = TD(this, e)), this.options.cache && (this.getSigningKey = wD(this, e)), this.getSigningKey = ND(this, e);
  }
  async getKeys() {
    Bn(`Fetching keys from '${this.options.jwksUri}'`);
    try {
      const e = await bD({
        uri: this.options.jwksUri,
        headers: this.options.requestHeaders,
        agent: this.options.requestAgent,
        timeout: this.options.timeout,
        fetcher: this.options.fetcher
      });
      return Bn("Keys:", e.keys), e.keys;
    } catch (e) {
      const { errorMsg: r } = e;
      throw Bn("Failure:", r || e), r ? new al(r) : e;
    }
  }
  async getSigningKeys() {
    const e = await this.getKeys();
    if (!e || !e.length)
      throw new al("The JWKS endpoint did not contain any keys");
    const r = await ID(e);
    if (!r.length)
      throw new al("The JWKS endpoint did not contain any signing keys");
    return Bn("Signing Keys:", r), r;
  }
  async getSigningKey(e) {
    Bn(`Fetching signing key for '${e}'`);
    const r = await this.getSigningKeys(), n = e != null;
    if (!n && r.length > 1)
      throw Bn("No KID specified and JWKS endpoint returned more than 1 key"), new D0("No KID specified and JWKS endpoint returned more than 1 key");
    const i = r.find((a) => !n || a.kid === e);
    if (i)
      return i;
    throw Bn(`Unable to find a signing key that matches '${e}'`), new D0(`Unable to find a signing key that matches '${e}'`);
  }
};
var Ha = {
  JwksClient: xD
};
function Ys(t) {
  Error.call(this, t), Error.captureStackTrace(this, this.constructor), this.name = "ArgumentError", this.message = t;
}
Ys.prototype = Object.create(Error.prototype);
Ys.prototype.constructor = Ys;
var OD = Ys, Ka = {
  ArgumentError: OD,
  JwksError: gd,
  JwksRateLimitError: HE,
  SigningKeyNotFoundError: jE
}, qE = { exports: {} };
const DD = [
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES256K",
  "ES384",
  "ES512",
  "EdDSA"
];
var ac = DD;
(function(t) {
  const { ArgumentError: e } = Ka, { JwksClient: r } = Ha, n = ac, i = (a, s) => {
    if (a && a.name === "SigningKeyNotFoundError" || a)
      return s(a, null, null);
  };
  t.exports.hapiJwt2KeyAsync = (a) => {
    const s = t.exports.hapiJwt2Key(a);
    return function(o) {
      return new Promise((l, u) => {
        s(o, (y, m) => {
          !m || y ? u(y) : l({ key: m });
        });
      });
    };
  }, t.exports.hapiJwt2Key = function(a) {
    if (a == null)
      throw new e("An options object must be provided when initializing hapiJwt2Key");
    const s = new r(a), o = a.handleSigningKeyError || i;
    return function(u, f) {
      if (!u || !u.header)
        return f(new Error("Cannot find a signing certificate if there is no header"), null, null);
      if (!n.includes(u.header.alg))
        return f(new Error("Unsupported algorithm " + u.header.alg + " supplied."), null, null);
      s.getSigningKey(u.header.kid).then((y) => f(null, y.publicKey || y.rsaPublicKey, y)).catch((y) => o(y, (m) => f(m, null, null)));
    };
  };
})(qE);
var LD = qE.exports, WE = {};
const { ArgumentError: PD } = Ka, { JwksClient: kD } = Ha, BD = ac, UD = (t, e) => {
  if (t && t.name === "SigningKeyNotFoundError")
    return e(null);
  if (t)
    return e(t);
};
WE.expressJwtSecret = function(t) {
  if (t == null)
    throw new PD("An options object must be provided when initializing expressJwtSecret");
  const e = new kD(t), r = t.handleSigningKeyError || UD, n = async (i, a) => {
    if (!a)
      return;
    const s = a.header;
    if (!(!s || !BD.includes(s.alg)))
      try {
        const o = await e.getSigningKey(s.kid);
        return o.publicKey || o.rsaPublicKey;
      } catch (o) {
        return new Promise((l, u) => {
          r(o, (f) => {
            if (!f)
              return l();
            u(f);
          });
        });
      }
  };
  return function(a, s, o, l) {
    if (arguments.length === 4) {
      n(a, { header: s }).then((u) => {
        setImmediate(l, null, u);
      }).catch((u) => {
        setImmediate(l, u);
      });
      return;
    }
    return n(a, arguments[1]);
  };
};
var JE = {};
const { ArgumentError: FD } = Ka, { JwksClient: MD } = Ha, VD = ac;
JE.koaJwtSecret = function(t = {}) {
  if (!t.jwksUri)
    throw new FD("No JWKS provided. Please provide a jwksUri");
  const e = new MD(t);
  return function({ alg: n, kid: i } = {}) {
    return new Promise((a, s) => {
      if (!VD.includes(n))
        return s(new Error("Missing / invalid token algorithm"));
      e.getSigningKey(i).then((o) => {
        a(o.publicKey || o.rsaPublicKey);
      }).catch((o) => t.handleSigningKeyError ? t.handleSigningKeyError(o).then(s) : s(o));
    });
  };
};
var zE = {};
const L0 = TE, { ArgumentError: P0 } = Ka, { JwksClient: $D } = Ha, HD = ac, KD = (t, e) => {
  if (t && t.name === "SigningKeyNotFoundError")
    return e(null);
  if (t)
    return e(t);
};
zE.passportJwtSecret = function(t) {
  if (t == null)
    throw new P0("An options object must be provided when initializing passportJwtSecret");
  if (!t.jwksUri)
    throw new P0("No JWKS provided. Please provide a jwksUri");
  const e = new $D(t), r = t.handleSigningKeyError || KD;
  return function(i, a, s) {
    let o;
    try {
      o = {
        payload: L0.decodeJwt(a),
        header: L0.decodeProtectedHeader(a)
      };
    } catch {
      o = null;
    }
    if (!o || !HD.includes(o.header.alg))
      return s(null, null);
    e.getSigningKey(o.header.kid).then((l) => {
      s(null, l.publicKey || l.rsaPublicKey);
    }).catch((l) => {
      r(l, (u) => s(u, null));
    });
  };
};
const { JwksClient: XE } = Ha, sc = Ka, { hapiJwt2Key: GD, hapiJwt2KeyAsync: jD } = LD, { expressJwtSecret: qD } = WE, { koaJwtSecret: WD } = JE, { passportJwtSecret: JD } = zE;
Cr.exports = (t) => new XE(t);
Cr.exports.JwksClient = XE;
Cr.exports.ArgumentError = sc.ArgumentError;
Cr.exports.JwksError = sc.JwksError;
Cr.exports.JwksRateLimitError = sc.JwksRateLimitError;
Cr.exports.SigningKeyNotFoundError = sc.SigningKeyNotFoundError;
Cr.exports.expressJwtSecret = qD;
Cr.exports.hapiJwt2Key = GD;
Cr.exports.hapiJwt2KeyAsync = jD;
Cr.exports.koaJwtSecret = WD;
Cr.exports.passportJwtSecret = JD;
var zD = Cr.exports;
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.JwtErrorCode = t.JwtError = t.EmulatorSignatureVerifier = t.PublicKeySignatureVerifier = t.UrlKeyFetcher = t.JwksFetcher = t.ALGORITHM_RS256 = void 0, t.verifyJwtSignature = S, t.decodeJwt = A;
  const e = Ue, r = c2, n = zD, i = tt;
  t.ALGORITHM_RS256 = "RS256";
  const a = "error in secret or public key callback: ", s = "no-matching-kid-error", o = "no-kid-in-header-error", l = 3600;
  class u {
    constructor(v, R) {
      if (this.publicKeysExpireAt = 0, !e.isURL(v))
        throw new Error("The provided JWKS URL is not a valid URL.");
      this.client = n({
        jwksUri: v,
        cache: !1,
        // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.
        requestAgent: R
      });
    }
    fetchPublicKeys() {
      return this.shouldRefresh() ? this.refresh() : Promise.resolve(this.publicKeys);
    }
    shouldRefresh() {
      return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
    }
    refresh() {
      return this.client.getSigningKeys().then((v) => {
        this.publicKeysExpireAt = 0;
        const R = v.reduce((N, C) => (N[C.kid] = C.getPublicKey(), N), {});
        return this.publicKeysExpireAt = Date.now() + l * 6 * 1e3, this.publicKeys = R, R;
      }).catch((v) => {
        throw new Error(`Error fetching Json Web Keys: ${v.message}`);
      });
    }
  }
  t.JwksFetcher = u;
  class f {
    constructor(v, R) {
      if (this.clientCertUrl = v, this.httpAgent = R, this.publicKeysExpireAt = 0, !e.isURL(v))
        throw new Error("The provided public client certificate URL is not a valid URL.");
    }
    /**
     * Fetches the public keys for the Google certs.
     *
     * @returns A promise fulfilled with public keys for the Google certs.
     */
    fetchPublicKeys() {
      return this.shouldRefresh() ? this.refresh() : Promise.resolve(this.publicKeys);
    }
    /**
     * Checks if the cached public keys need to be refreshed.
     *
     * @returns Whether the keys should be fetched from the client certs url or not.
     */
    shouldRefresh() {
      return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
    }
    refresh() {
      const v = new i.HttpClient(), R = {
        method: "GET",
        url: this.clientCertUrl,
        httpAgent: this.httpAgent
      };
      return v.send(R).then((N) => {
        if (!N.isJson() || N.data.error)
          throw new i.RequestResponseError(N);
        return this.publicKeysExpireAt = 0, Object.prototype.hasOwnProperty.call(N.headers, "cache-control") && N.headers["cache-control"].split(",").forEach((d) => {
          const O = d.trim().split("=");
          if (O[0] === "max-age") {
            const P = +O[1];
            this.publicKeysExpireAt = Date.now() + P * 1e3;
          }
        }), this.publicKeys = N.data, N.data;
      }).catch((N) => {
        if (N instanceof i.RequestResponseError) {
          let C = "Error fetching public keys for Google certs: ";
          const h = N.response;
          throw h.isJson() && h.data.error ? (C += `${h.data.error}`, h.data.error_description && (C += " (" + h.data.error_description + ")")) : C += `${h.text}`, new Error(C);
        }
        throw N;
      });
    }
  }
  t.UrlKeyFetcher = f;
  class y {
    constructor(v) {
      if (this.keyFetcher = v, !e.isNonNullObject(v))
        throw new Error("The provided key fetcher is not an object or null.");
    }
    static withCertificateUrl(v, R) {
      return new y(new f(v, R));
    }
    static withJwksUrl(v, R) {
      return new y(new u(v, R));
    }
    verify(v) {
      return e.isString(v) ? S(v, p(this.keyFetcher), { algorithms: [t.ALGORITHM_RS256] }).catch((R) => {
        if (R.code === c.NO_KID_IN_HEADER)
          return this.verifyWithoutKid(v);
        throw R;
      }) : Promise.reject(new I(c.INVALID_ARGUMENT, "The provided token must be a string."));
    }
    verifyWithoutKid(v) {
      return this.keyFetcher.fetchPublicKeys().then((R) => this.verifyWithAllKeys(v, R));
    }
    verifyWithAllKeys(v, R) {
      const N = [];
      return Object.values(R).forEach((C) => {
        const h = S(v, C).then(() => !0).catch((d) => {
          if (d.code === c.TOKEN_EXPIRED)
            throw d;
          return !1;
        });
        N.push(h);
      }), Promise.all(N).then((C) => {
        if (C.every((h) => h === !1))
          throw new I(c.INVALID_SIGNATURE, "Invalid token signature.");
      });
    }
  }
  t.PublicKeySignatureVerifier = y;
  class m {
    verify(v) {
      return S(v, void 0, { algorithms: ["none"] });
    }
  }
  t.EmulatorSignatureVerifier = m;
  function p(E) {
    return (v, R) => {
      v.kid || R(new Error(o));
      const N = v.kid || "";
      E.fetchPublicKeys().then((C) => {
        Object.prototype.hasOwnProperty.call(C, N) ? R(null, C[N]) : R(new Error(s));
      }).catch((C) => {
        R(C);
      });
    };
  }
  function S(E, v, R) {
    return e.isString(E) ? new Promise((N, C) => {
      r.verify(E, v, R, (h) => {
        if (!h)
          return N();
        if (h.name === "TokenExpiredError")
          return C(new I(c.TOKEN_EXPIRED, "The provided token has expired. Get a fresh token from your client app and try again."));
        if (h.name === "JsonWebTokenError" && h.message && h.message.includes(a)) {
          const d = h.message.split(a).pop() || "Error fetching public keys.";
          let O = c.KEY_FETCH_ERROR;
          return d === s ? O = c.NO_MATCHING_KID : d === o && (O = c.NO_KID_IN_HEADER), C(new I(O, d));
        }
        return C(new I(c.INVALID_SIGNATURE, h.message));
      });
    }) : Promise.reject(new I(c.INVALID_ARGUMENT, "The provided token must be a string."));
  }
  function A(E) {
    if (!e.isString(E))
      return Promise.reject(new I(c.INVALID_ARGUMENT, "The provided token must be a string."));
    const v = r.decode(E, {
      complete: !0
    });
    if (!v)
      return Promise.reject(new I(c.INVALID_ARGUMENT, "Decoding token failed."));
    const R = v == null ? void 0 : v.header, N = v == null ? void 0 : v.payload;
    return Promise.resolve({ header: R, payload: N });
  }
  class I extends Error {
    constructor(v, R) {
      super(R), this.code = v, this.message = R, this.__proto__ = I.prototype;
    }
  }
  t.JwtError = I;
  var c;
  (function(E) {
    E.INVALID_ARGUMENT = "invalid-argument", E.INVALID_CREDENTIAL = "invalid-credential", E.TOKEN_EXPIRED = "token-expired", E.INVALID_SIGNATURE = "invalid-token", E.NO_MATCHING_KID = "no-matching-kid-error", E.NO_KID_IN_HEADER = "no-kid-error", E.KEY_FETCH_ERROR = "key-fetch-error";
  })(c || (t.JwtErrorCode = c = {}));
})(tm);
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.FirebaseTokenVerifier = t.SESSION_COOKIE_INFO = t.AUTH_BLOCKING_TOKEN_INFO = t.ID_TOKEN_INFO = void 0, t.createIdTokenVerifier = f, t.createAuthBlockingTokenVerifier = y, t.createSessionCookieVerifier = m;
  const e = Te, r = at, n = Ue, i = tm, a = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit", s = "https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com", o = "https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys", l = new i.EmulatorSignatureVerifier();
  t.ID_TOKEN_INFO = {
    url: "https://firebase.google.com/docs/auth/admin/verify-id-tokens",
    verifyApiName: "verifyIdToken()",
    jwtName: "Firebase ID token",
    shortName: "ID token",
    expiredErrorCode: e.AuthClientErrorCode.ID_TOKEN_EXPIRED
  }, t.AUTH_BLOCKING_TOKEN_INFO = {
    url: "https://cloud.google.com/identity-platform/docs/blocking-functions",
    verifyApiName: "_verifyAuthBlockingToken()",
    jwtName: "Firebase Auth Blocking token",
    shortName: "Auth Blocking token",
    expiredErrorCode: e.AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED
  }, t.SESSION_COOKIE_INFO = {
    url: "https://firebase.google.com/docs/auth/admin/manage-cookies",
    verifyApiName: "verifySessionCookie()",
    jwtName: "Firebase session cookie",
    shortName: "session cookie",
    expiredErrorCode: e.AuthClientErrorCode.SESSION_COOKIE_EXPIRED
  };
  class u {
    constructor(S, A, I, c) {
      if (this.issuer = A, this.tokenInfo = I, this.app = c, n.isURL(S))
        if (n.isURL(A))
          if (n.isNonNullObject(I))
            if (n.isURL(I.url))
              if (n.isNonEmptyString(I.verifyApiName))
                if (n.isNonEmptyString(I.jwtName))
                  if (n.isNonEmptyString(I.shortName)) {
                    if (!n.isNonNullObject(I.expiredErrorCode) || !("code" in I.expiredErrorCode))
                      throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT expiration error code must be a non-null ErrorInfo object.");
                  } else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public short name must be a non-empty string.");
                else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public full name must be a non-empty string.");
              else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT verify API name must be a non-empty string.");
            else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT verification documentation URL is invalid.");
          else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT information is not an object or null.");
        else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT issuer is an invalid URL.");
      else throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, "The provided public client certificate URL is an invalid URL.");
      this.shortNameArticle = I.shortName.charAt(0).match(/[aeiou]/i) ? "an" : "a", this.signatureVerifier = i.PublicKeySignatureVerifier.withCertificateUrl(S, c.options.httpAgent);
    }
    /**
     * Verifies the format and signature of a Firebase Auth JWT token.
     *
     * @param jwtToken - The Firebase Auth JWT token to verify.
     * @param isEmulator - Whether to accept Auth Emulator tokens.
     * @returns A promise fulfilled with the decoded claims of the Firebase Auth ID token.
     */
    verifyJWT(S, A = !1) {
      if (!n.isString(S))
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
      return this.ensureProjectId().then((I) => this.decodeAndVerify(S, I, A)).then((I) => {
        const c = I.payload;
        return c.uid = c.sub, c;
      });
    }
    /** @alpha */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _verifyAuthBlockingToken(S, A, I) {
      if (!n.isString(S))
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
      return this.ensureProjectId().then((c) => (typeof I > "u" && (I = `${c}.cloudfunctions.net/`), this.decodeAndVerify(S, c, A, I))).then((c) => {
        const E = c.payload;
        return E.uid = E.sub, E;
      });
    }
    ensureProjectId() {
      return r.findProjectId(this.app).then((S) => {
        if (!n.isNonEmptyString(S))
          throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_CREDENTIAL, `Must initialize app with a cert credential or set your Firebase project ID as the GOOGLE_CLOUD_PROJECT environment variable to call ${this.tokenInfo.verifyApiName}.`);
        return Promise.resolve(S);
      });
    }
    decodeAndVerify(S, A, I, c) {
      return this.safeDecode(S).then((E) => (this.verifyContent(E, A, I, c), this.verifySignature(S, I).then(() => E)));
    }
    safeDecode(S) {
      return (0, i.decodeJwt)(S).catch((A) => {
        if (A.code === i.JwtErrorCode.INVALID_ARGUMENT) {
          const I = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`, c = `Decoding ${this.tokenInfo.jwtName} failed. Make sure you passed the entire string JWT which represents ${this.shortNameArticle} ${this.tokenInfo.shortName}.` + I;
          throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, c);
        }
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INTERNAL_ERROR, A.message);
      });
    }
    /**
     * Verifies the content of a Firebase Auth JWT.
     *
     * @param fullDecodedToken - The decoded JWT.
     * @param projectId - The Firebase Project Id.
     * @param isEmulator - Whether the token is an Emulator token.
     */
    verifyContent(S, A, I, c) {
      const E = S && S.header, v = S && S.payload, R = ` Make sure the ${this.tokenInfo.shortName} comes from the same Firebase project as the service account used to authenticate this SDK.`, N = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
      let C;
      if (!I && typeof E.kid > "u") {
        const h = v.aud === a, d = E.alg === "HS256" && v.v === 0 && "d" in v && "uid" in v.d;
        h ? C = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a custom token.` : d ? C = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a legacy custom token.` : C = `${this.tokenInfo.jwtName} has no "kid" claim.`, C += N;
      } else !I && E.alg !== i.ALGORITHM_RS256 ? C = `${this.tokenInfo.jwtName} has incorrect algorithm. Expected "` + i.ALGORITHM_RS256 + '" but got "' + E.alg + '".' + N : typeof c < "u" && !v.aud.includes(c) ? C = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + c + '" but got "' + v.aud + '".' + N : typeof c > "u" && v.aud !== A ? C = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + A + '" but got "' + v.aud + '".' + R + N : v.iss !== this.issuer + A ? C = `${this.tokenInfo.jwtName} has incorrect "iss" (issuer) claim. Expected "${this.issuer}` + A + '" but got "' + v.iss + '".' + R + N : v.event_type !== void 0 && (v.event_type === "beforeSendSms" || v.event_type === "beforeSendEmail") || (typeof v.sub != "string" ? C = `${this.tokenInfo.jwtName} has no "sub" (subject) claim.` + N : v.sub === "" ? C = `${this.tokenInfo.jwtName} has an empty "sub" (subject) claim.` + N : v.sub.length > 128 && (C = `${this.tokenInfo.jwtName} has a "sub" (subject) claim longer than 128 characters.` + N));
      if (C)
        throw new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, C);
    }
    verifySignature(S, A) {
      return (A ? l : this.signatureVerifier).verify(S).catch((c) => {
        throw this.mapJwtErrorToAuthError(c);
      });
    }
    /**
     * Maps JwtError to FirebaseAuthError
     *
     * @param error - JwtError to be mapped.
     * @returns FirebaseAuthError or Error instance.
     */
    mapJwtErrorToAuthError(S) {
      const A = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
      if (S.code === i.JwtErrorCode.TOKEN_EXPIRED) {
        const I = `${this.tokenInfo.jwtName} has expired. Get a fresh ${this.tokenInfo.shortName} from your client app and try again (auth/${this.tokenInfo.expiredErrorCode.code}).` + A;
        return new e.FirebaseAuthError(this.tokenInfo.expiredErrorCode, I);
      } else if (S.code === i.JwtErrorCode.INVALID_SIGNATURE) {
        const I = `${this.tokenInfo.jwtName} has invalid signature.` + A;
        return new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, I);
      } else if (S.code === i.JwtErrorCode.NO_MATCHING_KID) {
        const I = `${this.tokenInfo.jwtName} has "kid" claim which does not correspond to a known public key. Most likely the ${this.tokenInfo.shortName} is expired, so get a fresh token from your client app and try again.`;
        return new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, I);
      }
      return new e.FirebaseAuthError(e.AuthClientErrorCode.INVALID_ARGUMENT, S.message);
    }
  }
  t.FirebaseTokenVerifier = u;
  function f(p) {
    return new u(s, "https://securetoken.google.com/", t.ID_TOKEN_INFO, p);
  }
  function y(p) {
    return new u(s, "https://securetoken.google.com/", t.AUTH_BLOCKING_TOKEN_INFO, p);
  }
  function m(p) {
    return new u(o, "https://session.firebase.google.com/", t.SESSION_COOKIE_INFO, p);
  }
})(em);
var bt = {};
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.UserRecord = bt.UserInfo = bt.UserMetadata = bt.MultiFactorSettings = bt.TotpMultiFactorInfo = bt.TotpInfo = bt.PhoneMultiFactorInfo = bt.MultiFactorInfo = void 0;
const XD = vr, YD = Ue, Me = at, wn = Te, QD = Buffer.from("REDACTED").toString("base64");
function ql(t) {
  try {
    const e = new Date(parseInt(t, 10));
    if (!isNaN(e.getTime()))
      return e.toUTCString();
  } catch {
  }
  return null;
}
var Qs;
(function(t) {
  t.Phone = "phone", t.Totp = "totp";
})(Qs || (Qs = {}));
class oc {
  /**
   * Initializes the MultiFactorInfo associated subclass using the server side.
   * If no MultiFactorInfo is associated with the response, null is returned.
   *
   * @param response - The server side response.
   * @internal
   */
  static initMultiFactorInfo(e) {
    let r = null;
    try {
      e.phoneInfo !== void 0 ? r = new YE(e) : e.totpInfo !== void 0 && (r = new QE(e));
    } catch {
    }
    return r;
  }
  /**
   * Initializes the MultiFactorInfo object using the server side response.
   *
   * @param response - The server side response.
   * @constructor
   * @internal
   */
  constructor(e) {
    this.initFromServerResponse(e);
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    return {
      uid: this.uid,
      displayName: this.displayName,
      factorId: this.factorId,
      enrollmentTime: this.enrollmentTime
    };
  }
  /**
   * Initializes the MultiFactorInfo object using the provided server response.
   *
   * @param response - The server side response.
   */
  initFromServerResponse(e) {
    const r = e && this.getFactorId(e);
    if (!r || !e || !e.mfaEnrollmentId)
      throw new wn.FirebaseAuthError(wn.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor info response");
    Me.addReadonlyGetter(this, "uid", e.mfaEnrollmentId), Me.addReadonlyGetter(this, "factorId", r), Me.addReadonlyGetter(this, "displayName", e.displayName), e.enrolledAt ? Me.addReadonlyGetter(this, "enrollmentTime", new Date(e.enrolledAt).toUTCString()) : Me.addReadonlyGetter(this, "enrollmentTime", null);
  }
}
bt.MultiFactorInfo = oc;
class YE extends oc {
  /**
   * Initializes the PhoneMultiFactorInfo object using the server side response.
   *
   * @param response - The server side response.
   * @constructor
   * @internal
   */
  constructor(e) {
    super(e), Me.addReadonlyGetter(this, "phoneNumber", e.phoneInfo);
  }
  /**
   * {@inheritdoc MultiFactorInfo.toJSON}
   */
  toJSON() {
    return Object.assign(super.toJSON(), {
      phoneNumber: this.phoneNumber
    });
  }
  /**
   * Returns the factor ID based on the response provided.
   *
   * @param response - The server side response.
   * @returns The multi-factor ID associated with the provided response. If the response is
   *     not associated with any known multi-factor ID, null is returned.
   *
   * @internal
   */
  getFactorId(e) {
    return e && e.phoneInfo ? Qs.Phone : null;
  }
}
bt.PhoneMultiFactorInfo = YE;
class ZD {
}
bt.TotpInfo = ZD;
class QE extends oc {
  /**
   * Initializes the `TotpMultiFactorInfo` object using the server side response.
   *
   * @param response - The server side response.
   * @constructor
   * @internal
   */
  constructor(e) {
    super(e), Me.addReadonlyGetter(this, "totpInfo", e.totpInfo);
  }
  /**
   * {@inheritdoc MultiFactorInfo.toJSON}
   */
  toJSON() {
    return Object.assign(super.toJSON(), {
      totpInfo: this.totpInfo
    });
  }
  /**
   * Returns the factor ID based on the response provided.
   *
   * @param response - The server side response.
   * @returns The multi-factor ID associated with the provided response. If the response is
   *     not associated with any known multi-factor ID, `null` is returned.
   *
   * @internal
   */
  getFactorId(e) {
    return e && e.totpInfo ? Qs.Totp : null;
  }
}
bt.TotpMultiFactorInfo = QE;
class ZE {
  /**
   * Initializes the `MultiFactor` object using the server side or JWT format response.
   *
   * @param response - The server side response.
   * @constructor
   * @internal
   */
  constructor(e) {
    const r = [];
    if ((0, YD.isNonNullObject)(e))
      e.mfaInfo && e.mfaInfo.forEach((n) => {
        const i = oc.initMultiFactorInfo(n);
        i && r.push(i);
      });
    else throw new wn.FirebaseAuthError(wn.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor response");
    Me.addReadonlyGetter(this, "enrolledFactors", Object.freeze(r));
  }
  /**
   * Returns a JSON-serializable representation of this multi-factor object.
   *
   * @returns A JSON-serializable representation of this multi-factor object.
   */
  toJSON() {
    return {
      enrolledFactors: this.enrolledFactors.map((e) => e.toJSON())
    };
  }
}
bt.MultiFactorSettings = ZE;
class ev {
  /**
   * @param response - The server side response returned from the `getAccountInfo`
   *     endpoint.
   * @constructor
   * @internal
   */
  constructor(e) {
    Me.addReadonlyGetter(this, "creationTime", ql(e.createdAt)), Me.addReadonlyGetter(this, "lastSignInTime", ql(e.lastLoginAt));
    const r = e.lastRefreshAt ? new Date(e.lastRefreshAt).toUTCString() : null;
    Me.addReadonlyGetter(this, "lastRefreshTime", r);
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    return {
      lastSignInTime: this.lastSignInTime,
      creationTime: this.creationTime,
      lastRefreshTime: this.lastRefreshTime
    };
  }
}
bt.UserMetadata = ev;
class tv {
  /**
   * @param response - The server side response returned from the `getAccountInfo`
   *     endpoint.
   * @constructor
   * @internal
   */
  constructor(e) {
    if (!e.rawId || !e.providerId)
      throw new wn.FirebaseAuthError(wn.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user info response");
    Me.addReadonlyGetter(this, "uid", e.rawId), Me.addReadonlyGetter(this, "displayName", e.displayName), Me.addReadonlyGetter(this, "email", e.email), Me.addReadonlyGetter(this, "photoURL", e.photoUrl), Me.addReadonlyGetter(this, "providerId", e.providerId), Me.addReadonlyGetter(this, "phoneNumber", e.phoneNumber);
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    return {
      uid: this.uid,
      displayName: this.displayName,
      email: this.email,
      photoURL: this.photoURL,
      providerId: this.providerId,
      phoneNumber: this.phoneNumber
    };
  }
}
bt.UserInfo = tv;
class eL {
  /**
   * @param response - The server side response returned from the getAccountInfo
   *     endpoint.
   * @constructor
   * @internal
   */
  constructor(e) {
    if (!e.localId)
      throw new wn.FirebaseAuthError(wn.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user response");
    Me.addReadonlyGetter(this, "uid", e.localId), Me.addReadonlyGetter(this, "email", e.email), Me.addReadonlyGetter(this, "emailVerified", !!e.emailVerified), Me.addReadonlyGetter(this, "displayName", e.displayName), Me.addReadonlyGetter(this, "photoURL", e.photoUrl), Me.addReadonlyGetter(this, "phoneNumber", e.phoneNumber), Me.addReadonlyGetter(this, "disabled", e.disabled || !1), Me.addReadonlyGetter(this, "metadata", new ev(e));
    const r = [];
    for (const a of e.providerUserInfo || [])
      r.push(new tv(a));
    Me.addReadonlyGetter(this, "providerData", r), e.passwordHash === QD ? Me.addReadonlyGetter(this, "passwordHash", void 0) : Me.addReadonlyGetter(this, "passwordHash", e.passwordHash), Me.addReadonlyGetter(this, "passwordSalt", e.salt), e.customAttributes && Me.addReadonlyGetter(this, "customClaims", JSON.parse(e.customAttributes));
    let n = null;
    typeof e.validSince < "u" && (n = ql(parseInt(e.validSince, 10) * 1e3)), Me.addReadonlyGetter(this, "tokensValidAfterTime", n || void 0), Me.addReadonlyGetter(this, "tenantId", e.tenantId);
    const i = new ZE(e);
    i.enrolledFactors.length > 0 && Me.addReadonlyGetter(this, "multiFactor", i);
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns A JSON-serializable representation of this object.
   */
  toJSON() {
    const e = {
      uid: this.uid,
      email: this.email,
      emailVerified: this.emailVerified,
      displayName: this.displayName,
      photoURL: this.photoURL,
      phoneNumber: this.phoneNumber,
      disabled: this.disabled,
      // Convert metadata to json.
      metadata: this.metadata.toJSON(),
      passwordHash: this.passwordHash,
      passwordSalt: this.passwordSalt,
      customClaims: (0, XD.deepCopy)(this.customClaims),
      tokensValidAfterTime: this.tokensValidAfterTime,
      tenantId: this.tenantId
    };
    this.multiFactor && (e.multiFactor = this.multiFactor.toJSON()), e.providerData = [];
    for (const r of this.providerData)
      e.providerData.push(r.toJSON());
    return e;
  }
}
bt.UserRecord = eL;
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(si, "__esModule", { value: !0 });
si.BaseAuth = void 0;
si.createFirebaseTokenGenerator = rv;
const xe = Te, tL = vr, Un = Ue, Ss = La, sl = Xy, ol = em, Vt = Ba, vi = bt, ds = ai, rL = hr;
function rv(t, e) {
  try {
    const r = (0, Ss.useEmulator)() ? new sl.EmulatedSigner() : (0, rL.cryptoSignerFromApp)(t);
    return new sl.FirebaseTokenGenerator(r, e);
  } catch (r) {
    throw (0, sl.handleCryptoSignerError)(r);
  }
}
class nL {
  /**
   * The BaseAuth class constructor.
   *
   * @param app - The FirebaseApp to associate with this Auth instance.
   * @param authRequestHandler - The RPC request handler for this instance.
   * @param tokenGenerator - Optional token generator. If not specified, a
   *     (non-tenant-aware) instance will be created. Use this paramter to
   *     specify a tenant-aware tokenGenerator.
   * @constructor
   * @internal
   */
  constructor(e, r, n) {
    this.authRequestHandler = r, n ? this.tokenGenerator = n : this.tokenGenerator = rv(e), this.sessionCookieVerifier = (0, ol.createSessionCookieVerifier)(e), this.idTokenVerifier = (0, ol.createIdTokenVerifier)(e), this.authBlockingTokenVerifier = (0, ol.createAuthBlockingTokenVerifier)(e);
  }
  /**
   * Creates a new Firebase custom token (JWT) that can be sent back to a client
   * device to use to sign in with the client SDKs' `signInWithCustomToken()`
   * methods. (Tenant-aware instances will also embed the tenant ID in the
   * token.)
   *
   * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}
   * for code samples and detailed documentation.
   *
   * @param uid - The `uid` to use as the custom token's subject.
   * @param developerClaims - Optional additional claims to include
   *   in the custom token's payload.
   *
   * @returns A promise fulfilled with a custom token for the
   *   provided `uid` and payload.
   */
  createCustomToken(e, r) {
    return this.tokenGenerator.createCustomToken(e, r);
  }
  /**
   * Verifies a Firebase ID token (JWT). If the token is valid, the promise is
   * fulfilled with the token's decoded claims; otherwise, the promise is
   * rejected.
   *
   * If `checkRevoked` is set to true, first verifies whether the corresponding
   * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,
   * verifies if the session corresponding to the ID token was revoked. If the
   * corresponding user's session was invalidated, an `auth/id-token-revoked`
   * error is thrown. If not specified the check is not applied.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}
   * for code samples and detailed documentation.
   *
   * @param idToken - The ID token to verify.
   * @param checkRevoked - Whether to check if the ID token was revoked.
   *   This requires an extra request to the Firebase Auth backend to check
   *   the `tokensValidAfterTime` time for the corresponding user.
   *   When not specified, this additional check is not applied.
   *
   * @returns A promise fulfilled with the
   *   token's decoded claims if the ID token is valid; otherwise, a rejected
   *   promise.
   */
  verifyIdToken(e, r = !1) {
    const n = (0, Ss.useEmulator)();
    return this.idTokenVerifier.verifyJWT(e, n).then((i) => r || n ? this.verifyDecodedJWTNotRevokedOrDisabled(i, xe.AuthClientErrorCode.ID_TOKEN_REVOKED) : i);
  }
  /**
   * Gets the user data for the user corresponding to a given `uid`.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
   * for code samples and detailed documentation.
   *
   * @param uid - The `uid` corresponding to the user whose data to fetch.
   *
   * @returns A promise fulfilled with the user
   *   data corresponding to the provided `uid`.
   */
  getUser(e) {
    return this.authRequestHandler.getAccountInfoByUid(e).then((r) => new vi.UserRecord(r.users[0]));
  }
  /**
   * Gets the user data for the user corresponding to a given email.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
   * for code samples and detailed documentation.
   *
   * @param email - The email corresponding to the user whose data to
   *   fetch.
   *
   * @returns A promise fulfilled with the user
   *   data corresponding to the provided email.
   */
  getUserByEmail(e) {
    return this.authRequestHandler.getAccountInfoByEmail(e).then((r) => new vi.UserRecord(r.users[0]));
  }
  /**
   * Gets the user data for the user corresponding to a given phone number. The
   * phone number has to conform to the E.164 specification.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
   * for code samples and detailed documentation.
   *
   * @param phoneNumber - The phone number corresponding to the user whose
   *   data to fetch.
   *
   * @returns A promise fulfilled with the user
   *   data corresponding to the provided phone number.
   */
  getUserByPhoneNumber(e) {
    return this.authRequestHandler.getAccountInfoByPhoneNumber(e).then((r) => new vi.UserRecord(r.users[0]));
  }
  /**
   * Gets the user data for the user corresponding to a given provider id.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
   * for code samples and detailed documentation.
   *
   * @param providerId - The provider ID, for example, "google.com" for the
   *   Google provider.
   * @param uid - The user identifier for the given provider.
   *
   * @returns A promise fulfilled with the user data corresponding to the
   *   given provider id.
   */
  getUserByProviderUid(e, r) {
    return e === "phone" ? this.getUserByPhoneNumber(r) : e === "email" ? this.getUserByEmail(r) : this.authRequestHandler.getAccountInfoByFederatedUid(e, r).then((n) => new vi.UserRecord(n.users[0]));
  }
  /**
   * Gets the user data corresponding to the specified identifiers.
   *
   * There are no ordering guarantees; in particular, the nth entry in the result list is not
   * guaranteed to correspond to the nth entry in the input parameters list.
   *
   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,
   * this method throws a FirebaseAuthError.
   *
   * @param identifiers - The identifiers used to indicate which user records should be returned.
   *     Must not have more than 100 entries.
   * @returns A promise that resolves to the corresponding user records.
   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100
   *     identifiers are specified.
   */
  getUsers(e) {
    if (!Un.isArray(e))
      throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, "`identifiers` parameter must be an array");
    return this.authRequestHandler.getAccountInfoByIdentifiers(e).then((r) => {
      const n = (s, o) => !!o.find((l) => {
        if ((0, ds.isUidIdentifier)(s))
          return s.uid === l.uid;
        if ((0, ds.isEmailIdentifier)(s))
          return s.email === l.email;
        if ((0, ds.isPhoneIdentifier)(s))
          return s.phoneNumber === l.phoneNumber;
        if ((0, ds.isProviderIdentifier)(s)) {
          const u = l.providerData.find((f) => s.providerId === f.providerId);
          return !!u && s.providerUid === u.uid;
        } else
          throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INTERNAL_ERROR, "Unhandled identifier type");
      }), i = r.users ? r.users.map((s) => new vi.UserRecord(s)) : [], a = e.filter((s) => !n(s, i));
      return { users: i, notFound: a };
    });
  }
  /**
   * Retrieves a list of users (single batch only) with a size of `maxResults`
   * starting from the offset as specified by `pageToken`. This is used to
   * retrieve all the users of a specified project in batches.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}
   * for code samples and detailed documentation.
   *
   * @param maxResults - The page size, 1000 if undefined. This is also
   *   the maximum allowed limit.
   * @param pageToken - The next page token. If not specified, returns
   *   users starting without any offset.
   * @returns A promise that resolves with
   *   the current batch of downloaded users and the next page token.
   */
  listUsers(e, r) {
    return this.authRequestHandler.downloadAccount(e, r).then((n) => {
      const i = [];
      n.users.forEach((s) => {
        i.push(new vi.UserRecord(s));
      });
      const a = {
        users: i,
        pageToken: n.nextPageToken
      };
      return typeof a.pageToken > "u" && delete a.pageToken, a;
    });
  }
  /**
   * Creates a new user.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}
   * for code samples and detailed documentation.
   *
   * @param properties - The properties to set on the
   *   new user record to be created.
   *
   * @returns A promise fulfilled with the user
   *   data corresponding to the newly created user.
   */
  createUser(e) {
    return this.authRequestHandler.createNewAccount(e).then((r) => this.getUser(r)).catch((r) => {
      throw r.code === "auth/user-not-found" ? new xe.FirebaseAuthError(xe.AuthClientErrorCode.INTERNAL_ERROR, "Unable to create the user record provided.") : r;
    });
  }
  /**
   * Deletes an existing user.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}
   * for code samples and detailed documentation.
   *
   * @param uid - The `uid` corresponding to the user to delete.
   *
   * @returns An empty promise fulfilled once the user has been
   *   deleted.
   */
  deleteUser(e) {
    return this.authRequestHandler.deleteAccount(e).then(() => {
    });
  }
  /**
   * Deletes the users specified by the given uids.
   *
   * Deleting a non-existing user won't generate an error (i.e. this method
   * is idempotent.) Non-existing users are considered to be successfully
   * deleted, and are therefore counted in the
   * `DeleteUsersResult.successCount` value.
   *
   * Only a maximum of 1000 identifiers may be supplied. If more than 1000
   * identifiers are supplied, this method throws a FirebaseAuthError.
   *
   * This API is currently rate limited at the server to 1 QPS. If you exceed
   * this, you may get a quota exceeded error. Therefore, if you want to
   * delete more than 1000 users, you may need to add a delay to ensure you
   * don't go over this limit.
   *
   * @param uids - The `uids` corresponding to the users to delete.
   *
   * @returns A Promise that resolves to the total number of successful/failed
   *     deletions, as well as the array of errors that corresponds to the
   *     failed deletions.
   */
  deleteUsers(e) {
    if (!Un.isArray(e))
      throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, "`uids` parameter must be an array");
    return this.authRequestHandler.deleteAccounts(
      e,
      /*force=*/
      !0
    ).then((r) => {
      const n = {
        failureCount: 0,
        successCount: e.length,
        errors: []
      };
      return Un.isNonEmptyArray(r.errors) && (n.failureCount = r.errors.length, n.successCount = e.length - r.errors.length, n.errors = r.errors.map((i) => {
        if (i.index === void 0)
          throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INTERNAL_ERROR, "Corrupt BatchDeleteAccountsResponse detected");
        const a = (s) => {
          const o = s && s.startsWith("NOT_DISABLED") ? xe.AuthClientErrorCode.USER_NOT_DISABLED : xe.AuthClientErrorCode.INTERNAL_ERROR;
          return new xe.FirebaseAuthError(o, i.message);
        };
        return {
          index: i.index,
          error: a(i.message)
        };
      })), n;
    });
  }
  /**
   * Updates an existing user.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}
   * for code samples and detailed documentation.
   *
   * @param uid - The `uid` corresponding to the user to update.
   * @param properties - The properties to update on
   *   the provided user.
   *
   * @returns A promise fulfilled with the
   *   updated user data.
   */
  updateUser(e, r) {
    if (r = (0, tL.deepCopy)(r), r != null && r.providerToLink) {
      if (r.providerToLink.providerId === "email") {
        if (typeof r.email < "u")
          throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To link to the email/password provider, only specify the UpdateRequest.email field.");
        r.email = r.providerToLink.uid, delete r.providerToLink;
      } else if (r.providerToLink.providerId === "phone") {
        if (typeof r.phoneNumber < "u")
          throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To link to a phone provider, only specify the UpdateRequest.phoneNumber field.");
        r.phoneNumber = r.providerToLink.uid, delete r.providerToLink;
      }
    }
    if (r != null && r.providersToUnlink && r.providersToUnlink.indexOf("phone") !== -1 && r.phoneNumber === null)
      throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.");
    return this.authRequestHandler.updateExistingAccount(e, r).then((n) => this.getUser(n));
  }
  /**
   * Sets additional developer claims on an existing user identified by the
   * provided `uid`, typically used to define user roles and levels of
   * access. These claims should propagate to all devices where the user is
   * already signed in (after token expiration or when token refresh is forced)
   * and the next time the user signs in. If a reserved OIDC claim name
   * is used (sub, iat, iss, etc), an error is thrown. They are set on the
   * authenticated user's ID token JWT.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |
   * Defining user roles and access levels}
   * for code samples and detailed documentation.
   *
   * @param uid - The `uid` of the user to edit.
   * @param customUserClaims - The developer claims to set. If null is
   *   passed, existing custom claims are deleted. Passing a custom claims payload
   *   larger than 1000 bytes will throw an error. Custom claims are added to the
   *   user's ID token which is transmitted on every authenticated request.
   *   For profile non-access related user attributes, use database or other
   *   separate storage systems.
   * @returns A promise that resolves when the operation completes
   *   successfully.
   */
  setCustomUserClaims(e, r) {
    return this.authRequestHandler.setCustomUserClaims(e, r).then(() => {
    });
  }
  /**
   * Revokes all refresh tokens for an existing user.
   *
   * This API will update the user's {@link UserRecord.tokensValidAfterTime} to
   * the current UTC. It is important that the server on which this is called has
   * its clock set correctly and synchronized.
   *
   * While this will revoke all sessions for a specified user and disable any
   * new ID tokens for existing sessions from getting minted, existing ID tokens
   * may remain active until their natural expiration (one hour). To verify that
   * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}
   * where `checkRevoked` is set to true.
   *
   * @param uid - The `uid` corresponding to the user whose refresh tokens
   *   are to be revoked.
   *
   * @returns An empty promise fulfilled once the user's refresh
   *   tokens have been revoked.
   */
  revokeRefreshTokens(e) {
    return this.authRequestHandler.revokeRefreshTokens(e).then(() => {
    });
  }
  /**
   * Imports the provided list of users into Firebase Auth.
   * A maximum of 1000 users are allowed to be imported one at a time.
   * When importing users with passwords,
   * {@link UserImportOptions} are required to be
   * specified.
   * This operation is optimized for bulk imports and will ignore checks on `uid`,
   * `email` and other identifier uniqueness which could result in duplications.
   *
   * @param users - The list of user records to import to Firebase Auth.
   * @param options - The user import options, required when the users provided include
   *   password credentials.
   * @returns A promise that resolves when
   *   the operation completes with the result of the import. This includes the
   *   number of successful imports, the number of failed imports and their
   *   corresponding errors.
  */
  importUsers(e, r) {
    return this.authRequestHandler.uploadAccount(e, r);
  }
  /**
   * Creates a new Firebase session cookie with the specified options. The created
   * JWT string can be set as a server-side session cookie with a custom cookie
   * policy, and be used for session management. The session cookie JWT will have
   * the same payload claims as the provided ID token.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}
   * for code samples and detailed documentation.
   *
   * @param idToken - The Firebase ID token to exchange for a session
   *   cookie.
   * @param sessionCookieOptions - The session
   *   cookie options which includes custom session duration.
   *
   * @returns A promise that resolves on success with the
   *   created session cookie.
   */
  createSessionCookie(e, r) {
    return !Un.isNonNullObject(r) || !Un.isNumber(r.expiresIn) ? Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION)) : this.authRequestHandler.createSessionCookie(e, r.expiresIn);
  }
  /**
   * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.
   * Rejects the promise if the cookie could not be verified.
   *
   * If `checkRevoked` is set to true, first verifies whether the corresponding
   * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,
   * verifies if the session corresponding to the session cookie was revoked.
   * If the corresponding user's session was invalidated, an
   * `auth/session-cookie-revoked` error is thrown. If not specified the check
   * is not performed.
   *
   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |
   * Verify Session Cookies}
   * for code samples and detailed documentation
   *
   * @param sessionCookie - The session cookie to verify.
   * @param checkForRevocation -  Whether to check if the session cookie was
   *   revoked. This requires an extra request to the Firebase Auth backend to
   *   check the `tokensValidAfterTime` time for the corresponding user.
   *   When not specified, this additional check is not performed.
   *
   * @returns A promise fulfilled with the
   *   session cookie's decoded claims if the session cookie is valid; otherwise,
   *   a rejected promise.
   */
  verifySessionCookie(e, r = !1) {
    const n = (0, Ss.useEmulator)();
    return this.sessionCookieVerifier.verifyJWT(e, n).then((i) => r || n ? this.verifyDecodedJWTNotRevokedOrDisabled(i, xe.AuthClientErrorCode.SESSION_COOKIE_REVOKED) : i);
  }
  /**
   * Generates the out of band email action link to reset a user's password.
   * The link is generated for the user with the specified email address. The
   * optional  {@link ActionCodeSettings} object
   * defines whether the link is to be handled by a mobile app or browser and the
   * additional state information to be passed in the deep link, etc.
   *
   * @example
   * ```javascript
   * var actionCodeSettings = {
   *   url: 'https://www.example.com/?email=user@example.com',
   *   iOS: {
   *     bundleId: 'com.example.ios'
   *   },
   *   android: {
   *     packageName: 'com.example.android',
   *     installApp: true,
   *     minimumVersion: '12'
   *   },
   *   handleCodeInApp: true,
   *   linkDomain: 'project-id.firebaseapp.com'
   * };
   * admin.auth()
   *     .generatePasswordResetLink('user@example.com', actionCodeSettings)
   *     .then(function(link) {
   *       // The link was successfully generated.
   *     })
   *     .catch(function(error) {
   *       // Some error occurred, you can inspect the code: error.code
   *     });
   * ```
   *
   * @param email - The email address of the user whose password is to be
   *   reset.
   * @param actionCodeSettings - The action
   *     code settings. If specified, the state/continue URL is set as the
   *     "continueUrl" parameter in the password reset link. The default password
   *     reset landing page will use this to display a link to go back to the app
   *     if it is installed.
   *     If the actionCodeSettings is not specified, no URL is appended to the
   *     action URL.
   *     The state URL provided must belong to a domain that is whitelisted by the
   *     developer in the console. Otherwise an error is thrown.
   *     Mobile app redirects are only applicable if the developer configures
   *     and accepts the Firebase Dynamic Links terms of service.
   *     The Android package name and iOS bundle ID are respected only if they
   *     are configured in the same Firebase Auth project.
   * @returns A promise that resolves with the generated link.
   */
  generatePasswordResetLink(e, r) {
    return this.authRequestHandler.getEmailActionLink("PASSWORD_RESET", e, r);
  }
  /**
   * Generates the out of band email action link to verify the user's ownership
   * of the specified email. The {@link ActionCodeSettings} object provided
   * as an argument to this method defines whether the link is to be handled by a
   * mobile app or browser along with additional state information to be passed in
   * the deep link, etc.
   *
   * @example
   * ```javascript
   * var actionCodeSettings = {
   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
   *   iOS: {
   *     bundleId: 'com.example.ios'
   *   },
   *   android: {
   *     packageName: 'com.example.android',
   *     installApp: true,
   *     minimumVersion: '12'
   *   },
   *   handleCodeInApp: true,
   *   linkDomain: 'project-id.firebaseapp.com'
   * };
   * admin.auth()
   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
   *     .then(function(link) {
   *       // The link was successfully generated.
   *     })
   *     .catch(function(error) {
   *       // Some error occurred, you can inspect the code: error.code
   *     });
   * ```
   *
   * @param email - The email account to verify.
   * @param actionCodeSettings - The action
   *     code settings. If specified, the state/continue URL is set as the
   *     "continueUrl" parameter in the email verification link. The default email
   *     verification landing page will use this to display a link to go back to
   *     the app if it is installed.
   *     If the actionCodeSettings is not specified, no URL is appended to the
   *     action URL.
   *     The state URL provided must belong to a domain that is whitelisted by the
   *     developer in the console. Otherwise an error is thrown.
   *     Mobile app redirects are only applicable if the developer configures
   *     and accepts the Firebase Dynamic Links terms of service.
   *     The Android package name and iOS bundle ID are respected only if they
   *     are configured in the same Firebase Auth project.
   * @returns A promise that resolves with the generated link.
   */
  generateEmailVerificationLink(e, r) {
    return this.authRequestHandler.getEmailActionLink("VERIFY_EMAIL", e, r);
  }
  /**
   * Generates an out-of-band email action link to verify the user's ownership
   * of the specified email. The {@link ActionCodeSettings} object provided
   * as an argument to this method defines whether the link is to be handled by a
   * mobile app or browser along with additional state information to be passed in
   * the deep link, etc.
   *
   * @param email - The current email account.
   * @param newEmail - The email address the account is being updated to.
   * @param actionCodeSettings - The action
   *     code settings. If specified, the state/continue URL is set as the
   *     "continueUrl" parameter in the email verification link. The default email
   *     verification landing page will use this to display a link to go back to
   *     the app if it is installed.
   *     If the actionCodeSettings is not specified, no URL is appended to the
   *     action URL.
   *     The state URL provided must belong to a domain that is authorized
   *     in the console, or an error will be thrown.
   *     Mobile app redirects are only applicable if the developer configures
   *     and accepts the Firebase Dynamic Links terms of service.
   *     The Android package name and iOS bundle ID are respected only if they
   *     are configured in the same Firebase Auth project.
   * @returns A promise that resolves with the generated link.
   */
  generateVerifyAndChangeEmailLink(e, r, n) {
    return this.authRequestHandler.getEmailActionLink("VERIFY_AND_CHANGE_EMAIL", e, n, r);
  }
  /**
   * Generates the out of band email action link to verify the user's ownership
   * of the specified email. The {@link ActionCodeSettings} object provided
   * as an argument to this method defines whether the link is to be handled by a
   * mobile app or browser along with additional state information to be passed in
   * the deep link, etc.
   *
   * @example
   * ```javascript
   * var actionCodeSettings = {
   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
   *   iOS: {
   *     bundleId: 'com.example.ios'
   *   },
   *   android: {
   *     packageName: 'com.example.android',
   *     installApp: true,
   *     minimumVersion: '12'
   *   },
   *   handleCodeInApp: true,
   *   linkDomain: 'project-id.firebaseapp.com'
   * };
   * admin.auth()
   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
   *     .then(function(link) {
   *       // The link was successfully generated.
   *     })
   *     .catch(function(error) {
   *       // Some error occurred, you can inspect the code: error.code
   *     });
   * ```
   *
   * @param email - The email account to verify.
   * @param actionCodeSettings - The action
   *     code settings. If specified, the state/continue URL is set as the
   *     "continueUrl" parameter in the email verification link. The default email
   *     verification landing page will use this to display a link to go back to
   *     the app if it is installed.
   *     If the actionCodeSettings is not specified, no URL is appended to the
   *     action URL.
   *     The state URL provided must belong to a domain that is whitelisted by the
   *     developer in the console. Otherwise an error is thrown.
   *     Mobile app redirects are only applicable if the developer configures
   *     and accepts the Firebase Dynamic Links terms of service.
   *     The Android package name and iOS bundle ID are respected only if they
   *     are configured in the same Firebase Auth project.
   * @returns A promise that resolves with the generated link.
   */
  generateSignInWithEmailLink(e, r) {
    return this.authRequestHandler.getEmailActionLink("EMAIL_SIGNIN", e, r);
  }
  /**
   * Returns the list of existing provider configurations matching the filter
   * provided. At most, 100 provider configs can be listed at a time.
   *
   * SAML and OIDC provider support requires Google Cloud's Identity Platform
   * (GCIP). To learn more about GCIP, including pricing and features,
   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
   *
   * @param options - The provider config filter to apply.
   * @returns A promise that resolves with the list of provider configs meeting the
   *   filter requirements.
   */
  listProviderConfigs(e) {
    const r = (n, i) => {
      const a = {
        providerConfigs: i
      };
      return Object.prototype.hasOwnProperty.call(n, "nextPageToken") && (a.pageToken = n.nextPageToken), a;
    };
    return e && e.type === "oidc" ? this.authRequestHandler.listOAuthIdpConfigs(e.maxResults, e.pageToken).then((n) => {
      const i = [];
      return n.oauthIdpConfigs.forEach((a) => {
        i.push(new Vt.OIDCConfig(a));
      }), r(n, i);
    }) : e && e.type === "saml" ? this.authRequestHandler.listInboundSamlConfigs(e.maxResults, e.pageToken).then((n) => {
      const i = [];
      return n.inboundSamlConfigs.forEach((a) => {
        i.push(new Vt.SAMLConfig(a));
      }), r(n, i);
    }) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_ARGUMENT, '"AuthProviderConfigFilter.type" must be either "saml" or "oidc"'));
  }
  /**
   * Looks up an Auth provider configuration by the provided ID.
   * Returns a promise that resolves with the provider configuration
   * corresponding to the provider ID specified. If the specified ID does not
   * exist, an `auth/configuration-not-found` error is thrown.
   *
   * SAML and OIDC provider support requires Google Cloud's Identity Platform
   * (GCIP). To learn more about GCIP, including pricing and features,
   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
   *
   * @param providerId - The provider ID corresponding to the provider
   *     config to return.
   * @returns A promise that resolves
   *     with the configuration corresponding to the provided ID.
   */
  getProviderConfig(e) {
    return Vt.OIDCConfig.isProviderId(e) ? this.authRequestHandler.getOAuthIdpConfig(e).then((r) => new Vt.OIDCConfig(r)) : Vt.SAMLConfig.isProviderId(e) ? this.authRequestHandler.getInboundSamlConfig(e).then((r) => new Vt.SAMLConfig(r)) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_PROVIDER_ID));
  }
  /**
   * Deletes the provider configuration corresponding to the provider ID passed.
   * If the specified ID does not exist, an `auth/configuration-not-found` error
   * is thrown.
   *
   * SAML and OIDC provider support requires Google Cloud's Identity Platform
   * (GCIP). To learn more about GCIP, including pricing and features,
   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
   *
   * @param providerId - The provider ID corresponding to the provider
   *     config to delete.
   * @returns A promise that resolves on completion.
   */
  deleteProviderConfig(e) {
    return Vt.OIDCConfig.isProviderId(e) ? this.authRequestHandler.deleteOAuthIdpConfig(e) : Vt.SAMLConfig.isProviderId(e) ? this.authRequestHandler.deleteInboundSamlConfig(e) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_PROVIDER_ID));
  }
  /**
   * Returns a promise that resolves with the updated `AuthProviderConfig`
   * corresponding to the provider ID specified.
   * If the specified ID does not exist, an `auth/configuration-not-found` error
   * is thrown.
   *
   * SAML and OIDC provider support requires Google Cloud's Identity Platform
   * (GCIP). To learn more about GCIP, including pricing and features,
   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
   *
   * @param providerId - The provider ID corresponding to the provider
   *     config to update.
   * @param updatedConfig - The updated configuration.
   * @returns A promise that resolves with the updated provider configuration.
   */
  updateProviderConfig(e, r) {
    return Un.isNonNullObject(r) ? Vt.OIDCConfig.isProviderId(e) ? this.authRequestHandler.updateOAuthIdpConfig(e, r).then((n) => new Vt.OIDCConfig(n)) : Vt.SAMLConfig.isProviderId(e) ? this.authRequestHandler.updateInboundSamlConfig(e, r).then((n) => new Vt.SAMLConfig(n)) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_PROVIDER_ID)) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "UpdateAuthProviderRequest" configuration.'));
  }
  /**
   * Returns a promise that resolves with the newly created `AuthProviderConfig`
   * when the new provider configuration is created.
   *
   * SAML and OIDC provider support requires Google Cloud's Identity Platform
   * (GCIP). To learn more about GCIP, including pricing and features,
   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
   *
   * @param config - The provider configuration to create.
   * @returns A promise that resolves with the created provider configuration.
   */
  createProviderConfig(e) {
    return Un.isNonNullObject(e) ? Vt.OIDCConfig.isProviderId(e.providerId) ? this.authRequestHandler.createOAuthIdpConfig(e).then((r) => new Vt.OIDCConfig(r)) : Vt.SAMLConfig.isProviderId(e.providerId) ? this.authRequestHandler.createInboundSamlConfig(e).then((r) => new Vt.SAMLConfig(r)) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_PROVIDER_ID)) : Promise.reject(new xe.FirebaseAuthError(xe.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "AuthProviderConfig" configuration.'));
  }
  /** @alpha */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _verifyAuthBlockingToken(e, r) {
    const n = (0, Ss.useEmulator)();
    return this.authBlockingTokenVerifier._verifyAuthBlockingToken(e, n, r).then((i) => i);
  }
  /**
   * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that
   * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked
   * or user disabled.
   *
   * @param decodedIdToken - The JWT's decoded claims.
   * @param revocationErrorInfo - The revocation error info to throw on revocation
   *     detection.
   * @returns A promise that will be fulfilled after a successful verification.
   */
  verifyDecodedJWTNotRevokedOrDisabled(e, r) {
    return this.getUser(e.sub).then((n) => {
      if (n.disabled)
        throw new xe.FirebaseAuthError(xe.AuthClientErrorCode.USER_DISABLED, "The user record is disabled.");
      if (n.tokensValidAfterTime) {
        const i = e.auth_time * 1e3, a = new Date(n.tokensValidAfterTime).getTime();
        if (i < a)
          throw new xe.FirebaseAuthError(r);
      }
      return e;
    });
  }
}
si.BaseAuth = nL;
/*! firebase-admin v13.4.0 */
/*!
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.TenantManager = qn.TenantAwareAuth = void 0;
const Is = Ue, iL = at, $r = Te, k0 = si, hs = Hi, nv = La;
class iv extends k0.BaseAuth {
  /**
   * The TenantAwareAuth class constructor.
   *
   * @param app - The app that created this tenant.
   * @param tenantId - The corresponding tenant ID.
   * @constructor
   * @internal
   */
  constructor(e, r) {
    super(e, new nv.TenantAwareAuthRequestHandler(e, r), (0, k0.createFirebaseTokenGenerator)(e, r)), iL.addReadonlyGetter(this, "tenantId", r);
  }
  /**
   * {@inheritdoc BaseAuth.verifyIdToken}
   */
  verifyIdToken(e, r = !1) {
    return super.verifyIdToken(e, r).then((n) => {
      if (n.firebase.tenant !== this.tenantId)
        throw new $r.FirebaseAuthError($r.AuthClientErrorCode.MISMATCHING_TENANT_ID);
      return n;
    });
  }
  /**
   * {@inheritdoc BaseAuth.createSessionCookie}
   */
  createSessionCookie(e, r) {
    return Is.isNonEmptyString(e) ? !Is.isNonNullObject(r) || !Is.isNumber(r.expiresIn) ? Promise.reject(new $r.FirebaseAuthError($r.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION)) : this.verifyIdToken(e).then(() => super.createSessionCookie(e, r)) : Promise.reject(new $r.FirebaseAuthError($r.AuthClientErrorCode.INVALID_ID_TOKEN));
  }
  /**
   * {@inheritdoc BaseAuth.verifySessionCookie}
   */
  verifySessionCookie(e, r = !1) {
    return super.verifySessionCookie(e, r).then((n) => {
      if (n.firebase.tenant !== this.tenantId)
        throw new $r.FirebaseAuthError($r.AuthClientErrorCode.MISMATCHING_TENANT_ID);
      return n;
    });
  }
}
qn.TenantAwareAuth = iv;
class aL {
  /**
   * Initializes a TenantManager instance for a specified FirebaseApp.
   *
   * @param app - The app for this TenantManager instance.
   *
   * @constructor
   * @internal
   */
  constructor(e) {
    this.app = e, this.authRequestHandler = new nv.AuthRequestHandler(e), this.tenantsMap = {};
  }
  /**
   * Returns a `TenantAwareAuth` instance bound to the given tenant ID.
   *
   * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.
   *
   * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.
   */
  authForTenant(e) {
    if (!Is.isNonEmptyString(e))
      throw new $r.FirebaseAuthError($r.AuthClientErrorCode.INVALID_TENANT_ID);
    return typeof this.tenantsMap[e] > "u" && (this.tenantsMap[e] = new iv(this.app, e)), this.tenantsMap[e];
  }
  /**
   * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.
   *
   * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.
   *
   * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.
   */
  getTenant(e) {
    return this.authRequestHandler.getTenant(e).then((r) => new hs.Tenant(r));
  }
  /**
   * Retrieves a list of tenants (single batch only) with a size of `maxResults`
   * starting from the offset as specified by `pageToken`. This is used to
   * retrieve all the tenants of a specified project in batches.
   *
   * @param maxResults - The page size, 1000 if undefined. This is also
   *   the maximum allowed limit.
   * @param pageToken - The next page token. If not specified, returns
   *   tenants starting without any offset.
   *
   * @returns A promise that resolves with
   *   a batch of downloaded tenants and the next page token.
   */
  listTenants(e, r) {
    return this.authRequestHandler.listTenants(e, r).then((n) => {
      const i = [];
      n.tenants.forEach((s) => {
        i.push(new hs.Tenant(s));
      });
      const a = {
        tenants: i,
        pageToken: n.nextPageToken
      };
      return typeof a.pageToken > "u" && delete a.pageToken, a;
    });
  }
  /**
   * Deletes an existing tenant.
   *
   * @param tenantId - The `tenantId` corresponding to the tenant to delete.
   *
   * @returns An empty promise fulfilled once the tenant has been deleted.
   */
  deleteTenant(e) {
    return this.authRequestHandler.deleteTenant(e);
  }
  /**
   * Creates a new tenant.
   * When creating new tenants, tenants that use separate billing and quota will require their
   * own project and must be defined as `full_service`.
   *
   * @param tenantOptions - The properties to set on the new tenant configuration to be created.
   *
   * @returns A promise fulfilled with the tenant configuration corresponding to the newly
   *   created tenant.
   */
  createTenant(e) {
    return this.authRequestHandler.createTenant(e).then((r) => new hs.Tenant(r));
  }
  /**
   * Updates an existing tenant configuration.
   *
   * @param tenantId - The `tenantId` corresponding to the tenant to delete.
   * @param tenantOptions - The properties to update on the provided tenant.
   *
   * @returns A promise fulfilled with the update tenant data.
   */
  updateTenant(e, r) {
    return this.authRequestHandler.updateTenant(e, r).then((n) => new hs.Tenant(n));
  }
}
qn.TenantManager = aL;
var Ga = {};
/*! firebase-admin v13.4.0 */
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.ProjectConfigManager = void 0;
const B0 = Ki, sL = La;
class oL {
  /**
   * Initializes a ProjectConfigManager instance for a specified FirebaseApp.
   *
   * @param app - The app for this ProjectConfigManager instance.
   *
   * @constructor
   * @internal
   */
  constructor(e) {
    this.authRequestHandler = new sL.AuthRequestHandler(e);
  }
  /**
   * Get the project configuration.
   *
   * @returns A promise fulfilled with the project configuration.
   */
  getProjectConfig() {
    return this.authRequestHandler.getProjectConfig().then((e) => new B0.ProjectConfig(e));
  }
  /**
   * Updates an existing project configuration.
   *
   * @param projectConfigOptions - The properties to update on the project.
   *
   * @returns A promise fulfilled with the updated project config.
   */
  updateProjectConfig(e) {
    return this.authRequestHandler.updateProjectConfig(e).then((r) => new B0.ProjectConfig(r));
  }
}
Ga.ProjectConfigManager = oL;
/*! firebase-admin v13.4.0 */
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.Auth = void 0;
const cL = La, uL = qn, lL = si, fL = Ga;
class dL extends lL.BaseAuth {
  /**
   * @param app - The app for this Auth service.
   * @constructor
   * @internal
   */
  constructor(e) {
    super(e, new cL.AuthRequestHandler(e)), this.app_ = e, this.tenantManager_ = new uL.TenantManager(e), this.projectConfigManager_ = new fL.ProjectConfigManager(e);
  }
  /**
   * Returns the app associated with this Auth instance.
   *
   * @returns The app associated with this Auth instance.
   */
  get app() {
    return this.app_;
  }
  /**
   * Returns the tenant manager instance associated with the current project.
   *
   * @returns The tenant manager instance associated with the current project.
   */
  tenantManager() {
    return this.tenantManager_;
  }
  /**
   * Returns the project config manager instance associated with the current project.
   *
   * @returns The project config manager instance associated with the current project.
   */
  projectConfigManager() {
    return this.projectConfigManager_;
  }
}
ha.Auth = dL;
/*! firebase-admin v13.4.0 */
(function(t) {
  /*!
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AuthClientErrorCode = t.FirebaseAuthError = t.UserRecord = t.UserMetadata = t.UserInfo = t.PhoneMultiFactorInfo = t.MultiFactorSettings = t.MultiFactorInfo = t.ProjectConfigManager = t.ProjectConfig = t.TenantManager = t.TenantAwareAuth = t.Tenant = t.BaseAuth = t.Auth = void 0, t.getAuth = n;
  const e = tg, r = ha;
  function n(m) {
    return typeof m > "u" && (m = (0, e.getApp)()), m.getOrInitService("auth", (S) => new r.Auth(S));
  }
  var i = ha;
  Object.defineProperty(t, "Auth", { enumerable: !0, get: function() {
    return i.Auth;
  } });
  var a = si;
  Object.defineProperty(t, "BaseAuth", { enumerable: !0, get: function() {
    return a.BaseAuth;
  } });
  var s = Hi;
  Object.defineProperty(t, "Tenant", { enumerable: !0, get: function() {
    return s.Tenant;
  } });
  var o = qn;
  Object.defineProperty(t, "TenantAwareAuth", { enumerable: !0, get: function() {
    return o.TenantAwareAuth;
  } }), Object.defineProperty(t, "TenantManager", { enumerable: !0, get: function() {
    return o.TenantManager;
  } });
  var l = Ki;
  Object.defineProperty(t, "ProjectConfig", { enumerable: !0, get: function() {
    return l.ProjectConfig;
  } });
  var u = Ga;
  Object.defineProperty(t, "ProjectConfigManager", { enumerable: !0, get: function() {
    return u.ProjectConfigManager;
  } });
  var f = bt;
  Object.defineProperty(t, "MultiFactorInfo", { enumerable: !0, get: function() {
    return f.MultiFactorInfo;
  } }), Object.defineProperty(t, "MultiFactorSettings", { enumerable: !0, get: function() {
    return f.MultiFactorSettings;
  } }), Object.defineProperty(t, "PhoneMultiFactorInfo", { enumerable: !0, get: function() {
    return f.PhoneMultiFactorInfo;
  } }), Object.defineProperty(t, "UserInfo", { enumerable: !0, get: function() {
    return f.UserInfo;
  } }), Object.defineProperty(t, "UserMetadata", { enumerable: !0, get: function() {
    return f.UserMetadata;
  } }), Object.defineProperty(t, "UserRecord", { enumerable: !0, get: function() {
    return f.UserRecord;
  } });
  var y = Te;
  Object.defineProperty(t, "FirebaseAuthError", { enumerable: !0, get: function() {
    return y.FirebaseAuthError;
  } }), Object.defineProperty(t, "AuthClientErrorCode", { enumerable: !0, get: function() {
    return y.AuthClientErrorCode;
  } });
})(eg);
const Ht = /* @__PURE__ */ nA(eg);
Ht.Auth;
Ht.AuthClientErrorCode;
Ht.BaseAuth;
Ht.FirebaseAuthError;
Ht.MultiFactorInfo;
Ht.MultiFactorSettings;
Ht.PhoneMultiFactorInfo;
Ht.ProjectConfig;
Ht.ProjectConfigManager;
Ht.Tenant;
Ht.TenantAwareAuth;
Ht.TenantManager;
Ht.UserInfo;
Ht.UserMetadata;
Ht.UserRecord;
Ht.getAuth;
const hL = () => {
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const av = function(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++) {
    let i = t.charCodeAt(n);
    i < 128 ? e[r++] = i : i < 2048 ? (e[r++] = i >> 6 | 192, e[r++] = i & 63 | 128) : (i & 64512) === 55296 && n + 1 < t.length && (t.charCodeAt(n + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++n) & 1023), e[r++] = i >> 18 | 240, e[r++] = i >> 12 & 63 | 128, e[r++] = i >> 6 & 63 | 128, e[r++] = i & 63 | 128) : (e[r++] = i >> 12 | 224, e[r++] = i >> 6 & 63 | 128, e[r++] = i & 63 | 128);
  }
  return e;
}, pL = function(t) {
  const e = [];
  let r = 0, n = 0;
  for (; r < t.length; ) {
    const i = t[r++];
    if (i < 128)
      e[n++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const a = t[r++];
      e[n++] = String.fromCharCode((i & 31) << 6 | a & 63);
    } else if (i > 239 && i < 365) {
      const a = t[r++], s = t[r++], o = t[r++], l = ((i & 7) << 18 | (a & 63) << 12 | (s & 63) << 6 | o & 63) - 65536;
      e[n++] = String.fromCharCode(55296 + (l >> 10)), e[n++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const a = t[r++], s = t[r++];
      e[n++] = String.fromCharCode((i & 15) << 12 | (a & 63) << 6 | s & 63);
    }
  }
  return e.join("");
}, sv = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(t, e) {
    if (!Array.isArray(t))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const r = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, n = [];
    for (let i = 0; i < t.length; i += 3) {
      const a = t[i], s = i + 1 < t.length, o = s ? t[i + 1] : 0, l = i + 2 < t.length, u = l ? t[i + 2] : 0, f = a >> 2, y = (a & 3) << 4 | o >> 4;
      let m = (o & 15) << 2 | u >> 6, p = u & 63;
      l || (p = 64, s || (m = 64)), n.push(r[f], r[y], r[m], r[p]);
    }
    return n.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(av(t), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : pL(this.decodeStringToByteArray(t, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(t, e) {
    this.init_();
    const r = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, n = [];
    for (let i = 0; i < t.length; ) {
      const a = r[t.charAt(i++)], o = i < t.length ? r[t.charAt(i)] : 0;
      ++i;
      const u = i < t.length ? r[t.charAt(i)] : 64;
      ++i;
      const y = i < t.length ? r[t.charAt(i)] : 64;
      if (++i, a == null || o == null || u == null || y == null)
        throw new gL();
      const m = a << 2 | o >> 4;
      if (n.push(m), u !== 64) {
        const p = o << 4 & 240 | u >> 2;
        if (n.push(p), y !== 64) {
          const S = u << 6 & 192 | y;
          n.push(S);
        }
      }
    }
    return n;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let t = 0; t < this.ENCODED_VALS.length; t++)
        this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t);
    }
  }
};
class gL extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const yL = function(t) {
  const e = av(t);
  return sv.encodeByteArray(e, !0);
}, ov = function(t) {
  return yL(t).replace(/\./g, "");
}, mL = function(t) {
  try {
    return sv.decodeString(t, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EL() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vL = () => EL().__FIREBASE_DEFAULTS__, AL = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const t = process.env.__FIREBASE_DEFAULTS__;
  if (t)
    return JSON.parse(t);
}, CL = () => {
  if (typeof document > "u")
    return;
  let t;
  try {
    t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = t && mL(t[1]);
  return e && JSON.parse(e);
}, _L = () => {
  try {
    return hL() || vL() || AL() || CL();
  } catch (t) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
    return;
  }
}, cv = () => {
  var t;
  return (t = _L()) == null ? void 0 : t.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let SL = class {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, r) => {
      this.resolve = e, this.reject = r;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (r, n) => {
      r ? this.reject(r) : this.resolve(n), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(r) : e(r, n));
    };
  }
};
function uv() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function lv() {
  return new Promise((t, e) => {
    try {
      let r = !0;
      const n = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(n);
      i.onsuccess = () => {
        i.result.close(), r || self.indexedDB.deleteDatabase(n), t(!0);
      }, i.onupgradeneeded = () => {
        r = !1;
      }, i.onerror = () => {
        var a;
        e(((a = i.error) == null ? void 0 : a.message) || "");
      };
    } catch (r) {
      e(r);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IL = "FirebaseError";
class qi extends Error {
  constructor(e, r, n) {
    super(r), this.code = e, this.customData = n, this.name = IL, Object.setPrototypeOf(this, qi.prototype), Error.captureStackTrace && Error.captureStackTrace(this, cc.prototype.create);
  }
}
class cc {
  constructor(e, r, n) {
    this.service = e, this.serviceName = r, this.errors = n;
  }
  create(e, ...r) {
    const n = r[0] || {}, i = `${this.service}/${e}`, a = this.errors[e], s = a ? bL(a, n) : "Error", o = `${this.serviceName}: ${s} (${i}).`;
    return new qi(i, o, n);
  }
}
function bL(t, e) {
  return t.replace(wL, (r, n) => {
    const i = e[n];
    return i != null ? String(i) : `<${n}?>`;
  });
}
const wL = /\{\$([^}]+)}/g;
function Wl(t, e) {
  if (t === e)
    return !0;
  const r = Object.keys(t), n = Object.keys(e);
  for (const i of r) {
    if (!n.includes(i))
      return !1;
    const a = t[i], s = e[i];
    if (U0(a) && U0(s)) {
      if (!Wl(a, s))
        return !1;
    } else if (a !== s)
      return !1;
  }
  for (const i of n)
    if (!r.includes(i))
      return !1;
  return !0;
}
function U0(t) {
  return t !== null && typeof t == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fv(t) {
  return t && t._delegate ? t._delegate : t;
}
class zn {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, r, n) {
    this.name = e, this.instanceFactory = r, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fn = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TL {
  constructor(e, r) {
    this.name = e, this.container = r, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const r = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(r)) {
      const n = new SL();
      if (this.instancesDeferred.set(r, n), this.isInitialized(r) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: r
          });
          i && n.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(r).promise;
  }
  getImmediate(e) {
    const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier), n = (e == null ? void 0 : e.optional) ?? !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (i) {
        if (n)
          return null;
        throw i;
      }
    else {
      if (n)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (NL(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: Fn });
        } catch {
        }
      for (const [r, n] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(r);
        try {
          const a = this.getOrInitializeService({
            instanceIdentifier: i
          });
          n.resolve(a);
        } catch {
        }
      }
    }
  }
  clearInstance(e = Fn) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((r) => "INTERNAL" in r).map((r) => r.INTERNAL.delete()),
      ...e.filter((r) => "_delete" in r).map((r) => r._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = Fn) {
    return this.instances.has(e);
  }
  getOptions(e = Fn) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: r = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(n))
      throw Error(`${this.name}(${n}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: n,
      options: r
    });
    for (const [a, s] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(a);
      n === o && s.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, r) {
    const n = this.normalizeInstanceIdentifier(r), i = this.onInitCallbacks.get(n) ?? /* @__PURE__ */ new Set();
    i.add(e), this.onInitCallbacks.set(n, i);
    const a = this.instances.get(n);
    return a && e(a, n), () => {
      i.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, r) {
    const n = this.onInitCallbacks.get(r);
    if (n)
      for (const i of n)
        try {
          i(e, r);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: r = {} }) {
    let n = this.instances.get(e);
    if (!n && this.component && (n = this.component.instanceFactory(this.container, {
      instanceIdentifier: RL(e),
      options: r
    }), this.instances.set(e, n), this.instancesOptions.set(e, r), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, n);
      } catch {
      }
    return n || null;
  }
  normalizeInstanceIdentifier(e = Fn) {
    return this.component ? this.component.multipleInstances ? e : Fn : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function RL(t) {
  return t === Fn ? void 0 : t;
}
function NL(t) {
  return t.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xL {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const r = this.getProvider(e.name);
    if (r.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    r.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const r = new TL(e, this);
    return this.providers.set(e, r), r;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Qe;
(function(t) {
  t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT";
})(Qe || (Qe = {}));
const OL = {
  debug: Qe.DEBUG,
  verbose: Qe.VERBOSE,
  info: Qe.INFO,
  warn: Qe.WARN,
  error: Qe.ERROR,
  silent: Qe.SILENT
}, DL = Qe.INFO, LL = {
  [Qe.DEBUG]: "log",
  [Qe.VERBOSE]: "log",
  [Qe.INFO]: "info",
  [Qe.WARN]: "warn",
  [Qe.ERROR]: "error"
}, PL = (t, e, ...r) => {
  if (e < t.logLevel)
    return;
  const n = (/* @__PURE__ */ new Date()).toISOString(), i = LL[e];
  if (i)
    console[i](`[${n}]  ${t.name}:`, ...r);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class kL {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = DL, this._logHandler = PL, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in Qe))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? OL[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, Qe.DEBUG, ...e), this._logHandler(this, Qe.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, Qe.VERBOSE, ...e), this._logHandler(this, Qe.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, Qe.INFO, ...e), this._logHandler(this, Qe.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, Qe.WARN, ...e), this._logHandler(this, Qe.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, Qe.ERROR, ...e), this._logHandler(this, Qe.ERROR, ...e);
  }
}
const BL = (t, e) => e.some((r) => t instanceof r);
let F0, M0;
function UL() {
  return F0 || (F0 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function FL() {
  return M0 || (M0 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const dv = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), hv = /* @__PURE__ */ new WeakMap(), cl = /* @__PURE__ */ new WeakMap(), md = /* @__PURE__ */ new WeakMap();
function ML(t) {
  const e = new Promise((r, n) => {
    const i = () => {
      t.removeEventListener("success", a), t.removeEventListener("error", s);
    }, a = () => {
      r(cn(t.result)), i();
    }, s = () => {
      n(t.error), i();
    };
    t.addEventListener("success", a), t.addEventListener("error", s);
  });
  return e.then((r) => {
    r instanceof IDBCursor && dv.set(r, t);
  }).catch(() => {
  }), md.set(e, t), e;
}
function VL(t) {
  if (Jl.has(t))
    return;
  const e = new Promise((r, n) => {
    const i = () => {
      t.removeEventListener("complete", a), t.removeEventListener("error", s), t.removeEventListener("abort", s);
    }, a = () => {
      r(), i();
    }, s = () => {
      n(t.error || new DOMException("AbortError", "AbortError")), i();
    };
    t.addEventListener("complete", a), t.addEventListener("error", s), t.addEventListener("abort", s);
  });
  Jl.set(t, e);
}
let zl = {
  get(t, e, r) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return Jl.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || hv.get(t);
      if (e === "store")
        return r.objectStoreNames[1] ? void 0 : r.objectStore(r.objectStoreNames[0]);
    }
    return cn(t[e]);
  },
  set(t, e, r) {
    return t[e] = r, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function $L(t) {
  zl = t(zl);
}
function HL(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...r) {
    const n = t.call(ul(this), e, ...r);
    return hv.set(n, e.sort ? e.sort() : [e]), cn(n);
  } : FL().includes(t) ? function(...e) {
    return t.apply(ul(this), e), cn(dv.get(this));
  } : function(...e) {
    return cn(t.apply(ul(this), e));
  };
}
function KL(t) {
  return typeof t == "function" ? HL(t) : (t instanceof IDBTransaction && VL(t), BL(t, UL()) ? new Proxy(t, zl) : t);
}
function cn(t) {
  if (t instanceof IDBRequest)
    return ML(t);
  if (cl.has(t))
    return cl.get(t);
  const e = KL(t);
  return e !== t && (cl.set(t, e), md.set(e, t)), e;
}
const ul = (t) => md.get(t);
function uc(t, e, { blocked: r, upgrade: n, blocking: i, terminated: a } = {}) {
  const s = indexedDB.open(t, e), o = cn(s);
  return n && s.addEventListener("upgradeneeded", (l) => {
    n(cn(s.result), l.oldVersion, l.newVersion, cn(s.transaction), l);
  }), r && s.addEventListener("blocked", (l) => r(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), o.then((l) => {
    a && l.addEventListener("close", () => a()), i && l.addEventListener("versionchange", (u) => i(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
function ll(t, { blocked: e } = {}) {
  const r = indexedDB.deleteDatabase(t);
  return e && r.addEventListener("blocked", (n) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    n.oldVersion,
    n
  )), cn(r).then(() => {
  });
}
const GL = ["get", "getKey", "getAll", "getAllKeys", "count"], jL = ["put", "add", "delete", "clear"], fl = /* @__PURE__ */ new Map();
function V0(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (fl.get(e))
    return fl.get(e);
  const r = e.replace(/FromIndex$/, ""), n = e !== r, i = jL.includes(r);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(r in (n ? IDBIndex : IDBObjectStore).prototype) || !(i || GL.includes(r))
  )
    return;
  const a = async function(s, ...o) {
    const l = this.transaction(s, i ? "readwrite" : "readonly");
    let u = l.store;
    return n && (u = u.index(o.shift())), (await Promise.all([
      u[r](...o),
      i && l.done
    ]))[0];
  };
  return fl.set(e, a), a;
}
$L((t) => ({
  ...t,
  get: (e, r, n) => V0(e, r) || t.get(e, r, n),
  has: (e, r) => !!V0(e, r) || t.has(e, r)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qL {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((r) => {
      if (WL(r)) {
        const n = r.getImmediate();
        return `${n.library}/${n.version}`;
      } else
        return null;
    }).filter((r) => r).join(" ");
  }
}
function WL(t) {
  const e = t.getComponent();
  return (e == null ? void 0 : e.type) === "VERSION";
}
const Xl = "@firebase/app", $0 = "0.14.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const un = new kL("@firebase/app"), JL = "@firebase/app-compat", zL = "@firebase/analytics-compat", XL = "@firebase/analytics", YL = "@firebase/app-check-compat", QL = "@firebase/app-check", ZL = "@firebase/auth", eP = "@firebase/auth-compat", tP = "@firebase/database", rP = "@firebase/data-connect", nP = "@firebase/database-compat", iP = "@firebase/functions", aP = "@firebase/functions-compat", sP = "@firebase/installations", oP = "@firebase/installations-compat", cP = "@firebase/messaging", uP = "@firebase/messaging-compat", lP = "@firebase/performance", fP = "@firebase/performance-compat", dP = "@firebase/remote-config", hP = "@firebase/remote-config-compat", pP = "@firebase/storage", gP = "@firebase/storage-compat", yP = "@firebase/firestore", mP = "@firebase/ai", EP = "@firebase/firestore-compat", vP = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yl = "[DEFAULT]", AP = {
  [Xl]: "fire-core",
  [JL]: "fire-core-compat",
  [XL]: "fire-analytics",
  [zL]: "fire-analytics-compat",
  [QL]: "fire-app-check",
  [YL]: "fire-app-check-compat",
  [ZL]: "fire-auth",
  [eP]: "fire-auth-compat",
  [tP]: "fire-rtdb",
  [rP]: "fire-data-connect",
  [nP]: "fire-rtdb-compat",
  [iP]: "fire-fn",
  [aP]: "fire-fn-compat",
  [sP]: "fire-iid",
  [oP]: "fire-iid-compat",
  [cP]: "fire-fcm",
  [uP]: "fire-fcm-compat",
  [lP]: "fire-perf",
  [fP]: "fire-perf-compat",
  [dP]: "fire-rc",
  [hP]: "fire-rc-compat",
  [pP]: "fire-gcs",
  [gP]: "fire-gcs-compat",
  [yP]: "fire-fst",
  [EP]: "fire-fst-compat",
  [mP]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [vP]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zs = /* @__PURE__ */ new Map(), CP = /* @__PURE__ */ new Map(), Ql = /* @__PURE__ */ new Map();
function H0(t, e) {
  try {
    t.container.addComponent(e);
  } catch (r) {
    un.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, r);
  }
}
function ki(t) {
  const e = t.name;
  if (Ql.has(e))
    return un.debug(`There were multiple attempts to register component ${e}.`), !1;
  Ql.set(e, t);
  for (const r of Zs.values())
    H0(r, t);
  for (const r of CP.values())
    H0(r, t);
  return !0;
}
function Ed(t, e) {
  const r = t.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return r && r.triggerHeartbeat(), t.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _P = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, Sn = new cc("app", "Firebase", _P);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SP {
  constructor(e, r, n) {
    this._isDeleted = !1, this._options = { ...e }, this._config = { ...r }, this._name = r.name, this._automaticDataCollectionEnabled = r.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new zn(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Sn.create("app-deleted", { appName: this._name });
  }
}
function pv(t, e = {}) {
  let r = t;
  typeof e != "object" && (e = { name: e });
  const n = {
    name: Yl,
    automaticDataCollectionEnabled: !0,
    ...e
  }, i = n.name;
  if (typeof i != "string" || !i)
    throw Sn.create("bad-app-name", {
      appName: String(i)
    });
  if (r || (r = cv()), !r)
    throw Sn.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const a = Zs.get(i);
  if (a) {
    if (Wl(r, a.options) && Wl(n, a.config))
      return a;
    throw Sn.create("duplicate-app", { appName: i });
  }
  const s = new xL(i);
  for (const l of Ql.values())
    s.addComponent(l);
  const o = new SP(r, n, s);
  return Zs.set(i, o), o;
}
function IP(t = Yl) {
  const e = Zs.get(t);
  if (!e && t === Yl && cv())
    return pv();
  if (!e)
    throw Sn.create("no-app", { appName: t });
  return e;
}
function Ti(t, e, r) {
  let n = AP[t] ?? t;
  r && (n += `-${r}`);
  const i = n.match(/\s|\//), a = e.match(/\s|\//);
  if (i || a) {
    const s = [
      `Unable to register library "${n}" with version "${e}":`
    ];
    i && s.push(`library name "${n}" contains illegal characters (whitespace or "/")`), i && a && s.push("and"), a && s.push(`version name "${e}" contains illegal characters (whitespace or "/")`), un.warn(s.join(" "));
    return;
  }
  ki(new zn(
    `${n}-version`,
    () => ({ library: n, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bP = "firebase-heartbeat-database", wP = 1, ga = "firebase-heartbeat-store";
let dl = null;
function gv() {
  return dl || (dl = uc(bP, wP, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          try {
            t.createObjectStore(ga);
          } catch (r) {
            console.warn(r);
          }
      }
    }
  }).catch((t) => {
    throw Sn.create("idb-open", {
      originalErrorMessage: t.message
    });
  })), dl;
}
async function TP(t) {
  try {
    const r = (await gv()).transaction(ga), n = await r.objectStore(ga).get(yv(t));
    return await r.done, n;
  } catch (e) {
    if (e instanceof qi)
      un.warn(e.message);
    else {
      const r = Sn.create("idb-get", {
        originalErrorMessage: e == null ? void 0 : e.message
      });
      un.warn(r.message);
    }
  }
}
async function K0(t, e) {
  try {
    const n = (await gv()).transaction(ga, "readwrite");
    await n.objectStore(ga).put(e, yv(t)), await n.done;
  } catch (r) {
    if (r instanceof qi)
      un.warn(r.message);
    else {
      const n = Sn.create("idb-set", {
        originalErrorMessage: r == null ? void 0 : r.message
      });
      un.warn(n.message);
    }
  }
}
function yv(t) {
  return `${t.name}!${t.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RP = 1024, NP = 30;
class xP {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const r = this.container.getProvider("app").getImmediate();
    this._storage = new DP(r), this._heartbeatsCachePromise = this._storage.read().then((n) => (this._heartbeatsCache = n, n));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var e, r;
    try {
      const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), a = G0();
      if (((e = this._heartbeatsCache) == null ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((r = this._heartbeatsCache) == null ? void 0 : r.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === a || this._heartbeatsCache.heartbeats.some((s) => s.date === a))
        return;
      if (this._heartbeatsCache.heartbeats.push({ date: a, agent: i }), this._heartbeatsCache.heartbeats.length > NP) {
        const s = LP(this._heartbeatsCache.heartbeats);
        this._heartbeatsCache.heartbeats.splice(s, 1);
      }
      return this._storage.overwrite(this._heartbeatsCache);
    } catch (n) {
      un.warn(n);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var e;
    try {
      if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) == null ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
        return "";
      const r = G0(), { heartbeatsToSend: n, unsentEntries: i } = OP(this._heartbeatsCache.heartbeats), a = ov(JSON.stringify({ version: 2, heartbeats: n }));
      return this._heartbeatsCache.lastSentHeartbeatDate = r, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), a;
    } catch (r) {
      return un.warn(r), "";
    }
  }
}
function G0() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function OP(t, e = RP) {
  const r = [];
  let n = t.slice();
  for (const i of t) {
    const a = r.find((s) => s.agent === i.agent);
    if (a) {
      if (a.dates.push(i.date), j0(r) > e) {
        a.dates.pop();
        break;
      }
    } else if (r.push({
      agent: i.agent,
      dates: [i.date]
    }), j0(r) > e) {
      r.pop();
      break;
    }
    n = n.slice(1);
  }
  return {
    heartbeatsToSend: r,
    unsentEntries: n
  };
}
class DP {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return uv() ? lv().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const r = await TP(this.app);
      return r != null && r.heartbeats ? r : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    if (await this._canUseIndexedDBPromise) {
      const n = await this.read();
      return K0(this.app, {
        lastSentHeartbeatDate: e.lastSentHeartbeatDate ?? n.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    if (await this._canUseIndexedDBPromise) {
      const n = await this.read();
      return K0(this.app, {
        lastSentHeartbeatDate: e.lastSentHeartbeatDate ?? n.lastSentHeartbeatDate,
        heartbeats: [
          ...n.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function j0(t) {
  return ov(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: t })
  ).length;
}
function LP(t) {
  if (t.length === 0)
    return -1;
  let e = 0, r = t[0].date;
  for (let n = 1; n < t.length; n++)
    t[n].date < r && (r = t[n].date, e = n);
  return e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function PP(t) {
  ki(new zn(
    "platform-logger",
    (e) => new qL(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ki(new zn(
    "heartbeat",
    (e) => new xP(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Ti(Xl, $0, t), Ti(Xl, $0, "esm2020"), Ti("fire-js", "");
}
PP("");
var kP = "firebase", BP = "12.1.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Ti(kP, BP, "app");
const mv = "@firebase/installations", vd = "0.6.19";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ev = 1e4, vv = `w:${vd}`, Av = "FIS_v2", UP = "https://firebaseinstallations.googleapis.com/v1", FP = 60 * 60 * 1e3, MP = "installations", VP = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $P = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "not-registered": "Firebase Installation is not registered.",
  "installation-not-found": "Firebase Installation not found.",
  "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  "app-offline": "Could not process request. Application offline.",
  "delete-pending-registration": "Can't delete installation while there is a pending registration request."
}, Xn = new cc(MP, VP, $P);
function Cv(t) {
  return t instanceof qi && t.code.includes(
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _v({ projectId: t }) {
  return `${UP}/projects/${t}/installations`;
}
function Sv(t) {
  return {
    token: t.token,
    requestStatus: 2,
    expiresIn: KP(t.expiresIn),
    creationTime: Date.now()
  };
}
async function Iv(t, e) {
  const n = (await e.json()).error;
  return Xn.create("request-failed", {
    requestName: t,
    serverCode: n.code,
    serverMessage: n.message,
    serverStatus: n.status
  });
}
function bv({ apiKey: t }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": t
  });
}
function HP(t, { refreshToken: e }) {
  const r = bv(t);
  return r.append("Authorization", GP(e)), r;
}
async function wv(t) {
  const e = await t();
  return e.status >= 500 && e.status < 600 ? t() : e;
}
function KP(t) {
  return Number(t.replace("s", "000"));
}
function GP(t) {
  return `${Av} ${t}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function jP({ appConfig: t, heartbeatServiceProvider: e }, { fid: r }) {
  const n = _v(t), i = bv(t), a = e.getImmediate({
    optional: !0
  });
  if (a) {
    const u = await a.getHeartbeatsHeader();
    u && i.append("x-firebase-client", u);
  }
  const s = {
    fid: r,
    authVersion: Av,
    appId: t.appId,
    sdkVersion: vv
  }, o = {
    method: "POST",
    headers: i,
    body: JSON.stringify(s)
  }, l = await wv(() => fetch(n, o));
  if (l.ok) {
    const u = await l.json();
    return {
      fid: u.fid || r,
      registrationStatus: 2,
      refreshToken: u.refreshToken,
      authToken: Sv(u.authToken)
    };
  } else
    throw await Iv("Create Installation", l);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Tv(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qP(t) {
  return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WP = /^[cdef][\w-]{21}$/, Zl = "";
function JP() {
  try {
    const t = new Uint8Array(17);
    (self.crypto || self.msCrypto).getRandomValues(t), t[0] = 112 + t[0] % 16;
    const r = zP(t);
    return WP.test(r) ? r : Zl;
  } catch {
    return Zl;
  }
}
function zP(t) {
  return qP(t).substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function lc(t) {
  return `${t.appName}!${t.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rv = /* @__PURE__ */ new Map();
function Nv(t, e) {
  const r = lc(t);
  xv(r, e), XP(r, e);
}
function xv(t, e) {
  const r = Rv.get(t);
  if (r)
    for (const n of r)
      n(e);
}
function XP(t, e) {
  const r = YP();
  r && r.postMessage({ key: t, fid: e }), QP();
}
let Kn = null;
function YP() {
  return !Kn && "BroadcastChannel" in self && (Kn = new BroadcastChannel("[Firebase] FID Change"), Kn.onmessage = (t) => {
    xv(t.data.key, t.data.fid);
  }), Kn;
}
function QP() {
  Rv.size === 0 && Kn && (Kn.close(), Kn = null);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ZP = "firebase-installations-database", ek = 1, Yn = "firebase-installations-store";
let hl = null;
function Ad() {
  return hl || (hl = uc(ZP, ek, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          t.createObjectStore(Yn);
      }
    }
  })), hl;
}
async function eo(t, e) {
  const r = lc(t), i = (await Ad()).transaction(Yn, "readwrite"), a = i.objectStore(Yn), s = await a.get(r);
  return await a.put(e, r), await i.done, (!s || s.fid !== e.fid) && Nv(t, e.fid), e;
}
async function Ov(t) {
  const e = lc(t), n = (await Ad()).transaction(Yn, "readwrite");
  await n.objectStore(Yn).delete(e), await n.done;
}
async function fc(t, e) {
  const r = lc(t), i = (await Ad()).transaction(Yn, "readwrite"), a = i.objectStore(Yn), s = await a.get(r), o = e(s);
  return o === void 0 ? await a.delete(r) : await a.put(o, r), await i.done, o && (!s || s.fid !== o.fid) && Nv(t, o.fid), o;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Cd(t) {
  let e;
  const r = await fc(t.appConfig, (n) => {
    const i = tk(n), a = rk(t, i);
    return e = a.registrationPromise, a.installationEntry;
  });
  return r.fid === Zl ? { installationEntry: await e } : {
    installationEntry: r,
    registrationPromise: e
  };
}
function tk(t) {
  const e = t || {
    fid: JP(),
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  };
  return Dv(e);
}
function rk(t, e) {
  if (e.registrationStatus === 0) {
    if (!navigator.onLine) {
      const i = Promise.reject(Xn.create(
        "app-offline"
        /* ErrorCode.APP_OFFLINE */
      ));
      return {
        installationEntry: e,
        registrationPromise: i
      };
    }
    const r = {
      fid: e.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    }, n = nk(t, r);
    return { installationEntry: r, registrationPromise: n };
  } else return e.registrationStatus === 1 ? {
    installationEntry: e,
    registrationPromise: ik(t)
  } : { installationEntry: e };
}
async function nk(t, e) {
  try {
    const r = await jP(t, e);
    return eo(t.appConfig, r);
  } catch (r) {
    throw Cv(r) && r.customData.serverCode === 409 ? await Ov(t.appConfig) : await eo(t.appConfig, {
      fid: e.fid,
      registrationStatus: 0
      /* RequestStatus.NOT_STARTED */
    }), r;
  }
}
async function ik(t) {
  let e = await q0(t.appConfig);
  for (; e.registrationStatus === 1; )
    await Tv(100), e = await q0(t.appConfig);
  if (e.registrationStatus === 0) {
    const { installationEntry: r, registrationPromise: n } = await Cd(t);
    return n || r;
  }
  return e;
}
function q0(t) {
  return fc(t, (e) => {
    if (!e)
      throw Xn.create(
        "installation-not-found"
        /* ErrorCode.INSTALLATION_NOT_FOUND */
      );
    return Dv(e);
  });
}
function Dv(t) {
  return ak(t) ? {
    fid: t.fid,
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  } : t;
}
function ak(t) {
  return t.registrationStatus === 1 && t.registrationTime + Ev < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sk({ appConfig: t, heartbeatServiceProvider: e }, r) {
  const n = ok(t, r), i = HP(t, r), a = e.getImmediate({
    optional: !0
  });
  if (a) {
    const u = await a.getHeartbeatsHeader();
    u && i.append("x-firebase-client", u);
  }
  const s = {
    installation: {
      sdkVersion: vv,
      appId: t.appId
    }
  }, o = {
    method: "POST",
    headers: i,
    body: JSON.stringify(s)
  }, l = await wv(() => fetch(n, o));
  if (l.ok) {
    const u = await l.json();
    return Sv(u);
  } else
    throw await Iv("Generate Auth Token", l);
}
function ok(t, { fid: e }) {
  return `${_v(t)}/${e}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _d(t, e = !1) {
  let r;
  const n = await fc(t.appConfig, (a) => {
    if (!Lv(a))
      throw Xn.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const s = a.authToken;
    if (!e && lk(s))
      return a;
    if (s.requestStatus === 1)
      return r = ck(t, e), a;
    {
      if (!navigator.onLine)
        throw Xn.create(
          "app-offline"
          /* ErrorCode.APP_OFFLINE */
        );
      const o = dk(a);
      return r = uk(t, o), o;
    }
  });
  return r ? await r : n.authToken;
}
async function ck(t, e) {
  let r = await W0(t.appConfig);
  for (; r.authToken.requestStatus === 1; )
    await Tv(100), r = await W0(t.appConfig);
  const n = r.authToken;
  return n.requestStatus === 0 ? _d(t, e) : n;
}
function W0(t) {
  return fc(t, (e) => {
    if (!Lv(e))
      throw Xn.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const r = e.authToken;
    return hk(r) ? {
      ...e,
      authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      }
    } : e;
  });
}
async function uk(t, e) {
  try {
    const r = await sk(t, e), n = {
      ...e,
      authToken: r
    };
    return await eo(t.appConfig, n), r;
  } catch (r) {
    if (Cv(r) && (r.customData.serverCode === 401 || r.customData.serverCode === 404))
      await Ov(t.appConfig);
    else {
      const n = {
        ...e,
        authToken: {
          requestStatus: 0
          /* RequestStatus.NOT_STARTED */
        }
      };
      await eo(t.appConfig, n);
    }
    throw r;
  }
}
function Lv(t) {
  return t !== void 0 && t.registrationStatus === 2;
}
function lk(t) {
  return t.requestStatus === 2 && !fk(t);
}
function fk(t) {
  const e = Date.now();
  return e < t.creationTime || t.creationTime + t.expiresIn < e + FP;
}
function dk(t) {
  const e = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return {
    ...t,
    authToken: e
  };
}
function hk(t) {
  return t.requestStatus === 1 && t.requestTime + Ev < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function pk(t) {
  const e = t, { installationEntry: r, registrationPromise: n } = await Cd(e);
  return n ? n.catch(console.error) : _d(e).catch(console.error), r.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function gk(t, e = !1) {
  const r = t;
  return await yk(r), (await _d(r, e)).token;
}
async function yk(t) {
  const { registrationPromise: e } = await Cd(t);
  e && await e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mk(t) {
  if (!t || !t.options)
    throw pl("App Configuration");
  if (!t.name)
    throw pl("App Name");
  const e = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const r of e)
    if (!t.options[r])
      throw pl(r);
  return {
    appName: t.name,
    projectId: t.options.projectId,
    apiKey: t.options.apiKey,
    appId: t.options.appId
  };
}
function pl(t) {
  return Xn.create("missing-app-config-values", {
    valueName: t
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Pv = "installations", Ek = "installations-internal", vk = (t) => {
  const e = t.getProvider("app").getImmediate(), r = mk(e), n = Ed(e, "heartbeat");
  return {
    app: e,
    appConfig: r,
    heartbeatServiceProvider: n,
    _delete: () => Promise.resolve()
  };
}, Ak = (t) => {
  const e = t.getProvider("app").getImmediate(), r = Ed(e, Pv).getImmediate();
  return {
    getId: () => pk(r),
    getToken: (i) => gk(r, i)
  };
};
function Ck() {
  ki(new zn(
    Pv,
    vk,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), ki(new zn(
    Ek,
    Ak,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
}
Ck();
Ti(mv, vd);
Ti(mv, vd, "esm2020");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kv = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", _k = "https://fcmregistrations.googleapis.com/v1", Bv = "FCM_MSG", Sk = "google.c.a.c_id", Ik = 3, bk = 1;
var to;
(function(t) {
  t[t.DATA_MESSAGE = 1] = "DATA_MESSAGE", t[t.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION";
})(to || (to = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var ro;
(function(t) {
  t.PUSH_RECEIVED = "push-received", t.NOTIFICATION_CLICKED = "notification-clicked";
})(ro || (ro = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nn(t) {
  const e = new Uint8Array(t);
  return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function wk(t) {
  const e = "=".repeat((4 - t.length % 4) % 4), r = (t + e).replace(/\-/g, "+").replace(/_/g, "/"), n = atob(r), i = new Uint8Array(n.length);
  for (let a = 0; a < n.length; ++a)
    i[a] = n.charCodeAt(a);
  return i;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gl = "fcm_token_details_db", Tk = 5, J0 = "fcm_token_object_Store";
async function Rk(t) {
  if ("databases" in indexedDB && !(await indexedDB.databases()).map((a) => a.name).includes(gl))
    return null;
  let e = null;
  return (await uc(gl, Tk, {
    upgrade: async (n, i, a, s) => {
      if (i < 2 || !n.objectStoreNames.contains(J0))
        return;
      const o = s.objectStore(J0), l = await o.index("fcmSenderId").get(t);
      if (await o.clear(), !!l) {
        if (i === 2) {
          const u = l;
          if (!u.auth || !u.p256dh || !u.endpoint)
            return;
          e = {
            token: u.fcmToken,
            createTime: u.createTime ?? Date.now(),
            subscriptionOptions: {
              auth: u.auth,
              p256dh: u.p256dh,
              endpoint: u.endpoint,
              swScope: u.swScope,
              vapidKey: typeof u.vapidKey == "string" ? u.vapidKey : nn(u.vapidKey)
            }
          };
        } else if (i === 3) {
          const u = l;
          e = {
            token: u.fcmToken,
            createTime: u.createTime,
            subscriptionOptions: {
              auth: nn(u.auth),
              p256dh: nn(u.p256dh),
              endpoint: u.endpoint,
              swScope: u.swScope,
              vapidKey: nn(u.vapidKey)
            }
          };
        } else if (i === 4) {
          const u = l;
          e = {
            token: u.fcmToken,
            createTime: u.createTime,
            subscriptionOptions: {
              auth: nn(u.auth),
              p256dh: nn(u.p256dh),
              endpoint: u.endpoint,
              swScope: u.swScope,
              vapidKey: nn(u.vapidKey)
            }
          };
        }
      }
    }
  })).close(), await ll(gl), await ll("fcm_vapid_details_db"), await ll("undefined"), Nk(e) ? e : null;
}
function Nk(t) {
  if (!t || !t.subscriptionOptions)
    return !1;
  const { subscriptionOptions: e } = t;
  return typeof t.createTime == "number" && t.createTime > 0 && typeof t.token == "string" && t.token.length > 0 && typeof e.auth == "string" && e.auth.length > 0 && typeof e.p256dh == "string" && e.p256dh.length > 0 && typeof e.endpoint == "string" && e.endpoint.length > 0 && typeof e.swScope == "string" && e.swScope.length > 0 && typeof e.vapidKey == "string" && e.vapidKey.length > 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xk = "firebase-messaging-database", Ok = 1, Qn = "firebase-messaging-store";
let yl = null;
function Sd() {
  return yl || (yl = uc(xk, Ok, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          t.createObjectStore(Qn);
      }
    }
  })), yl;
}
async function Id(t) {
  const e = wd(t), n = await (await Sd()).transaction(Qn).objectStore(Qn).get(e);
  if (n)
    return n;
  {
    const i = await Rk(t.appConfig.senderId);
    if (i)
      return await bd(t, i), i;
  }
}
async function bd(t, e) {
  const r = wd(t), i = (await Sd()).transaction(Qn, "readwrite");
  return await i.objectStore(Qn).put(e, r), await i.done, e;
}
async function Dk(t) {
  const e = wd(t), n = (await Sd()).transaction(Qn, "readwrite");
  await n.objectStore(Qn).delete(e), await n.done;
}
function wd({ appConfig: t }) {
  return t.appId;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lk = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "only-available-in-window": "This method is available in a Window context.",
  "only-available-in-sw": "This method is available in a service worker context.",
  "permission-default": "The notification permission was not granted and dismissed instead.",
  "permission-blocked": "The notification permission was not granted and blocked instead.",
  "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
  "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
  "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
  "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
  "token-update-no-token": "FCM returned no token when updating the user to push.",
  "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
  "invalid-vapid-key": "The public VAPID key must be a string.",
  "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
}, yr = new cc("messaging", "Messaging", Lk);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Pk(t, e) {
  const r = await Rd(t), n = Fv(e), i = {
    method: "POST",
    headers: r,
    body: JSON.stringify(n)
  };
  let a;
  try {
    a = await (await fetch(Td(t.appConfig), i)).json();
  } catch (s) {
    throw yr.create("token-subscribe-failed", {
      errorInfo: s == null ? void 0 : s.toString()
    });
  }
  if (a.error) {
    const s = a.error.message;
    throw yr.create("token-subscribe-failed", {
      errorInfo: s
    });
  }
  if (!a.token)
    throw yr.create(
      "token-subscribe-no-token"
      /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */
    );
  return a.token;
}
async function kk(t, e) {
  const r = await Rd(t), n = Fv(e.subscriptionOptions), i = {
    method: "PATCH",
    headers: r,
    body: JSON.stringify(n)
  };
  let a;
  try {
    a = await (await fetch(`${Td(t.appConfig)}/${e.token}`, i)).json();
  } catch (s) {
    throw yr.create("token-update-failed", {
      errorInfo: s == null ? void 0 : s.toString()
    });
  }
  if (a.error) {
    const s = a.error.message;
    throw yr.create("token-update-failed", {
      errorInfo: s
    });
  }
  if (!a.token)
    throw yr.create(
      "token-update-no-token"
      /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */
    );
  return a.token;
}
async function Uv(t, e) {
  const n = {
    method: "DELETE",
    headers: await Rd(t)
  };
  try {
    const a = await (await fetch(`${Td(t.appConfig)}/${e}`, n)).json();
    if (a.error) {
      const s = a.error.message;
      throw yr.create("token-unsubscribe-failed", {
        errorInfo: s
      });
    }
  } catch (i) {
    throw yr.create("token-unsubscribe-failed", {
      errorInfo: i == null ? void 0 : i.toString()
    });
  }
}
function Td({ projectId: t }) {
  return `${_k}/projects/${t}/registrations`;
}
async function Rd({ appConfig: t, installations: e }) {
  const r = await e.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": t.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${r}`
  });
}
function Fv({ p256dh: t, auth: e, endpoint: r, vapidKey: n }) {
  const i = {
    web: {
      endpoint: r,
      auth: e,
      p256dh: t
    }
  };
  return n !== kv && (i.web.applicationPubKey = n), i;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Bk = 7 * 24 * 60 * 60 * 1e3;
async function Uk(t) {
  const e = await Mk(t.swRegistration, t.vapidKey), r = {
    vapidKey: t.vapidKey,
    swScope: t.swRegistration.scope,
    endpoint: e.endpoint,
    auth: nn(e.getKey("auth")),
    p256dh: nn(e.getKey("p256dh"))
  }, n = await Id(t.firebaseDependencies);
  if (n) {
    if (Vk(n.subscriptionOptions, r))
      return Date.now() >= n.createTime + Bk ? Fk(t, {
        token: n.token,
        createTime: Date.now(),
        subscriptionOptions: r
      }) : n.token;
    try {
      await Uv(t.firebaseDependencies, n.token);
    } catch (i) {
      console.warn(i);
    }
    return X0(t.firebaseDependencies, r);
  } else return X0(t.firebaseDependencies, r);
}
async function z0(t) {
  const e = await Id(t.firebaseDependencies);
  e && (await Uv(t.firebaseDependencies, e.token), await Dk(t.firebaseDependencies));
  const r = await t.swRegistration.pushManager.getSubscription();
  return r ? r.unsubscribe() : !0;
}
async function Fk(t, e) {
  try {
    const r = await kk(t.firebaseDependencies, e), n = {
      ...e,
      token: r,
      createTime: Date.now()
    };
    return await bd(t.firebaseDependencies, n), r;
  } catch (r) {
    throw r;
  }
}
async function X0(t, e) {
  const n = {
    token: await Pk(t, e),
    createTime: Date.now(),
    subscriptionOptions: e
  };
  return await bd(t, n), n.token;
}
async function Mk(t, e) {
  const r = await t.pushManager.getSubscription();
  return r || t.pushManager.subscribe({
    userVisibleOnly: !0,
    // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
    // submitted to pushManager#subscribe must be of type Uint8Array.
    applicationServerKey: wk(e)
  });
}
function Vk(t, e) {
  const r = e.vapidKey === t.vapidKey, n = e.endpoint === t.endpoint, i = e.auth === t.auth, a = e.p256dh === t.p256dh;
  return r && n && i && a;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $k(t) {
  const e = {
    from: t.from,
    // eslint-disable-next-line camelcase
    collapseKey: t.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: t.fcmMessageId
  };
  return Hk(e, t), Kk(e, t), Gk(e, t), e;
}
function Hk(t, e) {
  if (!e.notification)
    return;
  t.notification = {};
  const r = e.notification.title;
  r && (t.notification.title = r);
  const n = e.notification.body;
  n && (t.notification.body = n);
  const i = e.notification.image;
  i && (t.notification.image = i);
  const a = e.notification.icon;
  a && (t.notification.icon = a);
}
function Kk(t, e) {
  e.data && (t.data = e.data);
}
function Gk(t, e) {
  var i, a, s, o;
  if (!e.fcmOptions && !((i = e.notification) != null && i.click_action))
    return;
  t.fcmOptions = {};
  const r = ((a = e.fcmOptions) == null ? void 0 : a.link) ?? ((s = e.notification) == null ? void 0 : s.click_action);
  r && (t.fcmOptions.link = r);
  const n = (o = e.fcmOptions) == null ? void 0 : o.analytics_label;
  n && (t.fcmOptions.analyticsLabel = n);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jk(t) {
  return typeof t == "object" && !!t && Sk in t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qk(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
async function Wk(t, e) {
  const r = Jk(e, await t.firebaseDependencies.installations.getId());
  zk(t, r, e.productId);
}
function Jk(t, e) {
  var n, i;
  const r = {};
  return t.from && (r.project_number = t.from), t.fcmMessageId && (r.message_id = t.fcmMessageId), r.instance_id = e, t.notification ? r.message_type = to.DISPLAY_NOTIFICATION.toString() : r.message_type = to.DATA_MESSAGE.toString(), r.sdk_platform = Ik.toString(), r.package_name = self.origin.replace(/(^\w+:|^)\/\//, ""), t.collapse_key && (r.collapse_key = t.collapse_key), r.event = bk.toString(), (n = t.fcmOptions) != null && n.analytics_label && (r.analytics_label = (i = t.fcmOptions) == null ? void 0 : i.analytics_label), r;
}
function zk(t, e, r) {
  const n = {};
  n.event_time_ms = Math.floor(Date.now()).toString(), n.source_extension_json_proto3 = JSON.stringify({
    messaging_client_event: e
  }), r && (n.compliance_data = Xk(r)), t.logEvents.push(n);
}
function Xk(t) {
  return {
    privacy_context: {
      prequest: {
        origin_associated_product_id: t
      }
    }
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Yk(t, e) {
  var i;
  const { newSubscription: r } = t;
  if (!r) {
    await z0(e);
    return;
  }
  const n = await Id(e.firebaseDependencies);
  await z0(e), e.vapidKey = ((i = n == null ? void 0 : n.subscriptionOptions) == null ? void 0 : i.vapidKey) ?? kv, await Uk(e);
}
async function Qk(t, e) {
  const r = tB(t);
  if (!r)
    return;
  e.deliveryMetricsExportedToBigQueryEnabled && await Wk(e, r);
  const n = await Mv();
  if (nB(n))
    return iB(n, r);
  if (r.notification && await aB(eB(r)), !!e && e.onBackgroundMessageHandler) {
    const i = $k(r);
    typeof e.onBackgroundMessageHandler == "function" ? await e.onBackgroundMessageHandler(i) : e.onBackgroundMessageHandler.next(i);
  }
}
async function Zk(t) {
  var s, o;
  const e = (o = (s = t.notification) == null ? void 0 : s.data) == null ? void 0 : o[Bv];
  if (e) {
    if (t.action)
      return;
  } else return;
  t.stopImmediatePropagation(), t.notification.close();
  const r = sB(e);
  if (!r)
    return;
  const n = new URL(r, self.location.href), i = new URL(self.location.origin);
  if (n.host !== i.host)
    return;
  let a = await rB(n);
  if (a ? a = await a.focus() : (a = await self.clients.openWindow(r), await qk(3e3)), !!a)
    return e.messageType = ro.NOTIFICATION_CLICKED, e.isFirebaseMessaging = !0, a.postMessage(e);
}
function eB(t) {
  const e = {
    ...t.notification
  };
  return e.data = {
    [Bv]: t
  }, e;
}
function tB({ data: t }) {
  if (!t)
    return null;
  try {
    return t.json();
  } catch {
    return null;
  }
}
async function rB(t) {
  const e = await Mv();
  for (const r of e) {
    const n = new URL(r.url, self.location.href);
    if (t.host === n.host)
      return r;
  }
  return null;
}
function nB(t) {
  return t.some((e) => e.visibilityState === "visible" && // Ignore chrome-extension clients as that matches the background pages of extensions, which
  // are always considered visible for some reason.
  !e.url.startsWith("chrome-extension://"));
}
function iB(t, e) {
  e.isFirebaseMessaging = !0, e.messageType = ro.PUSH_RECEIVED;
  for (const r of t)
    r.postMessage(e);
}
function Mv() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: !0
    // TS doesn't know that "type: 'window'" means it'll return WindowClient[]
  });
}
function aB(t) {
  const { actions: e } = t, { maxActions: r } = Notification;
  return e && r && e.length > r && console.warn(`This browser only supports ${r} actions. The remaining actions will not be displayed.`), self.registration.showNotification(
    /* title= */
    t.title ?? "",
    t
  );
}
function sB(t) {
  var r, n;
  const e = ((r = t.fcmOptions) == null ? void 0 : r.link) ?? ((n = t.notification) == null ? void 0 : n.click_action);
  return e || (jk(t.data) ? self.location.origin : null);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function oB(t) {
  if (!t || !t.options)
    throw ml("App Configuration Object");
  if (!t.name)
    throw ml("App Name");
  const e = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ], { options: r } = t;
  for (const n of e)
    if (!r[n])
      throw ml(n);
  return {
    appName: t.name,
    projectId: r.projectId,
    apiKey: r.apiKey,
    appId: r.appId,
    senderId: r.messagingSenderId
  };
}
function ml(t) {
  return yr.create("missing-app-config-values", {
    valueName: t
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cB {
  constructor(e, r, n) {
    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
    const i = oB(e);
    this.firebaseDependencies = {
      app: e,
      appConfig: i,
      installations: r,
      analyticsProvider: n
    };
  }
  _delete() {
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uB = (t) => {
  const e = new cB(t.getProvider("app").getImmediate(), t.getProvider("installations-internal").getImmediate(), t.getProvider("analytics-internal"));
  return self.addEventListener("push", (r) => {
    r.waitUntil(Qk(r, e));
  }), self.addEventListener("pushsubscriptionchange", (r) => {
    r.waitUntil(Yk(r, e));
  }), self.addEventListener("notificationclick", (r) => {
    r.waitUntil(Zk(r));
  }), e;
};
function lB() {
  ki(new zn(
    "messaging-sw",
    uB,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function fB() {
  return uv() && await lv() && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dB(t, e) {
  if (self.document !== void 0)
    throw yr.create(
      "only-available-in-sw"
      /* ErrorCode.AVAILABLE_IN_SW */
    );
  return t.onBackgroundMessageHandler = e, () => {
    t.onBackgroundMessageHandler = null;
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hB(t = IP()) {
  return fB().then((e) => {
    if (!e)
      throw yr.create(
        "unsupported-browser"
        /* ErrorCode.UNSUPPORTED_BROWSER */
      );
  }, (e) => {
    throw yr.create(
      "indexed-db-unsupported"
      /* ErrorCode.INDEXED_DB_UNSUPPORTED */
    );
  }), Ed(fv(t), "messaging-sw").getImmediate();
}
function pB(t, e) {
  return t = fv(t), dB(t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
lB();
try {
  self["workbox:core:7.2.0"] && _();
} catch {
}
const gB = (t, ...e) => {
  let r = t;
  return e.length > 0 && (r += ` :: ${JSON.stringify(e)}`), r;
}, yB = gB;
class tr extends Error {
  /**
   *
   * @param {string} errorCode The error code that
   * identifies this particular error.
   * @param {Object=} details Any relevant arguments
   * that will help developers identify issues should
   * be added as a key on the context object.
   */
  constructor(e, r) {
    const n = yB(e, r);
    super(n), this.name = e, this.details = r;
  }
}
const sn = {
  googleAnalytics: "googleAnalytics",
  precache: "precache-v2",
  prefix: "workbox",
  runtime: "runtime",
  suffix: typeof registration < "u" ? registration.scope : ""
}, El = (t) => [sn.prefix, t, sn.suffix].filter((e) => e && e.length > 0).join("-"), mB = (t) => {
  for (const e of Object.keys(sn))
    t(e);
}, Nd = {
  updateDetails: (t) => {
    mB((e) => {
      typeof t[e] == "string" && (sn[e] = t[e]);
    });
  },
  getGoogleAnalyticsName: (t) => t || El(sn.googleAnalytics),
  getPrecacheName: (t) => t || El(sn.precache),
  getPrefix: () => sn.prefix,
  getRuntimeName: (t) => t || El(sn.runtime),
  getSuffix: () => sn.suffix
};
function Y0(t, e) {
  const r = e();
  return t.waitUntil(r), r;
}
try {
  self["workbox:precaching:7.2.0"] && _();
} catch {
}
const EB = "__WB_REVISION__";
function vB(t) {
  if (!t)
    throw new tr("add-to-cache-list-unexpected-type", { entry: t });
  if (typeof t == "string") {
    const a = new URL(t, location.href);
    return {
      cacheKey: a.href,
      url: a.href
    };
  }
  const { revision: e, url: r } = t;
  if (!r)
    throw new tr("add-to-cache-list-unexpected-type", { entry: t });
  if (!e) {
    const a = new URL(r, location.href);
    return {
      cacheKey: a.href,
      url: a.href
    };
  }
  const n = new URL(r, location.href), i = new URL(r, location.href);
  return n.searchParams.set(EB, e), {
    cacheKey: n.href,
    url: i.href
  };
}
class AB {
  constructor() {
    this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: r }) => {
      r && (r.originalRequest = e);
    }, this.cachedResponseWillBeUsed = async ({ event: e, state: r, cachedResponse: n }) => {
      if (e.type === "install" && r && r.originalRequest && r.originalRequest instanceof Request) {
        const i = r.originalRequest.url;
        n ? this.notUpdatedURLs.push(i) : this.updatedURLs.push(i);
      }
      return n;
    };
  }
}
class CB {
  constructor({ precacheController: e }) {
    this.cacheKeyWillBeUsed = async ({ request: r, params: n }) => {
      const i = (n == null ? void 0 : n.cacheKey) || this._precacheController.getCacheKeyForURL(r.url);
      return i ? new Request(i, { headers: r.headers }) : r;
    }, this._precacheController = e;
  }
}
let ea;
function _B() {
  if (ea === void 0) {
    const t = new Response("");
    if ("body" in t)
      try {
        new Response(t.body), ea = !0;
      } catch {
        ea = !1;
      }
    ea = !1;
  }
  return ea;
}
async function SB(t, e) {
  let r = null;
  if (t.url && (r = new URL(t.url).origin), r !== self.location.origin)
    throw new tr("cross-origin-copy-response", { origin: r });
  const n = t.clone(), a = {
    headers: new Headers(n.headers),
    status: n.status,
    statusText: n.statusText
  }, s = _B() ? n.body : await n.blob();
  return new Response(s, a);
}
const IB = (t) => new URL(String(t), location.href).href.replace(new RegExp(`^${location.origin}`), "");
function Q0(t, e) {
  const r = new URL(t);
  for (const n of e)
    r.searchParams.delete(n);
  return r.href;
}
async function bB(t, e, r, n) {
  const i = Q0(e.url, r);
  if (e.url === i)
    return t.match(e, n);
  const a = Object.assign(Object.assign({}, n), { ignoreSearch: !0 }), s = await t.keys(e, a);
  for (const o of s) {
    const l = Q0(o.url, r);
    if (i === l)
      return t.match(o, n);
  }
}
class wB {
  /**
   * Creates a promise and exposes its resolve and reject functions as methods.
   */
  constructor() {
    this.promise = new Promise((e, r) => {
      this.resolve = e, this.reject = r;
    });
  }
}
const TB = /* @__PURE__ */ new Set();
async function RB() {
  for (const t of TB)
    await t();
}
function NB(t) {
  return new Promise((e) => setTimeout(e, t));
}
try {
  self["workbox:strategies:7.2.0"] && _();
} catch {
}
function ps(t) {
  return typeof t == "string" ? new Request(t) : t;
}
class xB {
  /**
   * Creates a new instance associated with the passed strategy and event
   * that's handling the request.
   *
   * The constructor also initializes the state that will be passed to each of
   * the plugins handling this request.
   *
   * @param {workbox-strategies.Strategy} strategy
   * @param {Object} options
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params] The return value from the
   *     {@link workbox-routing~matchCallback} (if applicable).
   */
  constructor(e, r) {
    this._cacheKeys = {}, Object.assign(this, r), this.event = r.event, this._strategy = e, this._handlerDeferred = new wB(), this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = /* @__PURE__ */ new Map();
    for (const n of this._plugins)
      this._pluginStateMap.set(n, {});
    this.event.waitUntil(this._handlerDeferred.promise);
  }
  /**
   * Fetches a given request (and invokes any applicable plugin callback
   * methods) using the `fetchOptions` (for non-navigation requests) and
   * `plugins` defined on the `Strategy` object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - `requestWillFetch()`
   * - `fetchDidSucceed()`
   * - `fetchDidFail()`
   *
   * @param {Request|string} input The URL or request to fetch.
   * @return {Promise<Response>}
   */
  async fetch(e) {
    const { event: r } = this;
    let n = ps(e);
    if (n.mode === "navigate" && r instanceof FetchEvent && r.preloadResponse) {
      const s = await r.preloadResponse;
      if (s)
        return s;
    }
    const i = this.hasCallback("fetchDidFail") ? n.clone() : null;
    try {
      for (const s of this.iterateCallbacks("requestWillFetch"))
        n = await s({ request: n.clone(), event: r });
    } catch (s) {
      if (s instanceof Error)
        throw new tr("plugin-error-request-will-fetch", {
          thrownErrorMessage: s.message
        });
    }
    const a = n.clone();
    try {
      let s;
      s = await fetch(n, n.mode === "navigate" ? void 0 : this._strategy.fetchOptions);
      for (const o of this.iterateCallbacks("fetchDidSucceed"))
        s = await o({
          event: r,
          request: a,
          response: s
        });
      return s;
    } catch (s) {
      throw i && await this.runCallbacks("fetchDidFail", {
        error: s,
        event: r,
        originalRequest: i.clone(),
        request: a.clone()
      }), s;
    }
  }
  /**
   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
   * the response generated by `this.fetch()`.
   *
   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
   * so you do not have to manually call `waitUntil()` on the event.
   *
   * @param {Request|string} input The request or URL to fetch and cache.
   * @return {Promise<Response>}
   */
  async fetchAndCachePut(e) {
    const r = await this.fetch(e), n = r.clone();
    return this.waitUntil(this.cachePut(e, n)), r;
  }
  /**
   * Matches a request from the cache (and invokes any applicable plugin
   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
   * defined on the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillBeUsed()
   * - cachedResponseWillBeUsed()
   *
   * @param {Request|string} key The Request or URL to use as the cache key.
   * @return {Promise<Response|undefined>} A matching response, if found.
   */
  async cacheMatch(e) {
    const r = ps(e);
    let n;
    const { cacheName: i, matchOptions: a } = this._strategy, s = await this.getCacheKey(r, "read"), o = Object.assign(Object.assign({}, a), { cacheName: i });
    n = await caches.match(s, o);
    for (const l of this.iterateCallbacks("cachedResponseWillBeUsed"))
      n = await l({
        cacheName: i,
        matchOptions: a,
        cachedResponse: n,
        request: s,
        event: this.event
      }) || void 0;
    return n;
  }
  /**
   * Puts a request/response pair in the cache (and invokes any applicable
   * plugin callback methods) using the `cacheName` and `plugins` defined on
   * the strategy object.
   *
   * The following plugin lifecycle methods are invoked when using this method:
   * - cacheKeyWillBeUsed()
   * - cacheWillUpdate()
   * - cacheDidUpdate()
   *
   * @param {Request|string} key The request or URL to use as the cache key.
   * @param {Response} response The response to cache.
   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
   * not be cached, and `true` otherwise.
   */
  async cachePut(e, r) {
    const n = ps(e);
    await NB(0);
    const i = await this.getCacheKey(n, "write");
    if (!r)
      throw new tr("cache-put-with-no-response", {
        url: IB(i.url)
      });
    const a = await this._ensureResponseSafeToCache(r);
    if (!a)
      return !1;
    const { cacheName: s, matchOptions: o } = this._strategy, l = await self.caches.open(s), u = this.hasCallback("cacheDidUpdate"), f = u ? await bB(
      // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
      // feature. Consider into ways to only add this behavior if using
      // precaching.
      l,
      i.clone(),
      ["__WB_REVISION__"],
      o
    ) : null;
    try {
      await l.put(i, u ? a.clone() : a);
    } catch (y) {
      if (y instanceof Error)
        throw y.name === "QuotaExceededError" && await RB(), y;
    }
    for (const y of this.iterateCallbacks("cacheDidUpdate"))
      await y({
        cacheName: s,
        oldResponse: f,
        newResponse: a.clone(),
        request: i,
        event: this.event
      });
    return !0;
  }
  /**
   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
   * executes any of those callbacks found in sequence. The final `Request`
   * object returned by the last plugin is treated as the cache key for cache
   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
   * been registered, the passed request is returned unmodified
   *
   * @param {Request} request
   * @param {string} mode
   * @return {Promise<Request>}
   */
  async getCacheKey(e, r) {
    const n = `${e.url} | ${r}`;
    if (!this._cacheKeys[n]) {
      let i = e;
      for (const a of this.iterateCallbacks("cacheKeyWillBeUsed"))
        i = ps(await a({
          mode: r,
          request: i,
          event: this.event,
          // params has a type any can't change right now.
          params: this.params
          // eslint-disable-line
        }));
      this._cacheKeys[n] = i;
    }
    return this._cacheKeys[n];
  }
  /**
   * Returns true if the strategy has at least one plugin with the given
   * callback.
   *
   * @param {string} name The name of the callback to check for.
   * @return {boolean}
   */
  hasCallback(e) {
    for (const r of this._strategy.plugins)
      if (e in r)
        return !0;
    return !1;
  }
  /**
   * Runs all plugin callbacks matching the given name, in order, passing the
   * given param object (merged ith the current plugin state) as the only
   * argument.
   *
   * Note: since this method runs all plugins, it's not suitable for cases
   * where the return value of a callback needs to be applied prior to calling
   * the next callback. See
   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
   * below for how to handle that case.
   *
   * @param {string} name The name of the callback to run within each plugin.
   * @param {Object} param The object to pass as the first (and only) param
   *     when executing each callback. This object will be merged with the
   *     current plugin state prior to callback execution.
   */
  async runCallbacks(e, r) {
    for (const n of this.iterateCallbacks(e))
      await n(r);
  }
  /**
   * Accepts a callback and returns an iterable of matching plugin callbacks,
   * where each callback is wrapped with the current handler state (i.e. when
   * you call each callback, whatever object parameter you pass it will
   * be merged with the plugin's current state).
   *
   * @param {string} name The name fo the callback to run
   * @return {Array<Function>}
   */
  *iterateCallbacks(e) {
    for (const r of this._strategy.plugins)
      if (typeof r[e] == "function") {
        const n = this._pluginStateMap.get(r);
        yield (a) => {
          const s = Object.assign(Object.assign({}, a), { state: n });
          return r[e](s);
        };
      }
  }
  /**
   * Adds a promise to the
   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
   * of the event event associated with the request being handled (usually a
   * `FetchEvent`).
   *
   * Note: you can await
   * {@link workbox-strategies.StrategyHandler~doneWaiting}
   * to know when all added promises have settled.
   *
   * @param {Promise} promise A promise to add to the extend lifetime promises
   *     of the event that triggered the request.
   */
  waitUntil(e) {
    return this._extendLifetimePromises.push(e), e;
  }
  /**
   * Returns a promise that resolves once all promises passed to
   * {@link workbox-strategies.StrategyHandler~waitUntil}
   * have settled.
   *
   * Note: any work done after `doneWaiting()` settles should be manually
   * passed to an event's `waitUntil()` method (not this handler's
   * `waitUntil()` method), otherwise the service worker thread my be killed
   * prior to your work completing.
   */
  async doneWaiting() {
    let e;
    for (; e = this._extendLifetimePromises.shift(); )
      await e;
  }
  /**
   * Stops running the strategy and immediately resolves any pending
   * `waitUntil()` promises.
   */
  destroy() {
    this._handlerDeferred.resolve(null);
  }
  /**
   * This method will call cacheWillUpdate on the available plugins (or use
   * status === 200) to determine if the Response is safe and valid to cache.
   *
   * @param {Request} options.request
   * @param {Response} options.response
   * @return {Promise<Response|undefined>}
   *
   * @private
   */
  async _ensureResponseSafeToCache(e) {
    let r = e, n = !1;
    for (const i of this.iterateCallbacks("cacheWillUpdate"))
      if (r = await i({
        request: this.request,
        response: r,
        event: this.event
      }) || void 0, n = !0, !r)
        break;
    return n || r && r.status !== 200 && (r = void 0), r;
  }
}
class OB {
  /**
   * Creates a new instance of the strategy and sets all documented option
   * properties as public instance properties.
   *
   * Note: if a custom strategy class extends the base Strategy class and does
   * not need more than these properties, it does not need to define its own
   * constructor.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
   * `fetch()` requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   */
  constructor(e = {}) {
    this.cacheName = Nd.getRuntimeName(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions;
  }
  /**
   * Perform a request strategy and returns a `Promise` that will resolve with
   * a `Response`, invoking all relevant plugin callbacks.
   *
   * When a strategy instance is registered with a Workbox
   * {@link workbox-routing.Route}, this method is automatically
   * called when the route matches.
   *
   * Alternatively, this method can be used in a standalone `FetchEvent`
   * listener by passing it to `event.respondWith()`.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   */
  handle(e) {
    const [r] = this.handleAll(e);
    return r;
  }
  /**
   * Similar to {@link workbox-strategies.Strategy~handle}, but
   * instead of just returning a `Promise` that resolves to a `Response` it
   * it will return an tuple of `[response, done]` promises, where the former
   * (`response`) is equivalent to what `handle()` returns, and the latter is a
   * Promise that will resolve once any promises that were added to
   * `event.waitUntil()` as part of performing the strategy have completed.
   *
   * You can await the `done` promise to ensure any extra work performed by
   * the strategy (usually caching responses) completes successfully.
   *
   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
   *     properties listed below.
   * @param {Request|string} options.request A request to run this strategy for.
   * @param {ExtendableEvent} options.event The event associated with the
   *     request.
   * @param {URL} [options.url]
   * @param {*} [options.params]
   * @return {Array<Promise>} A tuple of [response, done]
   *     promises that can be used to determine when the response resolves as
   *     well as when the handler has completed all its work.
   */
  handleAll(e) {
    e instanceof FetchEvent && (e = {
      event: e,
      request: e.request
    });
    const r = e.event, n = typeof e.request == "string" ? new Request(e.request) : e.request, i = "params" in e ? e.params : void 0, a = new xB(this, { event: r, request: n, params: i }), s = this._getResponse(a, n, r), o = this._awaitComplete(s, a, n, r);
    return [s, o];
  }
  async _getResponse(e, r, n) {
    await e.runCallbacks("handlerWillStart", { event: n, request: r });
    let i;
    try {
      if (i = await this._handle(r, e), !i || i.type === "error")
        throw new tr("no-response", { url: r.url });
    } catch (a) {
      if (a instanceof Error) {
        for (const s of e.iterateCallbacks("handlerDidError"))
          if (i = await s({ error: a, event: n, request: r }), i)
            break;
      }
      if (!i)
        throw a;
    }
    for (const a of e.iterateCallbacks("handlerWillRespond"))
      i = await a({ event: n, request: r, response: i });
    return i;
  }
  async _awaitComplete(e, r, n, i) {
    let a, s;
    try {
      a = await e;
    } catch {
    }
    try {
      await r.runCallbacks("handlerDidRespond", {
        event: i,
        request: n,
        response: a
      }), await r.doneWaiting();
    } catch (o) {
      o instanceof Error && (s = o);
    }
    if (await r.runCallbacks("handlerDidComplete", {
      event: i,
      request: n,
      response: a,
      error: s
    }), r.destroy(), s)
      throw s;
  }
}
class _n extends OB {
  /**
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] Cache name to store and retrieve
   * requests. Defaults to the cache names provided by
   * {@link workbox-core.cacheNames}.
   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
   * to use in conjunction with this caching strategy.
   * @param {Object} [options.fetchOptions] Values passed along to the
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
   * of all fetch() requests made by this strategy.
   * @param {Object} [options.matchOptions] The
   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
   * for any `cache.match()` or `cache.put()` calls made by this strategy.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor(e = {}) {
    e.cacheName = Nd.getPrecacheName(e.cacheName), super(e), this._fallbackToNetwork = e.fallbackToNetwork !== !1, this.plugins.push(_n.copyRedirectedCacheableResponsesPlugin);
  }
  /**
   * @private
   * @param {Request|string} request A request to run this strategy for.
   * @param {workbox-strategies.StrategyHandler} handler The event that
   *     triggered the request.
   * @return {Promise<Response>}
   */
  async _handle(e, r) {
    const n = await r.cacheMatch(e);
    return n || (r.event && r.event.type === "install" ? await this._handleInstall(e, r) : await this._handleFetch(e, r));
  }
  async _handleFetch(e, r) {
    let n;
    const i = r.params || {};
    if (this._fallbackToNetwork) {
      const a = i.integrity, s = e.integrity, o = !s || s === a;
      n = await r.fetch(new Request(e, {
        integrity: e.mode !== "no-cors" ? s || a : void 0
      })), a && o && e.mode !== "no-cors" && (this._useDefaultCacheabilityPluginIfNeeded(), await r.cachePut(e, n.clone()));
    } else
      throw new tr("missing-precache-entry", {
        cacheName: this.cacheName,
        url: e.url
      });
    return n;
  }
  async _handleInstall(e, r) {
    this._useDefaultCacheabilityPluginIfNeeded();
    const n = await r.fetch(e);
    if (!await r.cachePut(e, n.clone()))
      throw new tr("bad-precaching-response", {
        url: e.url,
        status: n.status
      });
    return n;
  }
  /**
   * This method is complex, as there a number of things to account for:
   *
   * The `plugins` array can be set at construction, and/or it might be added to
   * to at any time before the strategy is used.
   *
   * At the time the strategy is used (i.e. during an `install` event), there
   * needs to be at least one plugin that implements `cacheWillUpdate` in the
   * array, other than `copyRedirectedCacheableResponsesPlugin`.
   *
   * - If this method is called and there are no suitable `cacheWillUpdate`
   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
   *
   * - If this method is called and there is exactly one `cacheWillUpdate`, then
   * we don't have to do anything (this might be a previously added
   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
   *
   * - If this method is called and there is more than one `cacheWillUpdate`,
   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
   * we need to remove it. (This situation is unlikely, but it could happen if
   * the strategy is used multiple times, the first without a `cacheWillUpdate`,
   * and then later on after manually adding a custom `cacheWillUpdate`.)
   *
   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
   *
   * @private
   */
  _useDefaultCacheabilityPluginIfNeeded() {
    let e = null, r = 0;
    for (const [n, i] of this.plugins.entries())
      i !== _n.copyRedirectedCacheableResponsesPlugin && (i === _n.defaultPrecacheCacheabilityPlugin && (e = n), i.cacheWillUpdate && r++);
    r === 0 ? this.plugins.push(_n.defaultPrecacheCacheabilityPlugin) : r > 1 && e !== null && this.plugins.splice(e, 1);
  }
}
_n.defaultPrecacheCacheabilityPlugin = {
  async cacheWillUpdate({ response: t }) {
    return !t || t.status >= 400 ? null : t;
  }
};
_n.copyRedirectedCacheableResponsesPlugin = {
  async cacheWillUpdate({ response: t }) {
    return t.redirected ? await SB(t) : t;
  }
};
class DB {
  /**
   * Create a new PrecacheController.
   *
   * @param {Object} [options]
   * @param {string} [options.cacheName] The cache to use for precaching.
   * @param {string} [options.plugins] Plugins to use when precaching as well
   * as responding to fetch events for precached assets.
   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
   * get the response from the network if there's a precache miss.
   */
  constructor({ cacheName: e, plugins: r = [], fallbackToNetwork: n = !0 } = {}) {
    this._urlsToCacheKeys = /* @__PURE__ */ new Map(), this._urlsToCacheModes = /* @__PURE__ */ new Map(), this._cacheKeysToIntegrities = /* @__PURE__ */ new Map(), this._strategy = new _n({
      cacheName: Nd.getPrecacheName(e),
      plugins: [
        ...r,
        new CB({ precacheController: this })
      ],
      fallbackToNetwork: n
    }), this.install = this.install.bind(this), this.activate = this.activate.bind(this);
  }
  /**
   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
   * used to cache assets and respond to fetch events.
   */
  get strategy() {
    return this._strategy;
  }
  /**
   * Adds items to the precache list, removing any duplicates and
   * stores the files in the
   * {@link workbox-core.cacheNames|"precache cache"} when the service
   * worker installs.
   *
   * This method can be called multiple times.
   *
   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
   */
  precache(e) {
    this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0);
  }
  /**
   * This method will add items to the precache list, removing duplicates
   * and ensuring the information is valid.
   *
   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
   *     Array of entries to precache.
   */
  addToCacheList(e) {
    const r = [];
    for (const n of e) {
      typeof n == "string" ? r.push(n) : n && n.revision === void 0 && r.push(n.url);
      const { cacheKey: i, url: a } = vB(n), s = typeof n != "string" && n.revision ? "reload" : "default";
      if (this._urlsToCacheKeys.has(a) && this._urlsToCacheKeys.get(a) !== i)
        throw new tr("add-to-cache-list-conflicting-entries", {
          firstEntry: this._urlsToCacheKeys.get(a),
          secondEntry: i
        });
      if (typeof n != "string" && n.integrity) {
        if (this._cacheKeysToIntegrities.has(i) && this._cacheKeysToIntegrities.get(i) !== n.integrity)
          throw new tr("add-to-cache-list-conflicting-integrities", {
            url: a
          });
        this._cacheKeysToIntegrities.set(i, n.integrity);
      }
      if (this._urlsToCacheKeys.set(a, i), this._urlsToCacheModes.set(a, s), r.length > 0) {
        const o = `Workbox is precaching URLs without revision info: ${r.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;
        console.warn(o);
      }
    }
  }
  /**
   * Precaches new and updated assets. Call this method from the service worker
   * install event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.InstallResult>}
   */
  install(e) {
    return Y0(e, async () => {
      const r = new AB();
      this.strategy.plugins.push(r);
      for (const [a, s] of this._urlsToCacheKeys) {
        const o = this._cacheKeysToIntegrities.get(s), l = this._urlsToCacheModes.get(a), u = new Request(a, {
          integrity: o,
          cache: l,
          credentials: "same-origin"
        });
        await Promise.all(this.strategy.handleAll({
          params: { cacheKey: s },
          request: u,
          event: e
        }));
      }
      const { updatedURLs: n, notUpdatedURLs: i } = r;
      return { updatedURLs: n, notUpdatedURLs: i };
    });
  }
  /**
   * Deletes assets that are no longer present in the current precache manifest.
   * Call this method from the service worker activate event.
   *
   * Note: this method calls `event.waitUntil()` for you, so you do not need
   * to call it yourself in your event handlers.
   *
   * @param {ExtendableEvent} event
   * @return {Promise<workbox-precaching.CleanupResult>}
   */
  activate(e) {
    return Y0(e, async () => {
      const r = await self.caches.open(this.strategy.cacheName), n = await r.keys(), i = new Set(this._urlsToCacheKeys.values()), a = [];
      for (const s of n)
        i.has(s.url) || (await r.delete(s), a.push(s.url));
      return { deletedURLs: a };
    });
  }
  /**
   * Returns a mapping of a precached URL to the corresponding cache key, taking
   * into account the revision information for the URL.
   *
   * @return {Map<string, string>} A URL to cache key mapping.
   */
  getURLsToCacheKeys() {
    return this._urlsToCacheKeys;
  }
  /**
   * Returns a list of all the URLs that have been precached by the current
   * service worker.
   *
   * @return {Array<string>} The precached URLs.
   */
  getCachedURLs() {
    return [...this._urlsToCacheKeys.keys()];
  }
  /**
   * Returns the cache key used for storing a given URL. If that URL is
   * unversioned, like `/index.html', then the cache key will be the original
   * URL with a search parameter appended to it.
   *
   * @param {string} url A URL whose cache key you want to look up.
   * @return {string} The versioned URL that corresponds to a cache key
   * for the original URL, or undefined if that URL isn't precached.
   */
  getCacheKeyForURL(e) {
    const r = new URL(e, location.href);
    return this._urlsToCacheKeys.get(r.href);
  }
  /**
   * @param {string} url A cache key whose SRI you want to look up.
   * @return {string} The subresource integrity associated with the cache key,
   * or undefined if it's not set.
   */
  getIntegrityForCacheKey(e) {
    return this._cacheKeysToIntegrities.get(e);
  }
  /**
   * This acts as a drop-in replacement for
   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
   * with the following differences:
   *
   * - It knows what the name of the precache is, and only checks in that cache.
   * - It allows you to pass in an "original" URL without versioning parameters,
   * and it will automatically look up the correct cache key for the currently
   * active revision of that URL.
   *
   * E.g., `matchPrecache('index.html')` will find the correct precached
   * response for the currently active service worker, even if the actual cache
   * key is `'/index.html?__WB_REVISION__=1234abcd'`.
   *
   * @param {string|Request} request The key (without revisioning parameters)
   * to look up in the precache.
   * @return {Promise<Response|undefined>}
   */
  async matchPrecache(e) {
    const r = e instanceof Request ? e.url : e, n = this.getCacheKeyForURL(r);
    if (n)
      return (await self.caches.open(this.strategy.cacheName)).match(n);
  }
  /**
   * Returns a function that looks up `url` in the precache (taking into
   * account revision information), and returns the corresponding `Response`.
   *
   * @param {string} url The precached URL which will be used to lookup the
   * `Response`.
   * @return {workbox-routing~handlerCallback}
   */
  createHandlerBoundToURL(e) {
    const r = this.getCacheKeyForURL(e);
    if (!r)
      throw new tr("non-precached-url", { url: e });
    return (n) => (n.request = new Request(e), n.params = Object.assign({ cacheKey: r }, n.params), this.strategy.handle(n));
  }
}
let vl;
const Vv = () => (vl || (vl = new DB()), vl);
try {
  self["workbox:routing:7.2.0"] && _();
} catch {
}
const $v = "GET", no = (t) => t && typeof t == "object" ? t : { handle: t };
class fa {
  /**
   * Constructor for Route class.
   *
   * @param {workbox-routing~matchCallback} match
   * A callback function that determines whether the route matches a given
   * `fetch` event by returning a non-falsy value.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(e, r, n = $v) {
    this.handler = no(r), this.match = e, this.method = n;
  }
  /**
   *
   * @param {workbox-routing-handlerCallback} handler A callback
   * function that returns a Promise resolving to a Response
   */
  setCatchHandler(e) {
    this.catchHandler = no(e);
  }
}
class LB extends fa {
  /**
   * If the regular expression contains
   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
   * the captured values will be passed to the
   * {@link workbox-routing~handlerCallback} `params`
   * argument.
   *
   * @param {RegExp} regExp The regular expression to match against URLs.
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to match the Route
   * against.
   */
  constructor(e, r, n) {
    const i = ({ url: a }) => {
      const s = e.exec(a.href);
      if (s && !(a.origin !== location.origin && s.index !== 0))
        return s.slice(1);
    };
    super(i, r, n);
  }
}
class PB {
  /**
   * Initializes a new Router.
   */
  constructor() {
    this._routes = /* @__PURE__ */ new Map(), this._defaultHandlerMap = /* @__PURE__ */ new Map();
  }
  /**
   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
   * method name ('GET', etc.) to an array of all the corresponding `Route`
   * instances that are registered.
   */
  get routes() {
    return this._routes;
  }
  /**
   * Adds a fetch event listener to respond to events when a route matches
   * the event's request.
   */
  addFetchListener() {
    self.addEventListener("fetch", (e) => {
      const { request: r } = e, n = this.handleRequest({ request: r, event: e });
      n && e.respondWith(n);
    });
  }
  /**
   * Adds a message event listener for URLs to cache from the window.
   * This is useful to cache resources loaded on the page prior to when the
   * service worker started controlling it.
   *
   * The format of the message data sent from the window should be as follows.
   * Where the `urlsToCache` array may consist of URL strings or an array of
   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
   *
   * ```
   * {
   *   type: 'CACHE_URLS',
   *   payload: {
   *     urlsToCache: [
   *       './script1.js',
   *       './script2.js',
   *       ['./script3.js', {mode: 'no-cors'}],
   *     ],
   *   },
   * }
   * ```
   */
  addCacheListener() {
    self.addEventListener("message", (e) => {
      if (e.data && e.data.type === "CACHE_URLS") {
        const { payload: r } = e.data, n = Promise.all(r.urlsToCache.map((i) => {
          typeof i == "string" && (i = [i]);
          const a = new Request(...i);
          return this.handleRequest({ request: a, event: e });
        }));
        e.waitUntil(n), e.ports && e.ports[0] && n.then(() => e.ports[0].postMessage(!0));
      }
    });
  }
  /**
   * Apply the routing rules to a FetchEvent object to get a Response from an
   * appropriate Route's handler.
   *
   * @param {Object} options
   * @param {Request} options.request The request to handle.
   * @param {ExtendableEvent} options.event The event that triggered the
   *     request.
   * @return {Promise<Response>|undefined} A promise is returned if a
   *     registered route can handle the request. If there is no matching
   *     route and there's no `defaultHandler`, `undefined` is returned.
   */
  handleRequest({ request: e, event: r }) {
    const n = new URL(e.url, location.href);
    if (!n.protocol.startsWith("http"))
      return;
    const i = n.origin === location.origin, { params: a, route: s } = this.findMatchingRoute({
      event: r,
      request: e,
      sameOrigin: i,
      url: n
    });
    let o = s && s.handler;
    const l = e.method;
    if (!o && this._defaultHandlerMap.has(l) && (o = this._defaultHandlerMap.get(l)), !o)
      return;
    let u;
    try {
      u = o.handle({ url: n, request: e, event: r, params: a });
    } catch (y) {
      u = Promise.reject(y);
    }
    const f = s && s.catchHandler;
    return u instanceof Promise && (this._catchHandler || f) && (u = u.catch(async (y) => {
      if (f)
        try {
          return await f.handle({ url: n, request: e, event: r, params: a });
        } catch (m) {
          m instanceof Error && (y = m);
        }
      if (this._catchHandler)
        return this._catchHandler.handle({ url: n, request: e, event: r });
      throw y;
    })), u;
  }
  /**
   * Checks a request and URL (and optionally an event) against the list of
   * registered routes, and if there's a match, returns the corresponding
   * route along with any params generated by the match.
   *
   * @param {Object} options
   * @param {URL} options.url
   * @param {boolean} options.sameOrigin The result of comparing `url.origin`
   *     against the current origin.
   * @param {Request} options.request The request to match.
   * @param {Event} options.event The corresponding event.
   * @return {Object} An object with `route` and `params` properties.
   *     They are populated if a matching route was found or `undefined`
   *     otherwise.
   */
  findMatchingRoute({ url: e, sameOrigin: r, request: n, event: i }) {
    const a = this._routes.get(n.method) || [];
    for (const s of a) {
      let o;
      const l = s.match({ url: e, sameOrigin: r, request: n, event: i });
      if (l)
        return o = l, (Array.isArray(o) && o.length === 0 || l.constructor === Object && // eslint-disable-line
        Object.keys(l).length === 0 || typeof l == "boolean") && (o = void 0), { route: s, params: o };
    }
    return {};
  }
  /**
   * Define a default `handler` that's called when no routes explicitly
   * match the incoming request.
   *
   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
   *
   * Without a default handler, unmatched requests will go against the
   * network as if there were no service worker present.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   * @param {string} [method='GET'] The HTTP method to associate with this
   * default handler. Each method has its own default.
   */
  setDefaultHandler(e, r = $v) {
    this._defaultHandlerMap.set(r, no(e));
  }
  /**
   * If a Route throws an error while handling a request, this `handler`
   * will be called and given a chance to provide a response.
   *
   * @param {workbox-routing~handlerCallback} handler A callback
   * function that returns a Promise resulting in a Response.
   */
  setCatchHandler(e) {
    this._catchHandler = no(e);
  }
  /**
   * Registers a route with the router.
   *
   * @param {workbox-routing.Route} route The route to register.
   */
  registerRoute(e) {
    this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e);
  }
  /**
   * Unregisters a route with the router.
   *
   * @param {workbox-routing.Route} route The route to unregister.
   */
  unregisterRoute(e) {
    if (!this._routes.has(e.method))
      throw new tr("unregister-route-but-not-found-with-method", {
        method: e.method
      });
    const r = this._routes.get(e.method).indexOf(e);
    if (r > -1)
      this._routes.get(e.method).splice(r, 1);
    else
      throw new tr("unregister-route-route-not-registered");
  }
}
let ta;
const kB = () => (ta || (ta = new PB(), ta.addFetchListener(), ta.addCacheListener()), ta);
function BB(t, e, r) {
  let n;
  if (typeof t == "string") {
    const a = new URL(t, location.href), s = ({ url: o }) => o.href === a.href;
    n = new fa(s, e, r);
  } else if (t instanceof RegExp)
    n = new LB(t, e, r);
  else if (typeof t == "function")
    n = new fa(t, e, r);
  else if (t instanceof fa)
    n = t;
  else
    throw new tr("unsupported-route-type", {
      moduleName: "workbox-routing",
      funcName: "registerRoute",
      paramName: "capture"
    });
  return kB().registerRoute(n), n;
}
function UB(t, e = []) {
  for (const r of [...t.searchParams.keys()])
    e.some((n) => n.test(r)) && t.searchParams.delete(r);
  return t;
}
function* FB(t, { ignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/], directoryIndex: r = "index.html", cleanURLs: n = !0, urlManipulation: i } = {}) {
  const a = new URL(t, location.href);
  a.hash = "", yield a.href;
  const s = UB(a, e);
  if (yield s.href, r && s.pathname.endsWith("/")) {
    const o = new URL(s.href);
    o.pathname += r, yield o.href;
  }
  if (n) {
    const o = new URL(s.href);
    o.pathname += ".html", yield o.href;
  }
  if (i) {
    const o = i({ url: a });
    for (const l of o)
      yield l.href;
  }
}
class MB extends fa {
  /**
   * @param {PrecacheController} precacheController A `PrecacheController`
   * instance used to both match requests and respond to fetch events.
   * @param {Object} [options] Options to control how requests are matched
   * against the list of precached URLs.
   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
   * check cache entries for a URLs ending with '/' to see if there is a hit when
   * appending the `directoryIndex` value.
   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
   * array of regex's to remove search params when looking for a cache match.
   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
   * check the cache for the URL with a `.html` added to the end of the end.
   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
   * This is a function that should take a URL and return an array of
   * alternative URLs that should be checked for precache matches.
   */
  constructor(e, r) {
    const n = ({ request: i }) => {
      const a = e.getURLsToCacheKeys();
      for (const s of FB(i.url, r)) {
        const o = a.get(s);
        if (o) {
          const l = e.getIntegrityForCacheKey(o);
          return { cacheKey: o, integrity: l };
        }
      }
    };
    super(n, e.strategy);
  }
}
function VB(t) {
  const e = Vv(), r = new MB(e, t);
  BB(r);
}
function $B(t) {
  Vv().precache(t);
}
function HB(t, e) {
  $B(t), VB(e);
}
HB([{"revision":null,"url":"assets/index-B-MkzqQl.css"},{"revision":null,"url":"assets/index-B9EKP14x.js"},{"revision":"472f9b284ef4dea02e679a7c9f66aeb7","url":"index.html"},{"revision":"d4bd41f8dd12f1517340d931428983fb","url":"registerSW.js"},{"revision":"04fb41277b2d80dfa79441653613f291","url":"favicon.ico"},{"revision":"cf5eaff918a960ce531aa06af4f66583","url":"icons/android-chrome-192x192.png"},{"revision":"b3a2b02ff54274e88cba679738ae3b04","url":"icons/android-chrome-512x512.png"},{"revision":"fe78c2de6cbe40fab54d42c53c641a48","url":"manifest.webmanifest"}]);
const Hv = {
  apiKey: "AIzaSyC-jTMiDjHNTC6cvSKUU44mVbWwT-ToLxQ",
  authDomain: "mister-x-d6b59.firebaseapp.com",
  databaseURL: "https://mister-x-d6b59-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "mister-x-d6b59",
  storageBucket: "mister-x-d6b59.firebasestorage.app",
  messagingSenderId: "616391598963",
  appId: "1:616391598963:web:da07882b0f481d3000db06",
  measurementId: "G-W66SK677NG"
}, KB = pv(Hv), GB = hB(KB), jB = `${Hv.databaseURL}`;
function qB(t) {
  return (t || "").replace(/[.#$/\[\]\/]/g, "_");
}
async function WB() {
  try {
    const t = await JB("app-db", "settings");
    return await new Promise((e) => {
      const i = t.transaction("settings", "readonly").objectStore("settings").get("deviceName");
      i.onsuccess = () => {
        t.close(), e(i.result || null);
      }, i.onerror = () => {
        t.close(), e(null);
      };
    });
  } catch {
    return null;
  }
}
async function JB(t, e) {
  return new Promise((r, n) => {
    const i = indexedDB.open(t);
    i.onupgradeneeded = () => {
      const a = i.result;
      a.objectStoreNames.contains(e) || a.createObjectStore(e);
    }, i.onsuccess = () => {
      const a = i.result;
      if (a.objectStoreNames.contains(e))
        return r(a);
      const s = a.version + 1;
      a.close();
      const o = indexedDB.open(t, s);
      o.onupgradeneeded = () => {
        const l = o.result;
        l.objectStoreNames.contains(e) || l.createObjectStore(e);
      }, o.onsuccess = () => r(o.result), o.onerror = () => n(o.error);
    }, i.onerror = () => n(i.error);
  });
}
async function zB(t, e) {
  if (!t || !e) return;
  const r = qB(e), n = `${jB}/notifications/${t}/recipients/${r}.json`;
  try {
    await fetch(n, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(!0)
    });
  } catch (i) {
    console.error("[SW] RTDB update failed:", i);
  }
}
pB(GB, async (t) => {
  var s, o, l, u;
  const e = ((s = t == null ? void 0 : t.data) == null ? void 0 : s.title) ?? "Neue Nachricht", r = ((o = t == null ? void 0 : t.data) == null ? void 0 : o.body) ?? "", n = ((l = t == null ? void 0 : t.data) == null ? void 0 : l.url) ?? "/Mister-X/", i = ((u = t == null ? void 0 : t.data) == null ? void 0 : u.messageId) ?? null;
  await self.registration.showNotification(e, {
    body: r,
    icon: "icons/android-chrome-192x192.png",
    badge: "icons/Mister_X_Badge.png",
    data: { url: n }
  });
  const a = await WB();
  console.log("[SW] BG-Nachricht empfangen", { messageId: i, deviceName: a, payload: t }), i && a && await zB(i, a);
})();
self.addEventListener("push", (t) => {
  t.waitUntil(promise);
});
self.addEventListener("notificationclick", (t) => {
  t.notification.close(), t.waitUntil((async () => {
    var n;
    const e = ((n = t.notification.data) == null ? void 0 : n.url) || "/Mister-X/", r = await clients.matchAll({ type: "window", includeUncontrolled: !0 });
    for (const i of r)
      if ("focus" in i && i.url.includes("/Mister-X/")) return i.focus();
    if (clients.openWindow) return clients.openWindow(e);
  })());
});
self.addEventListener("message", (t) => {
  var e;
  ((e = t == null ? void 0 : t.data) == null ? void 0 : e.type) === "SKIP_WAITING" && self.skipWaiting();
});
self.addEventListener("activate", (t) => {
  t.waitUntil(self.clients.claim());
});
